## UASR: Unified Approach to Speech Synthesis and Recognition
## - Utility functions: recognizer(.exe) result post-processing utilities
##
## AUTHOR : Matthias Wolff
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2013-2016 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus-Senftenberg
## - Fraunhofer IKTS, Dresden
## - Chair of System Theory and Speech Technology, TU Dresden
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

## Loads the data files produced by the recognizer from the locations committed
## thorugh the command line arguments.
##
## @cgen:index
## @param nFArg integer
##          One-based index of first command line argument, standard is 1.
## @param iSI object
##          Filled with the session info, can be <code>NULL</code> if not 
##          needed.
## @param itRec fst
##          Filled with the main recognition result, can be <code>NULL</code> if
##          not needed.
## @param itRef fst
##          Filled with the reference recognition result, can be 
##          <code>NULL</code> if not needed.
## @param idNld data
##          Filled with the frame-by-Gaussian neglog. density array, can be 
##          <code>NULL</code> if not needed.
## @param idSig data
##          Filled with the input speech signal, can be <code>NULL</code> if not
##          needed.
## @param itFvr fst
##          Filled with the recognized semantics (feature-value relation), can 
##          be <code>NULL</code> if not needed.
function -RRES_getargs(nFArg,iSI,itRec,itRef,idNld,idSig,itFvr)
{
  itRec if ( nFArg     -argv ) itRec -restore;              end                 # Load main recognition result
  itRef if ( :nFArg+1: -argv ) itRef -restore;              end                 # Load reference recognition result
  idNld if ( :nFArg+2: -argv ) idNld -restore;              end                 # Load neglog. density array
  idSig if ( :nFArg+3: -argv ) "wav" idSig stdfile -import; end                 # Load speech signal
  itFvr if ( :nFArg+4: -argv ) itFvr -restore;              end                 # Load recognized semantics
  iSI   if ( :nFArg+5: -argv ) iSI   -restore;              end                 # Load session info
}

## Computes the per-frame recognition result. The function stips uninteresing
## components, removes epsilon input symbols and adds phoneme (component 
## "~PLB") and output (component "~OLB") label names.
##
## @cgen:index
## @param itRes fst
##          The recognition result transducer (consecutive path though the
##          recognition network).
## @param idNld data
##          The neglog likelihood matrix (records: feature vectors, components:
##          GMMs).
## @param idPhnTab data
##          The phoneme table, phoneme labels are expected in component 0.
## @return A data object containing the processed path. 
function -RRES_perframe(itRes,idNld,idPhnTab)
{
  data idRes;                                                                   # The stripped recognition result
  data idOut;
  data idAux;                                                                   # An auxiliary data object
  data idAux2;
  var  nR;
  var  nXR;
  var  sL;

  ## Strip components                                                           # -------------------------------------
  :itRes.td["~TIS"]: idRes -join;                                               # Keep input symbols (Gaussians)
  :itRes.td["~PHN"]: idRes -join;                                               # Keep phoneme symbols
  :itRes.td["~LSR"]: idRes -join;                                               # Keep phoneme symbols

  ## Remove epsilon input symbols                                               # -------------------------------------
  :idRes["~TIS"].<0: idRes -dmark;                                              # Mark epsilcon records
  idRes 0 0 idRes /mark -delete;                                                # Delete 'em

  ## Get per-frame neglog likelihoods                                           # -------------------------------------
  "~RID" -1 idRes -rindex;                                                      # Add record index component
  :idRes["~RID"]: 0 :idRes["~TIS"]: 0 idNld idAux -lookup_2;                    # Get neglog likelihoods
  0 "~NLL" idAux -set_cname; idAux idRes -join;                                 # Add to stripped recognition result
  idRes ( "~RID" idRes -find_comp ) 1 idRes -delete;                            # Delete record index component

  ## Add symbolic phoneme labels                                                # -------------------------------------
  :idRes["~PHN"]: 0 idPhnTab 0 1 idAux -lookup;                                 # Look up phoneme labels
  0 "~PLB" idAux -set_cname; idAux idRes -join;                                 # Add to stripped recognition result
  
  ## Get per-frame output labels                                                # -------------------------------------
  :itRes.td["~TOS"]: 0 itRes.os 0 1 idOut -lookup;
  0 "~OLB" idOut -set_cname;
  :itRes.td["~TIS"]: idOut -join;
  :itRes.td["~TOS"]: idOut -join;
  
  ## - Move output labels away from epsilon-input transitions                   # - - - - - - - - - - - - - - - - - - -
  "" sL =;                                                                      # Output label aggregation buffer
  -1 nXR =;                                                                     # Last non-epsilon transition
  0 nR =; nR idOut.nrec < while                                                 # Loop over transitions >>
    :sL+=idOut[nR,0];                                                           #   Aggregate output label
    :idOut[nR,1]<0: if                                                          #   Epsilon input symbol >>
      :idOut[nR,0]="";                                                          #     No output
    else                                                                        #   << Non-epsilon input symbol >>
      :idOut[nR,0]=sL;                                                          #     Write aggregated output label
      "" sL =;                                                                  #     Clear label aggregation buffer
      nR nXR =;                                                                 #     Remember last non-eps transition
    end                                                                         #   <<
    nR ++=;                                                                     #   Next transition
  end                                                                           # <<
  ( sL "" != ) ( nXR 0 >= ) && if                                               # Rest in aggregation buffer >>
    :idOut[nXR,0]+=sL;                                                          #   Write to last non-eps transition
  end                                                                           # <<

  ## - Remove epsilon input symbols                                             # - - - - - - - - - - - - - - - - - - -
  :idOut["~TIS"].<0: idOut -dmark;                                              # Mark epsilcon transition
  idOut 0 0 idOut /mark -delete;                                                # Delete 'em
  idOut 0 1 idOut -select;                                                      # Keep only output labels
  idOut idRes -join;                                                            # Join to result

  ## Return result                                                              # ---------------------------------------  
  idRes return;                                                                 # Return result
}

## Returns the recognition result as a string.
##
## @cgen:index
## @param itRes fst
##          The recognition result transducer (consecutive path though the
##          recognition network).
## @return The recognition result as a string.
function -RRES_out(itRes)
{
  data idAux;                                                                   # Auciliary data
  var  sOut;  "" sOut -sset;                                                    # Output string buffer
  var  i;                                                                       # Loop counter

  :itRes.td["~TOS"]: 0 itRes.os 0 1 idAux -lookup;                              # Get output symbols
  0 i =; i idAux.nrec < while                                                   # Loop over transitions >>
    :idAux[i,0]: sOut +=;                                                       #   Aggregate output string 1)
    i ++=;                                                                      #   Next transition
  end                                                                           # <<
  sOut return;                                                                  # Return output string

  ## 1) -strop not used because result may be longer than 255 characters! 
}

## Collects the recognition result into a speech database.
## 
## @cgen:index
## @param idSig data
##          The speech signal.
## @param idRpf data
##          The per-frame recognition result as returned by <a class="code"
##          href="#clp_-RRES_perframe">RRES_perframe</a>.
## @param itFvr fst
##          The recognized semantics (feature-value relation represented by an
##          FST), can be <code>NULL</code> or emtpy. The transliteration is
##          expected as <a href="javascript:__goDlabpro('automatic/fvrtools.html')"
##          >FVR comment string</a> in <code>itFvr.ud.rtext</code>.
function -RRES_collect(idSig,idRpf,itFvr)
{
  data idOrt;                                                                   # Transliteration 
  var  sDate; ( stdprof -date "?-?" "replace" -VAR_strop ) sDate =;             # Current date
  var  sTime; stdprof -time                                sTime =;             # Current time
  var  sTid;  "$[sDate]-$[sTime]"                          sTid  =;             # Turn ID: a time stamp

  ## Get transliteration                                                        # -------------------------------------
  itFvr if
    ( itFvr.ud.rtext " " "split" -VAR_strop ) ' idOrt =;
  else
    ## TODO: Make transliteration from idRpf output labels!
  end
idOrt -print; 1 brk;
}

## EOF
