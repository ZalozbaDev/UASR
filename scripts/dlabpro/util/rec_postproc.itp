## UASR: Unified Approach to Speech Synthesis and Recognition
## - Utility functions: recognizer(.exe) result post-processing utilities
##
## AUTHOR : Matthias Wolff
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2013-2016 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus-Senftenberg
## - Fraunhofer IKTS, Dresden
## - Chair of System Theory and Speech Technology, TU Dresden
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

## Loads the data files produced by the recognizer from the locations committed
## thorugh the command line arguments.
##
## @cgen:index
## @param nFArg integer
##          One-based index of first command line argument, standard is 1.
## @param iSI object
##          Filled with the session info, can be <code>NULL</code> if not 
##          needed.
## @param itRec fst
##          Filled with the main recognition result, can be <code>NULL</code> if
##          not needed.
## @param itRef fst
##          Filled with the reference recognition result, can be 
##          <code>NULL</code> if not needed.
## @param idNld data
##          Filled with the frame-by-Gaussian neglog. density array, can be 
##          <code>NULL</code> if not needed.
## @param idSig data
##          Filled with the input speech signal, can be <code>NULL</code> if not
##          needed.
## @param itFvr fst
##          Filled with the recognized semantics (feature-value relation), can 
##          be <code>NULL</code> if not needed.
function -RRES_getargs(nFArg,iSI,itRec,itRef,idNld,idSig,itFvr)
{
  itRec if ( nFArg     -argv ) itRec -restore;
  itRef if ( :nFArg+1: -argv ) itRef -restore;
  idNld if ( :nFArg+2: -argv ) idNld -restore;
  idSig if ( :nFArg+3: -argv ) "wav" idSig stdfile -import;
  itFvr if ( :nFArg+4: -argv ) itFvr -restore;
  iSI   if ( :nFArg+5: -argv ) iSI   -restore;
}

## Processes a recognition result transducer. The function stips uninteresing
## components, removes epsilon input symbols and adds phoneme label names.
##
## @cgen:index
## @param itRes fst
##          The recognition result transducer (consecutive path though the
##          recognition network).
## @param idNld data
##          The neglog likelihood matrix (records: feature vectors, components:
##          GMMs).
## @param idPhnTab data
##          The phoneme table, phoneme labels are expected in component 0.
## @return A data object containing the processed path. 
function -RRES_process(itRes,idNld,idPhnTab)
{
  data idRes;                                                                   # The stripped recognition result
  data idAux;                                                                   # An auxiliary data object
  data idAux2;
  
  ## Strip components                                                           # -------------------------------------
  :itRes.td["~TIS"]: idRes -join;                                               # Keep input symbols (Gaussians)
  :itRes.td["~PHN"]: idRes -join;                                               # Keep phoneme symbols
  :itRes.td["~LSR"]: idRes -join;                                               # Keep phoneme symbols

  ## Remove epsilon input symbols                                               # -------------------------------------
  :idRes["~TIS"].<0: idRes -dmark;                                              # Mark epsilcon records
  idRes 0 0 idRes /mark -delete;                                                # Delete 'em

  ## Get per-frame neglog likelihoods                                           # -------------------------------------
  "~RID" -1 idRes -rindex;                                                      # Add record index component
  :idRes["~RID"]: 0 :idRes["~TIS"]: 0 idNld idAux -lookup_2;                    # Get neglog likelihoods
  0 "~NLL" idAux -set_cname; idAux idRes -join;                                 # Add to stripped recognition result
  idRes ( "~RID" idRes -find_comp ) 1 idRes -delete;                            # Delete record index component

  ## Add symbolic labels                                                        # -------------------------------------
  :idRes["~PHN"]: 0 idPhnTab 0 1 idAux -lookup;                                 # Look up phoneme labels
  0 "~PLB" idAux -set_cname; idAux idRes -join;                                 # Add to stripped recognition result
  
  idRes return;                                                                 # Return result
}

## Returns the per-frame output labels of the recognition result. 
##
## @cgen:index
## @param itRes fst
##          The recognition result transducer (consecutive path though the
##          recognition network).
## @return A data object containing the frame-wise output labels. 
function -RRES_out(itRes)
{
  data idRes;
  var  nR;
  var  nXR;
  var  sL;
  
  :itRes.td["~TOS"]: 0 itRes.os 0 1 idRes -lookup;
  0 "~OUT" idRes -set_cname;
  :itRes.td["~TIS"]: idRes -join;
  :itRes.td["~TOS"]: idRes -join;
  
  "" sL =;
  -1 nXR =;
  0 nR =; nR idRes.nrec < while
    :sL+=idRes[nR,0];
    :idRes[nR,1]<0: if
      :idRes[nR,0]="";
    else
      :idRes[nR,0]=sL;
      "" sL =;
      nR nXR =;
    end
    nR ++=;
  end
  ( sL "" != ) ( nXR 0 >= ) && if
    :idRes[nXR,0]+=sL;    
  end

  ## Remove epsilon input symbols                                               # -------------------------------------
  :idRes["~TIS"].<0: idRes -dmark;                                              # Mark epsilcon records
  idRes 0 0 idRes /mark -delete;                                                # Delete 'em
  idRes 0 1 idRes -select;                                                      # Keep only output labels
  
  idRes return;
}

## EOF
