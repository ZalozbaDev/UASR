## UASR: Unified Approach to Speech Synthesis and Recognition
## - Universal Primary and secondary feature analysis and synthesis
##
## AUTHOR : Frank Duckhorn
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2013 UASR contributors (see COPYRIGHT file)
## - Chair of System Theory and Speech Technology, TU Dresden
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

## UPFA transformation function with fourier analysis
##
## @param idFea  Current feature data object
## @param iPfa   Primary feature analysis config object
function -UPFA_trf_FFT(idFea,iPfa)
{
  idFea fft idFea.nScale ./ idFea =;
}

## UPFA transformation function with wavelet analysis
##
## @param idFea  Current feature data object
## @param iPfa   Primary feature analysis config object
function -UPFA_trf_WVL(idFea,iPfa)
{
  idFea iPfa.wvl_di iPfa.wvl_level wvl idFea =;
}

## UPFA transformation function with generalized mel-cepstrum analysis
##
## @param idFea  Current feature data object
## @param iPfa   Primary feature analysis config object
function -UPFA_trf_MGC(idFea,iPfa)
{
  idFea iPfa.mgc_gamma iPfa.mgc_lambda iPfa.mgc_coeff mgcep idFea =;
}

## UPFA transformation mapping function with absolute value calculation
##
## @param idFea  Current feature data object
function -UPFA_tmap_ABS(idFea)
{
  idFea abs idFea =;
}

## UPFA transformation mapping function taking the logarithm
##
## @param idFea  Current feature data object
function -UPFA_tmap_LOG(idFea)
{
  idFea abs .ln
    idFea.nScale ln -1 *
    max idFea =;
}

## UPFA transformation mapping function with no operation
##
## @param idFea  Current feature data object
function -UPFA_tmap_NONE(idFea)
{
  leave;
}

## UPFA filter mapping function taking the logarithm
##
## @param idFea  Current feature data object
function -UPFA_fmap_LOG(idFea)
{
  idFea .ln
    idFea.nScale ln +
    0 max
    idFea =;
}

## UPFA filter mapping function with subtraction of quantization energy
##
## @param idFea  Current feature data object
function -UPFA_fmap_QEN(idFea)
{
  idFea idFea.nScale ln + idFea =;
}

## UPFA filter mapping function with no operation
##
## @param idFea  Current feature data object
function -UPFA_fmap_NONE(idFea)
{
  leave;
}

## Universal primary feature analysis
##
## This function preforms the universal primary feature analysis.
##
## @param idSig data
##          Signal to be analyzed, may contain multiple signal channels,
##          may contain one or multiple label components.
## @param idPM data
##          Pitch marks for pitch synchronous analysis, may be NULL
## @param idFea data
##          Will be filled with the feature output vectors. Labels will be
##          copied from <code>idSig</code>.
## @param idDummy data
##          Only for compatible with imaginary data object in dlabpro's feature
##          processors. Should be NULL.
## @see -UPFA_init
function -UPFA_ana(idSig,idPM,idFea,idDummy,iPfa)
{
  idSig idFea =;                                                                # Copy signal to feature object

  var nC;                                                                       # Channel index
  ## Check for non-numeric components                                           # -------------------------------------
  0 nC =; nC idFea.dim < while;                                                 # Iterate over components in signal >>
    nC idFea -get_comp_type 256 <= if break end;                                #   Break on label component
  nC ++=; end;                                                                  # <<
  ## Extract labels into subobject idFea.idL                                    # -------------------------------------
  nC idFea.dim < if;                                                            # If there are label components >>
    data idFea.idLab;                                                           #   Create label subobject idFea.idLab
    0 nC =; nC idFea.dim < while;                                               #   Iterate over components in signal >>
      nC idFea -get_comp_type 256 <= if;                                        #     Check for label component >>
        :idFea[nC]: idFea.idLab -join;                                          #       Copy labels
        idFea nC 1 idFea -delete;                                               #       Remove labels from signals
      else;                                                                     #     << Numeric component >>
        nC ++=;                                                                 #       Go to next component
      end;                                                                      #     <<
    end;                                                                        #   <<
  end                                                                           # <<

  ## Remove direct component if configured                                      # -------------------------------------
  iPfa.rmdc if idFea rmdc idFea = end;                                          # Remove direct component

  ## Framing                                                                    # -------------------------------------
  idPM NULL != if;                                                              # If there are pitch marks >>
    idFea iPfa.wlen iPfa.crate idPM iPfa.nperiods sframe idFea =;               #   Perform pitch synchron framing
  else;                                                                         # << Without pitch marks >>
    idFea iPfa.wlen iPfa.crate frame idFea =;                                   #   Perform fixed length framing
  end;                                                                          # <<
  ## Windowing                                                                  # -------------------------------------
  idFea iPfa.wlen iPfa.len iPfa.wtype iPfa.wnorm window noisify idFea =;        # Perform windowing & noisify

  ## Transformation + mapping                                                   # -------------------------------------
  idFea iPfa -UPFA_trf_$[iPfa.trf];                                             # Call transformation function
  idFea -UPFA_tmap_$[iPfa.tmap];                                                # Call transformation mapping function
  # TODO: noiserdc

  ## Filter matrix                                                              # -------------------------------------
  iPfa.fil -is_empty not if iPfa.fil idFea * idFea =; end                       # Apply filter matrix if configured

  ## Output dimension                                                           # -------------------------------------
  idFea.dim iPfa.dim > if idFea iPfa.dim :idFea.dim-iPfa.dim: idFea -delete; end #Clip dimension to configured dimension
  idFea.dim iPfa.dim < if -type double :iPfa.dim-idFea.dim: idFea -addncomps;end #Expand dimension to configured dimension

  ## Filter mapping                                                             # -------------------------------------
  idFea -UPFA_fmap_$[iPfa.fmap];                                                # Call filter mapping function

  ## Append labels                                                              # -------------------------------------
  "idFea.idLab" "data" ?instance if; idFea.idLab idFea -join; end;              # Append labels to features
}


## Universal primary feature synthesis
##
## This function preforms the universal primary feature synthesis.
## It is currently not yet implemented!
##
## @param idFea data
##          Features to be synthesized.
## @param idControl data
##          May contain pitch marks or into data.
## @param idSyn data
##          Will be filled with the synthesized signal. Labels will be
##          copied from <code>idSig</code>.
## @see -UPFA_init
function -UPFA_syn(idFea,idControl,idSyn)
{
  "Universal synthesis is currently not implemented." -ERROR;                   # Error
}

## Initialize universal primary feature analysis
##
## This function creates the object .__FEA_iPfa and sets up
## the methods -analyze and -synthesize. Additionally it reads
## all required configuration keys. Finally the object is
## compatible to feature analysis/synthesis processor instances
## in dlabpro.
##
## @global .__FEA_iPfa                      CW
## @global .__FEA_sAnaOpt                   CW
## @global .__FEA_sSynOpt                   CW
## @global &lt;uasr.pfa.crate&gt;           R
## @global &lt;uasr.pfa.srate&gt;           R
## @global &lt;uasr.pfa.wlen&gt;            R
## @global &lt;uasr.pfa.window&gt;          R
## @global &lt;uasr.pfa.len&gt;             R
## @global &lt;uasr.pfa.dim&gt;             R
## @global &lt;uasr.pfa.UPFA.*&gt;          R
function -UPFA_init()
{
  ## Create and configure signal analysis/synthesis processor                   # -------------------------------------
  object iPfa;                                                                  # Create analysis processor

  ## Read configuration key for UPFA with up to two fallback keys
  ##
  ## This function reads the config key <code>uasr.pfa.UPFA.$[sCfgN]</code>.
  ## If this key is not available it falls back to <code>uasr.$[sCfgO1]</code>
  ## and than to <code>uasr.$[sCfgO2]</code>. If non of the keys is
  ## available <code>def</code> is used.
  ##
  ## The function creates a subobject in <code>.__FEA_iPfa</code> of class
  ## <code>var</code> to store the value of the key. Additionally the value is
  ## returned.
  ##
  ## The first character of <code>sType</code> determines the <code>-?set</code>
  ## method to write the value into an instance of class <code>var</code>.
  ## The remaining characters maybe one or more of the following:
  ## <ul>
  ## <li><code>l</code>: Do not create subobject in <code>.__FEA_iPfa</code>, only return the value.
  ## <li><code>f</code>: Fail if the working function <code>-UPFA_$[sCfgN]_$[val]</code> does not exist.
  ## <li><code>F</code>: Fail if the init function <code>-UPFA_init_$[sCfgN]_$[val]</code> does not exist.
  ## </ul>
  ##
  ## @global &lt;uasr.pfa.UPFA.$[sCfgN]&gt;   R
  ## @global &lt;uasr.$[sCfgO1]&gt;           R
  ## @global &lt;uasr.$[sCfgO2]&gt;           R
  function -UPFA_cfg(sCfgN,sCfgO1,sCfgO2,def,sType)
  {
    function -UPFA_cfgo(sCfgO,val)
    {
      "" sCfgO == if val return end;
      data idCfgO;
      { "$[sCfgO]" } ":" "split" idCfgO -strop;
      idCfgO.dim 2 == if;
        :idCfgO[0,0]: "" "S" -CFG_get_ex :idCfgO[0,1]: "search" -VAR_strop 0 >=
          if TRUE else FALSE end val =;
        else;
        sCfgO val "S" -CFG_get_ex val =;
      end;
      val return;
    }

    sType "1" "left"  -VAR_strop var sLType;                                    # Get data type
    sType "l" "search" -VAR_strop 0 >= var bLoc;                                # Check for local flag
    sType "f" "search" -VAR_strop 0 >= var bFnc;                                # Check for function flag
    sType "F" "search" -VAR_strop 0 >= var bIniFnc;                             # Check for init function flag

    def var val;                                                                # Start with default value
    sCfgO2 val -UPFA_cfgo val =;                                                # Try to read key sCfgO2
    sCfgO1 val -UPFA_cfgo val =;                                                # Try to read key sCfgO1
    "pfa.UPFA.$[sCfgN]" val "S" -CFG_get_ex val =;                              # Try to read key pfa.UPFA.sCfgN

    bFnc "-UPFA_$[sCfgN]_$[val]" "function" ?instance not && if;                # Check for existance of working function >>
      "Function -UPFA_$[sCfgN]_$[val] does not exist (fix uasr.pdf.UPFA.$[sCfgN])" -ERROR;
      def val =;                                                                #   Fallback to default
    end;                                                                        # <<
    bIniFnc "-UPFA_init_$[sCfgN]_$[val]" "function" ?instance not && if;        # Check for existance of init function >>
      "Function -UPFA_init_$[sCfgN]_$[val] does not exist (fix uasr.pdf.UPFA.$[sCfgN])" -ERROR;
      def val =;                                                                #   Fallback to default
    end;                                                                        # <<

    var vout; val vout -$[sLType]set;                                           # Setup output var instance
    bLoc not if;                                                                # If we should write into iPfa >>
      object iP; iPfa iP =;                                                     #   Copy iPfa locally
      var iP.$[sCfgN];                                                          #   Create subobject of class var
      vout iP.$[sCfgN] -$[sLType]set;                                           #   Write config value
      iP iPfa =;                                                                #   Copy local iPfa to global one
    end;                                                                        # <<
    vout return;                                                                # Return configuration key value
  }

  ## Init filter for wavelet transformation
  ##
  ## @global &lt;uasr.pfa.UPFA.trf.WVL.type&gt;   R
  ## @global &lt;uasr.pfa.UPFA.trf.WVL.level&gt;  R
  ## @local  iPfa.wvl_di                          CW
  ## @local  iPfa.wvl_level                       CW
  ## @local  sDefTMap                             W
  ## @local  sDefFil                              W
  ## @local  sDefFMap                             W
  function -UPFA_init_trf_WVL()
  {
    "NONE" sDefTMap =;                                                          # Set default transformation mapping method
    "NONE" sDefFMap =;                                                          # Set default filter mapping method
    "NONE" sDefFil  =;                                                          # Set default filter matrix mode

    "trf.WVL.type"  "pfa.FWT.wvltype" "" "d4" "sl" -UPFA_cfg var sType;         # Get wavelet type from config
    "trf.WVL.level" "pfa.FWT.level"   ""   -1 "vl" -UPFA_cfg var nLevel;        # Get wavelet detail level from config

    4 var nDI;                                                                  # Set default daubechies index
    "haar" sType == if 2 nDI = end;                                             # Update daubechies index on haar type
    "d" sType "1" "left" -VAR_strop == if;                                      # Update daubechies index from dN type >>
      sType sType "" "len" -VAR_strop -- "right" -VAR_strop nDI -vset;          #   Read index number for type
    end;                                                                        # <<

    object iP; iPfa iP =;                                                       # Copy iPfa locally
    nDI    var iP.wvl_di;                                                       # Write daubechies index
    nLevel var iP.wvl_level;                                                    # Write wavelet detail level
    iP iPfa =;                                                                  # Copy local iPfa to global one
  }

  ## Init filter for generalized mel-cepstrum transformation
  ##
  ## @global &lt;uasr.pfa.UPFA.trf.MGC.gamma&gt;  R
  ## @global &lt;uasr.pfa.UPFA.trf.MGC.lambda&gt; R
  ## @global &lt;uasr.pfa.UPFA.trf.MGC.coeff&gt;  R
  ## @local  iPfa.mgc_gamma                       CW
  ## @local  iPfa.mgc_lambda                      CW
  ## @local  iPfa.mgc_coeff                       CW
  ## @local  sDefTMap                             W
  ## @local  sDefFil                              W
  ## @local  sDefFMap                             W
  function -UPFA_init_trf_MGC()
  {
    "NONE" sDefTMap =;                                                          # Set default transformation mapping method
    "NONE" sDefFMap =;                                                          # Set default filter mapping method
    "NONE" sDefFil  =;                                                          # Set default filter matrix mode

    object iP; iPfa iP =;                                                       # Copy iPfa locally
    "trf.MGC.gamma"  "" "" -0.5 "vl" -UPFA_cfg var iP.mgc_gamma;                # Get MGC gamma from config
    "trf.MGC.lambda" "" "" 0.47 "vl" -UPFA_cfg var iP.mgc_lambda;               # Get MGC lambda from config
    "trf.MGC.coeff"  "" ""   24 "vl" -UPFA_cfg var iP.mgc_coeff;                # Get MGC number of coefficients from config
    iP iPfa =;                                                                  # Copy local iPfa to global one
  }

  ## Init filter matrix for mel-filter
  ##
  ## @global &lt;uasr.pfa.UPFA.fil.MEL.lambda&gt; R
  ## @global &lt;uasr.pfa.UPFA.fil.MEL.type&gt;   R
  ## @local  iPfa.dim                             R
  ## @local  iPfa.fil                             W
  ## @local  sDefTMap                             W
  ## @local  sDefFMap                             W
  function -UPFA_init_fil_MEL()
  {
    "fil.MEL.lambda" ""                "" 0.47 "vl" -UPFA_cfg var nLambda;      # Get Lambda from configuration
    "fil.MEL.type"   "pfa.MEL.mf_type" "" "MT" "sl" -UPFA_cfg var sType;        # Get MEL-Type from configuration

    sType "S" "search" -VAR_strop 0 >= if;                                      # If we use sinc transfer functions >>
      "LOG" sDefTMap =;                                                         #   Update default transformation mapping method
      "QEN" sDefFMap =;                                                         #   Update default filter mapping method
    end;                                                                        # <<
    
    iPfa.fil -reset;                                                            # Reset filter matrix
    iPfa.len unit nLambda iPfa.dim sType mfbs iPfa.fil =;                       # Get filter matrix form analysis of unity vectors
  }

  ## Init filter with no operation (stands for identity matrix)
  ##
  ## @local  iPfa.fil                    W
  function -UPFA_init_fil_NONE()
  {
    iPfa.fil -reset;                                                            # Reset filter matrix
  }

  ## Create session persistent variables                                        # -------------------------------------
  ".__FEA_iPfa"      ""   ?instance     if .__FEA_iPfa -destroy;  end           # Destroy previous analysis processor
  ".__FEA_sAnaOpt"  "var" ?instance not if "" var .__FEA_sAnaOpt; end           # Options on -analyze
  ".__FEA_sSynOpt"  "var" ?instance not if "" var .__FEA_sSynOpt; end           # Options on -synthesize

  ## Common configuration                                                       # -------------------------------------
  "srate"    "sig.srate"            ""      16000 "v"   -UPFA_cfg;              # Set sampling rate
  "crate"    "pfa.crate"            ""        160 "v"   -UPFA_cfg;              # Set frame continuation rate
  "wlen"     "pfa.wlen"             ""        400 "v"   -UPFA_cfg;              # Set window length
  "wtype"    "pfa.window"           "" "Blackman" "s"   -UPFA_cfg;              # Set window type
  "len"      "pfa.len"              ""        512 "v"   -UPFA_cfg;              # Set frame length
  "dim"      "pfa.dim"              ""         30 "v"   -UPFA_cfg;              # Set primary feature vector dimension

  ## UPFA configuration                                                         # -------------------------------------
  "ABS" var sDefTMap;                                                           # Default transformation mapping method
  "LOG" var sDefFMap;                                                           # Default filter mapping method
  "MEL" var sDefFil;                                                            # Default filter type            
  "rmdc"     "pfa.anaoptions:/rmdc" ""      FALSE "b"   -UPFA_cfg;              # Set remove mean
  "wnorm"    "pfa.FBA.wnorm"        ""      FALSE "b"   -UPFA_cfg;              # Set window normalization
  "nperiods" "pfa.FBA.n_periods"    ""          2 "v"   -UPFA_cfg;              # Set maximal number of periods
  "trf"      ""                     ""      "FFT" "sf"  -UPFA_cfg;              # Set signal transformation method
  "-UPFA_init_trf_$[iPfa.trf]" "function" ?instance if                          # If there is a transformation init function >>
    -UPFA_init_trf_$[iPfa.trf];                                                 #   Call transformation init funtcion
  end                                                                           # <<
  "fil"      ""                     ""    sDefFil "slF" -UPFA_cfg var sFil;     # Get filter matrix type
  data iPfa.fil;  -UPFA_init_fil_$[sFil];                                       # Set filter matrix
  "tmap"     ""                     ""   sDefTMap "sf"  -UPFA_cfg;              # Set transformation mapping type
  "fmap"     ""                     ""   sDefFMap "sf"  -UPFA_cfg;              # Set filter mapping type

  ## Functions                                                                  # -------------------------------------
  function iPfa.-analyze;    /disarm -UPFA_ana /disarm iPfa.-analyze    =;      # Set analysis function
  function iPfa.-synthesize; /disarm -UPFA_ana /disarm iPfa.-synthesize =;      # Set synthesis function

  ## Finalize                                                                   # -------------------------------------
  object .__FEA_iPfa; iPfa .__FEA_iPfa =;                                       # Create global object and copy proc.
}

