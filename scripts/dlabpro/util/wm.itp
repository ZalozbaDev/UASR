## UASR: Unified Approach to Signal Synthesis and Recognition
## - Utility functions: Finite state world modeling
##
## AUTHOR : Matthias Wolff, Werner Meyer
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2014-2015 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"$UASR_HOME/scripts/dlabpro/util/cfg.itp"  /noerror include;                    # UASR configutation utilities
"$UASR_HOME/scripts/dlabpro/util/fst.itp"  /noerror include;                    # FST utilities
"$UASR_HOME/scripts/dlabpro/util/os.itp"   /noerror include;                    # OS utilities
"$UASR_HOME/scripts/dlabpro/util/uasr.itp" /noerror include;                    # UASR utilities
"$UASR_HOME/scripts/dlabpro/util/var.itp"  /noerror include;                    # Variable utilities

var __wm_sNcTdQR; "~QR" __wm_sNcTdQR =;                                         # Q-value/reward component

## -- World model/inner map editing, rendering and auxiliary functions --

## Creates a new empty world automaton.
##
## @cgen:index
## @param itWm fst
##          Filled with the new world automaton. Any present data will be 
##          deleted.
## @return void
function -WM_init(itWm)
{
  itWm -reset;                                                                  # Reset target
  "world" itWm /fsa /lsr -addunit;                                              # Create weighted acceptor
  "NAME" 255 itWm.sd -addcomp;                                                  # State name
  itWm.NC_TD_RC ( -type int    ) itWm.td -addcomp;                              # Add trans. reference counter comp.
  .__wm_sNcTdQR ( -type double ) itWm.td -addcomp;                              # Add Q-value/reward component
}

## Returns the zero-based index of an action in the input symbol table if the
## world model. If <code>act</code> is numeric or can be converted to a number,
## the function returns the numeric value of <code>act</code>. Otherwise the
## function will look up the action named <code>act</code> in the input symbol
## table and return its zero-based index. If no action named <code>act</code> is
## found, the function will add the action.
##
## <p><b>TODO:</b> Function is a bit strange; straighten it out!</p> 
##
## @cgen:index
## @param act variant
##          The zero-based action index or the action name.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the action in the input symbol table. 
function -WM_getactionid(act,itWm)
{
  var nAct;
  act nAct /noerror -vset ?error not if nAct return; end 

  data idAct; { "" } idAct =; :idAct[0,0]=act;
  data idAux;
  
  idAct itWm.is 0 0 idAux /noerror -gen_index ?error not if
    :idAux[0,0]>=0: if :idAux[0,0]: return; end
  end
  
  idAct itWm.is -cat;
  itWm.is.nrec -- return;
}

## Deletes an action and all transitions accepting that action from a world 
## automaton.
##
## @cgen:index
## @param act variant
##          The zero-based action index or the action name.
## @param itWm fst
##          The world automaton.
## @return void
function -WM_delaction(act,itWm)
{
  var nAct; ( act itWm -WM_getactionid ) nAct =;                                # Get the action index
  :itWm.td[itWm.NC_TD_TIS].==nAct: itWm.td -dmark;                              # Mark transitions accepting action
  itWm.td 0 0 itWm.td /mark -delete;                                            # Delete them
#  :itWm.td[itWm.NC_TD_TIS]-=(itWm.td[itWm.NC_TD_TIS].>nAct);                    # Adjust input symbol indices >nAct
#  itWm.is nAct 1 itWm.is /rec -delete;                                          # Delete nAct from input symb. table
  :itWm.is[nAct,0]="";                                                          # Clear symbol
  :itWm.ud[0,itWm.IC_UD_XT]=itWm.td.nrec;                                       # Adjust transition count of unit 0
}

## Determines if an action is ineffective. An action is ineffective iff it never
## changes the state of the world, i.e. no transition or only self loops accept 
## the action.
##
## @cgen:index
## @param act variant
##          The zero-based action index or the action name.
## @param itWm fst
##          The world automaton.
## @return <code>TRUE</code> if the action is ineffective, <code>FALSE</code>
##         otherwise.
function -WM_isineffective(act,itWm)
{
  var nAct; ( act itWm -WM_getactionid ) nAct =;                                # Get the action index
  data idTd; itWm.td idTd -copy;                                                # Copy transition table of world
  :idTd[itWm.NC_TD_TIS].!=nAct: idTd -dmark;                                    # Mark transitions not accepting action
  idTd 0 0 idTd /mark -delete;                                                  # Delete them
  idTd -is_empty if TRUE return; end                                            # Action not used at all -> ineffective
  :idTd[itWm.IC_TD_INI].==idTd[itWm.IC_TD_TER]: idTd =;                         # Find loops among remaining trans.
  idTd NULL 0 "min" idTd /rec -aggregate;                                       # Test whether they are ALL loops
  :idTd[0,0]==1: return;                                                        # Return that
}

## Ensures the presence of the specified state ID in a world automaton.
##
## @cgen:index
## @param nS integer
##          The zero-based index of the state to ensure. If the world model in
##          <code>itWm</code> contains fewer than <code>nS</code>+1 states, the
##          function will add new states.
## @param itWm fst
##          The world model in unit 0. If empty, the function will create a new 
##          world model.
## @return void
function -WM_ensurestate(nS,itWm)
{
  itWm.ud -is_empty if itWm -WM_init; end                                       # Init world automaton if empty
  var nXS; :nXS = itWm.ud[0,itWm.IC_UD_XS];                                     # Number of states in current world
  var nIcSn; ( "NAME" itWm.sd -find_comp ) nIcSn =;                             # Component index of state name
  :nS>=nXS: if                                                                  # Need new states? Yes >>
    0 :nS-nXS+1: itWm -addstates;                                               #   Create new states
    nIcSn -1 > if                                                               #   Have state names? Yes >>
      nXS nS =; :nS<itWm.ud[0,itWm.IC_UD_XS]: while                             #     Iterate new states >>
        "$[nS]" nS nIcSn itWm.sd -store;                                        #       Set state name
        nS ++=;                                                                 #       Next state
      end                                                                       #     <<
    end                                                                         #   <<
  end                                                                           # <<
}

## Determines if a goal can be reached from a specified state. The function
## computes the state potentials. A state is forward-connected iff its state
## potential is not infinity (world automata initialized through <a 
## href="#clp_-WM_init">-WM_init</a> have logarithmic weights).
##
## @cgen:index
## @param nS integer
##          The zero-based index of the state to check.
## @param itWm fst
##          The world automaton or agent's inner map of the world.
## @return <code>TRUE</code> if a goal can be reached from the state, 
##         <code>FALSE</code> otherwise.
## @see -WM_ismastered
function -WM_pathtogoal(nS,itWm)
{
  fst itAux; itWm itAux =;                                                      # Copy world automaton
  0 itAux -potential;                                                           # Compute state potentials
  :itAux.sd[nS,"~POT"]<1e308: return;                                           # Return (potential of nS) < infinity
}

## Finds a transition in a world automaton.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition, -1: any terminal state.
## @param nAct integer
##          The action of the transition.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the first matching transision, or -1 if 
##         no matching transition was not found. 
function -WM_findtrans(nIni,nTer,nAct,itWm)
{
  data idTd;   itWm.td 0 :itWm.ud[0,itWm.IC_UD_XT]: idTd /rec -select;          # Get transition table of unit 0
  data idMark;                                                                  # Transition marking list
  idTd -is_empty if -1 return; end                                              # No transitions -> return not found

  "IDX" ( type int ) idTd -addcomp;                                             # Add index component
  :idTd.dim-1: 1 idTd /comp -mark; 0 1 idTd /mark -fill;                        # Fill index component
  :(idTd[itWm.IC_TD_INI].==nIni).&&(idTd[itWm.NC_TD_TIS].==nAct): idMark =;     # Match initial state and action
  nTer 0 >= if :idMark.&&(idTd[itWm.IC_TD_TER].==nTer): idMark =; end           # If term. state specified, match it
  idMark idTd /comp -dmark;                                                     # Mark matching transition(s)
  idTd 0 0 idTd /mark -select;                                                  # Discard unmarked transitions
  :idTd.nrec==0: if -1 return; end                                              # No matching trans. -> ret. not found
  :idTd[0,idTd.dim-1]: return;                                                  # Return index of first match
}

## Adds a transition to a world automaton. If the transition already exists and
## the transition table of <code>itWm</code> contains a reference counter 
## component, the function will increment the reference counter.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition.
## @param act variant
##          The zero-based action index or the action name.
## @param bFinal boolean
##          Indicates whether the terminal state is final.
## @param itWm fst
##          The world automaton. If empty, the function will create a new world
##          model in unit 0.
## @return The zero-based transition index of the added/updated transition.
function -WM_addtrans(nIni,nTer,act,bFinal,itWm)
{
  var nAct; ( act itWm -WM_getactionid ) nAct =;                                # Get the action index
  :max(nIni,nTer): itWm -WM_ensurestate;                                        # Ensure states for new transition
  var nT; ( nIni nTer nAct itWm -WM_findtrans ) nT =;                           # Find specified transition
  nT 0 < if                                                                     # Does not yet exist >>
    var sOpts; bFinal if "/final" else "" end sOpts =;                          #   Options to -addtrans
    0 nIni nTer itWm $[sOpts] -addtrans;                                        #   Add transition
    :itWm.ud[0,itWm.IC_UD_XT]-1: nT =;                                          #   Index of newly added transition
    :itWm.td[nT,itWm.NC_TD_TIS]=nAct;                                           #   Set action ID (trans. input symbol)
  end                                                                           # <<
  :itWm.td[nT,itWm.NC_TD_RC]++;                                                 # Increment trans. reference counter
  nT return;                                                                    # Return transition index
}

## Renders a world automaton using the GraphViz toolkit. The function expects
## the GraphViz executables to be found in the path environment variable.
##
## @cgen:index
## @param sFname string
##          The name of the output file.
## @param sTool string
##          The GraphViz rendering tool, can be <code>NULL</code> which is 
##          equivalent to "fdp -Gmaxiter=10000".
## @param sFormat string
##          The output format; "dot" or any of the output file formats supported
##          by GraphViz.
## @param sMode string
##          Empty string (default operation) or any combination of the following 
##          characters:
##          <table cellpadding="3" style="margin-top:6pt; margin-bottom:6pt;">
##            <tr><th>Character</th><th>Description</th></tr>
##            <tr><td>E</td><td>Skip entry transitions (for legibility)</td></tr>
##            <tr><td>F</td><td>Use fix state positions<sup>1)</sup></td></tr>
##            <tr><td>L</td><td>Display Q-values/rewards as line widths<sup>2)</sup></td></tr>
##            <tr><td>P</td><td>Prefix action names with "a_"</td></tr>
##            <tr><td>Q</td><td>Display Q-values/rewards in transition labels</td></tr>
##          </table>
##          <sup>1)</sup> requires that the state table <code>itWm.sd</code> of
##          the world automaton contains two numeric components named "POSX" and
##          "POSY" specifying the state positions<br>
##          <sup>2)</sup> effective only if format is "eps"
## @param itWm fst
##          The world model to be rendered.
## @return void
function -WM_render(sFname,sTool,sFormat,sMode,itWm)
{
  ## Initial checks                                                             # -------------------------------------
  itWm.ud.nrec 1 != if                                                          # Not exactly one unit in world >>
    "itWm must contain exactly one unit." -ERROR; -list trace;                  #   Error and stack trace
    leave;                                                                      #   No service!
  end                                                                           # <<
  sTool not if "fdp -Gmaxiter=10000" sTool =; end                               # Set default renderer

  ## Local functions and objects                                                # -------------------------------------
  function -get_tis(nT,itWm)                                                    # Get input symbol of transition
  {                                                                             # <<
    var nTis; :itWm.td[nT,itWm.NC_TD_TIS]: nTis =;                              #   Input symbol index
    nTis  0 >= if :itWm.is[nTis,0]: return; end                                 #   Look-up in symbol table
    nTis -1 == if "eps" return; end                                             #   Epsilon symbol
    nTis -2 == if "dlt" return; end                                             #   Delta symbol
    "?" return;                                                                 #   Dunno...
  }                                                                             # <<

  DGen iDG;                                                                     # The DOT document
  data idAux;
  var  nIcsdX; ( "POSX" itWm.sd -find_comp ) nIcsdX =;                          # X-coordinate comp. in state table
  var  nIcsdY; ( "POSY" itWm.sd -find_comp ) nIcsdY =;                          # Y-coordinate comp. in state table
  var  bNoEnt; ( ( sMode "E" "search" -VAR_strop ) 0 >= ) bNoEnt =;             # Do not render entry transitions
  var  bPin;   ( ( sMode "F" "search" -VAR_strop ) 0 >= ) bPin   =;             # Use fix state positions
  var  bLw;    ( ( sMode "L" "search" -VAR_strop ) 0 >= ) bLw    =;             # Q-values/rewards as line widths
  var  bPfx;   ( ( sMode "P" "search" -VAR_strop ) 0 >= ) bPfx   =;             # Prefix action names with "a_"
  var  bQr;    ( ( sMode "Q" "search" -VAR_strop ) 0 >= ) bQr    =;             # Display Q-values/rewards
  var  sAttr;                                                                   # State attributes
  var  nQr;                                                                     # Q-value or reward of transition
  var  nQrMax;                                                                  # Max. Q-value or reward
  var  nQrMin;                                                                  # Min. Q-value or reward
  var  nLw;                                                                     # Line width in inch
  var  i;                                                                       # Loop counter

  ## Some more checks                                                           # -------------------------------------
  :bPin && (nIcsdX<0 || nIcsdY<0): if                                           # "F"-mode but no state pos. found >>
    "State table does not contain state positions. Ignoring mode 'P'."          #   |
    1 -WARNING;                                                                 #   Warning
    FALSE bPin =;                                                               #   Do not fix states
  end                                                                           ## <<

  ## Begin DOT document                                                         # -------------------------------------
  "digraph ${itWm.ud[0,0]} {\n"                                         iDG >>; # DOT output
  bPin not if                                                                   # Fix state positions >>
    "  sep=\"+30\"; overlap=\"vpsc\";\n"                                iDG >>; #   DOT output
  end                                                                           # <<
  "  node [fontname=Helvetica, shape=circle, fixedsize=true];\n"        iDG >>; # DOT output
  "  edge [fontname=Helvetica];\n"                                      iDG >>; # DOT output

  ## States                                                                     # -------------------------------------
  0 i =; i itWm.sd.nrec < while                                                 # Loop over states >>
    :bNoEnt && (i==0): if i ++=; continue; end                                  #   Skip start state
    "" sAttr =;                                                                 #   Clear state attributes
    bPin if                                                                     #   Fix state positions >>
      :sAttr="pos=\"${itWm.sd[i,nIcsdX]},${itWm.sd[i,nIcsdY]}!\"";              #     Create "pos" attribute
    end                                                                         #   <<
    :itWm.sd[i,0]%2==1: if # HACK: should be (itWm.sd[i,0]&0x0001)>0!           #   State is final >>
      :sAttr!="": if :sAttr+=", "; end :sAttr+="peripheries=2";                 #     Create "peripheries" attribute
    end                                                                         #   <<
    ( i itWm -WM_pathtogoal ) not if                                            #   Goal cannot be reached >>
      :sAttr!="": if :sAttr+=", "; end :sAttr+="style=filled";                  #     Create "filled" attribute
    end                                                                         #   <<
    "  \"$[i]\" [ " sAttr + " ];\n" +                                   iDG >>; #   DOT output
    i ++=;                                                                      #   Next state
  end                                                                           # <<
  
  ## Transitions                                                                # -------------------------------------
  bLw if                                                                        # Rendering line widths >>
    1e308 nQrMin =;-1e308 nQrMax =; 0 i =; i itWm.td.nrec < while               #   Loop over transitions >>
      :bNoEnt && (itWm.td[i,itWm.IC_TD_INI]==0): if i ++=; continue; end        #     Skip entry transitions
      :nQrMax=max(nQrMax,itWm.td[i,"~QR"]);                                     #     Aggregate maximum Q-value/reward
      :nQrMin=min(nQrMin,itWm.td[i,"~QR"]);                                     #     Aggregate minimum Q-value/reward
      i ++=;                                                                    #     Next transition
    end                                                                         #   <<
    :nQrMin==nQrMax: if FALSE bLw =; end                                        #   Min==max --> no line weights
  end                                                                           # <<
  0 i =; i itWm.td.nrec < while                                                 # Loop over transitions >>
    :bNoEnt && (itWm.td[i,itWm.IC_TD_INI]==0): if i ++=; continue; end          #   Skip entry transitions
    :nQr=ent(itWm.td[i,"~QR"]*1000)/1000;                                       #   Get Q-value/reward
    "label=\"" ( bPfx if "a_" else "" end ) + ( i itWm -get_tis ) +             #   |
      ( bQr if ":$[nQr]" else "" end ) + "\"" +  sAttr =;                       #   Create "label" attribute
    bLw if                                                                      #   Rendering line widths >>
      :nLw = max(0.1,min(5,ent((nQr-nQrMin)/(nQrMax-nQrMin)*50)/10));           #     Compute line width (0.1...5.0 pt)
      ", style=\"setlinewidth($[nLw])\"" sAttr +=;                              #     Create "style" attribute
    end                                                                         #   <<
    "  \"${itWm.td[i,itWm.IC_TD_INI]}\" -> \"${itWm.td[i,itWm.IC_TD_TER]}\""    #   |
      " [ " + sAttr + " ];\n" +                                         iDG >>; #   DOT output (transition)
    i ++=;                                                                      #   Next transition
  end                                                                           # <<

  ## Finish DOT document                                                        # -------------------------------------
  "}\n"                                                                 iDG >>; # DOT output

  ## Render through GraphViz                                                    # -------------------------------------
  "dot" sFormat == if                                                           # Dot format >>
    sFname iDG -write;                                                          #   Write DOT to output file
    "\n   - Generated $[sFname]\n  "                                     -MSG2; #   Protocol
  else                                                                          # << Other formats >>
    var sTmpFile; ( "$__SFILE__" -SH_tmpfile ) sTmpFile =;                      #   Get a temporary file name
    sTmpFile iDG -write;                                                        #   Write DOT to temporary file
    "$[sTool] -T$[sFormat] -o$[sFname] " sTmpFile + -system;                    #   Render
    sTmpFile -SH_rm;                                                            #   Remove temporary file
    "\n   - Generated $[sFname] using \"$[sTool]\"\n  "                  -MSG2; #   Protocol
  end                                                                           # <<
}

## -- World model functions --

## Returns the current state of a world automaton.
##
## @cgen:index
## @param itWm fst
##          The world model in unit 0. 
## @return The zero-based index of the current state.
## @see -WM_setstate
function -WM_getstate(itWm)
{
  itWm.ud.descr0 return;                                                        # State stored in ud.descr0
}

## Sets the current state of a world automaton.
##
## @cgen:index
## @param nS int
##          The zero-based index of the current state. There are no checks 
##          performed.
## @param itWm fst
##          The world model in unit 0. 
## @return void
## @see -WM_getstate
## @see -WM_enter
function -WM_setstate(nS,itWm)
{
  nS itWm.ud -set descr0;                                                       # State stored in ud.descr0
}

## (Re-)enters the world at a random state.
##
## @cgen:index
## @param itWm fst
##          The world model in unit 0. 
## @return A data instance with exactly one record of the following structure:
##    <table>
##      <tr><th>Component</th><th>Type</th><th>Description</th></tr>
##      <tr><td>0</td><td><code>int</code></td><td>0 (world state before entering)</td></tr>
##      <tr><td>1</td><td><code>int</code></td><td>State after entering world</td></tr>
##      <tr><td>2</td><td><code>int</code></td><td>-1 (epsilon action)</td></tr>
##      <tr><td>3</td><td><code>double</code></td><td>The direct reward of entry</td></tr>
##    </table>
## @see -WM_act
## @see -WM_getstate
## @see -WM_setstate
function -WM_enter(itWm)
{
  data idTdE;                                                                   # List of entry transitions
  data idRes;                                                                   # Result
  var  nRT;                                                                     # Random transition index
  var  nT;                                                                      # Transition index
  var  nDRw;                                                                    # Direct reward of entry
  var  nTer;                                                                    # Selected world entry state

  :itWm.td[itWm.IC_TD_INI].==0: itWm.td -dmark;                                 # Mark entry transition
  itWm.td 0 0 idTdE /mark -select;                                              # Copy entry transitions
  itWm.td -unmark;                                                              # Clear marks

  idTdE -is_empty not if                                                        # Entry transitions found >>
    0 :idTdE.nrec-1: 1 nRT -intv; nRT nT =;                                     #   Select random transition
    :idTdE[nT,itWm.IC_TD_TER]: nTer =;                                          #   Get terminal state (entry state)
    :idTdE[nT,.__wm_sNcTdQR]:  nDRw =;                                          #   Get direct reward
    nTer itWm.ud -set descr0;                                                   #   Set new world state
    { 0 $[nTer] -1 $[nDRw] } idRes =;                                           #   Prepare result
  else                                                                          # << No entry transitions found >>
    "World has no entry transitions"                                1 -WARNING; #   Warning
    0 itWm.ud -set descr0;                                                      #   Set new world state
    { 0 0 -1 0 } idRes =;                                                       #   Prepare dummy result
  end                                                                           # <<

  { "nIni" "nTer" "nAct" "nR" } ' 0 idRes -set_cnames;                          # Name result components
  idRes return;                                                                 # Return result
}

## Performs one action in a finite state world.
## 
## @cgen:index
## @param act variant
##          The zero-based action index or the action name.
## @param itWm fst
##          The world model in unit 0. 
## @return A data instance with exactly one record of the following structure:
##    <table>
##      <tr><th>Component</th><th>Type</th><th>Description</th></tr>
##      <tr><td>0</td><td><code>int</code></td><td>State before performing <code>act</code></td></tr>
##      <tr><td>1</td><td><code>int</code></td><td>State after performing <code>act</code></td></tr>
##      <tr><td>2</td><td><code>int</code></td><td><code>act</code> (as index)</td></tr>
##      <tr><td>3</td><td><code>double</code></td><td>The direct reward of <code>act</code></td></tr>
##    </table>
## @see -WM_enter
## @see -WM_qlearn
function -WM_act(act,itWm)
{
  data idRes;                                                                   # Result
  var  nDRw; 0 nDRw =;                                                          # Direct reward of action
  var  nIni; itWm.ud.descr0 nIni =;                                             # Current world state
  var  nTer; nIni nTer =;                                                       # World state after action (default)
  var  nAct; ( act itWm  -WM_getactionid ) nAct =;                              # Get the action index
  var  nT; ( nIni -1 nAct itWm -WM_findtrans ) nT =;                            # Get action transition
  :nT<0 || nAct<0: if                                                           # Action trans. or action not found >>
    ( nIni -1 -2 itWm -WM_findtrans ) nT =;                                     #   Get fall-back transition
  end                                                                           # <<
  :nT>=0: if                                                                    # Action transition found >>
    :itWm.td[nT,itWm.IC_TD_TER]: nTer =;                                        #   Get world state after action
    :itWm.td[nT,.__wm_sNcTdQR]:  nDRw =;                                        #   Get direct reward of action
  end                                                                           # <<
  nTer itWm.ud -set descr0;                                                     # Set new world state
  { $[nIni] $[nTer] $[nAct] $[nDRw] } idRes =;                                  # Prepare result
  { "nIni" "nTer" "nAct" "nR" } ' 0 idRes -set_cnames;                          # ...
  idRes return;                                                                 # Return result
}

## -- Cognitive agents' inner map of world functions --

## Explores the world by randomly performing actions. The function interacts 
## with the world model <code>itWm</code> only by invoking <a 
## href="#clp_-WM_enter">-WM_enter</a> and <a href="#clp_-WM_act">-WM_act</a>. 
## These functions may be overloaded to implement other worlds.
##
## @cgen:index
## @param itWm fst
##          The world model.
## @param nECnt integer
##          Number of episodes to perform.
## @param nELen integer
##          Episode lenght (number of actions performed) until randomly 
##          requesting a initial world state.
## @param itIm fst
##          Filled with the cognitive agent's inner map of the world. Must have 
##          been initialize through <a href="#clp_-WM_init">-WM_init</a> or be
##          the result of a previous exploration. Actions performed during the 
##          exploration are taken from the input symbol table 
##          <code>itIm.is</code>. 
## @return <code>itIm</code>
function -WM_explore(nECnt,nELen,itWm,itIm)
{
  data idObs;                                                                   # Observation of the world
  var  nI;                                                                      # Iteration counter in episode
  var  nE;                                                                      # Episode counter
  var  nS;                                                                      # Random start state of world
  var  nRAct; 0 :itIm.is.nrec-1: 1 nRAct -intv;                                 # Random action
  var  nAct;                                                                    # Current action (rec.index in itIm.is)

  "\n\n   Exploring world ($[nECnt] episodes of $[nELen] action"                # |
    ( nELen 1 != if "s" else "" end ) + ")" +                             -MSG; # Protocol
  "\n   - Agent's actions: { "                                            -MSG; # Protocol
  :nI=0; :nI<itIm.is.nrec: while                                                # Protocol
    :itIm.is[nI,0]: if "${itIm.is[nI,0]} " -MSG; end                            # Protocol
  nI ++=; end                                                         "}" -MSG; # Protocol

  0 1 -PBAR;                                                                    # Begin progress bar
  0 nE =; nE nECnt < while                                                      # Loop over scheduled episodes >>
    "\n   - Episode $[nE]/$[nECnt]"                                      -MSG2; #   Protocol
    ( itWm -WM_enter ) idObs =;                                                 #   (Re-)enter world at randow state
    0 :idObs[0,1]: -1 :idObs[0,3]>0: itIm -WM_addtrans;                         #   Add entry transition to inner map
    "\n     - Entry at state "                                           -MSG2; #   Protocol
    ( :idObs[0,3]>0: if "(${idObs[0,1]})" else "${idObs[0,1]}" end )     -MSG2; #   Protocol
    itIm.is.nrec 0 == if nE ++=; :(nE+1)/nECnt: 1 -PBAR; continue; end          #   No actions -> next episode 
    0 nI =; nI nELen < while                                                    #   Loop over actions of episode >>
      :(nE*nELen+nI+1)/(nECnt*nELen): 1 -PBAR;                                  #     Display progress
      "\n     - Action ${nI+1}/$[nELen]: "                               -MSG2; #     Protocol
        nRAct nAct =;                                                           #     Randomly choose action
        ( ( :itIm.is[nAct,0]: itIm -WM_getactionid ) itWm -WM_act ) idObs =;    #     Perform action in world
        :idObs[0,0]: :idObs[0,1]: nAct :idObs[0,3]>0: itIm -WM_addtrans;        #     Update agent's inner map of world
        "${idObs[0,0]} --\"${itIm.is[nAct,0]}\"--> "                     -MSG2; #     Protocol
        ( :idObs[0,3]>0: if "(${idObs[0,1]})" else "${idObs[0,1]}" end ) -MSG2; #     Protocol
      nI ++=;                                                                   #     Next action
    end                                                                         #   <<
    nE ++=                                                                      #   Next episode
  end                                                                           # <<
  "\n  " -MSG2; "done\n"                                                  -MSG; # Protocol
  itIm return;                                                                  # Return updated inner map
}

## Basic Q-learning of a cognitive agent's inner map of the world. The function 
## interacts with the world model <code>itWm</code> only by invoking <a 
## href="#clp_-WM_enter">-WM_enter</a> and <a href="#clp_-WM_act">-WM_act</a>. 
## These functions may be overloaded to implement other worlds.
##
## @cgen:index
## @param nDefQ double
##         Initial Q-value, 3 is a reasonable choice.
## @param nDctQ double
##         Q discount factor, 0.9 is a reasonable choice.
## @param nXIte integer
##         Number of iterations.
## @param itWm fst
##          The world model. 
## @param itIm fst
##          Filled with the cognitive agent's inner map of the world. Must have 
##          been initialize through <a href="#clp_-WM_init">-WM_init</a> or be
##          the result of a previous Q-learning. Actions performed during the 
##          Q-learning are taken from the input symbol table 
##          <code>itIm.is</code>. 
## @return void
function -WM_qlearn(nDefQ,nDctQ,nXIte,itWm,itIm)
{
  function -LPA(nIni,idAct,nDefQ,itIm)                                          # List possible actions at nIni
  {                                                                             # >>
    data idRes;                                                                 #   Result (transition list)
    data idRes2;                                                                #   List transitions from nIni in itIm
    data idAux;                                                                 #   Auxiliary data instance
    var  nIcTdTis; ( itIm.NC_TD_TIS itIm.td -find_comp ) nIcTdTis =;            #   Transducer input symbol comp. index

    idAct -is_empty if idRes return; end                                        #   There are no actions -> return
    itIm.td idRes =; 1 idRes -allocate;                                         #   Make one empty dummy transition
    :idRes[0,itIm.IC_TD_INI]=nIni;                                              #   Set initial state
    :idRes[0,itIm.IC_TD_TER]=-1;                                                #   Set terminal state
    :idRes[0,.__wm_sNcTdQR]=nDefQ;                                              #   Set initial Q-value
    ( 1  idAct.nrec zeros ) 0 idRes 0 idRes.dim idRes -lookup;                  #   Duplicate trans. idAct.nrec times
    itIm.NC_TD_TIS nIcTdTis idRes -rindex;                                      #   Fill in action indices
    :itIm.td[itIm.IC_TD_INI].==nIni: itIm.td /comp -dmark;                      #   Mark existing transitions from nIni
    itIm.td 0 0 idRes2 /mark -select; itIm.td -unmark;                          #   Copy marked transitions and unmark
    idRes2 -is_empty not if                                                     #   Found existing transitions >>
      idRes idRes2 nIcTdTis nIcTdTis idAux -gen_index;                          #     Find actions in default result
      :idAux.>=0: idRes /comp -dmark; idRes 0 0 idRes /mark -delete;            #     Delete them
      idRes2 idRes -cat;                                                        #     Append existing trans. to result
    end                                                                         #   <<
    -UASR_get_vlevel 3 >= if                                                    #   Verbose level 3 and higher >>
      "\n     Possible actions at state $[nIni]"                         -echo; #     Protocol
      var nR; nR idRes.nrec < while                                             #     Loop over action list >>
        "\n     - ${idRes[nR,itIm.NC_TD_TIS]}"                           -echo; #       Protocol
        " (\"${idAct[idRes[nR,itIm.NC_TD_TIS],0]}\"):"                   -echo; #       Protocol
        " -> ter=" :idRes[nR,itIm.IC_TD_TER]<0: if "?"                          #       Protocol
          else "${idRes[nR,itIm.IC_TD_TER]}" end +                       -echo; #       ...
        ", Q=${idRes[nR,.__wm_sNcTdQR]}"                                 -echo; #       Protocol
        nR ++=;                                                                 #       Next possible action
      end                                                                       #     <<
      "\n     "                                                          -echo; #   Protocol
    end                                                                         #   <<
    idRes return;                                                               #   Return a transition list
  }                                                                             # <<

  data idAct;                                                                   # Set of actions known to the agent
  data idLpa;                                                                   # Possible actions at current state
  data idObs;                                                                   # Observation of the world
  data idAux;                                                                   # Auxiliary data instance
  var  nRAct;                                                                   # Random action
  var  nAct;                                                                    # Current action
  var  nIni;                                                                    # World state (before action)
  var  nTer;                                                                    # World state (after action)
  var  nDrw;                                                                    # Direct reward from world
  var  nT;                                                                      # Transition index in inner world model
  var  nIte;                                                                    # Current Q-learning iteration
  var  nI;
  
  ## Initialization                                                             # -------------------------------------
  itIm.is idAct -copy;                                                          # Get agent's action set
  
#profile iP; profile iXP; iXP -begin_timer;
#iP -cont_timer; # == PROFILE SNIPPET =>
#iP -break_timer; # <= PROFILE SNIPPET ==
  ## Q-learning iteration                                                       # -------------------------------------
  "\n\n   Q-Learning ($[nXIte] iterations)"                               -MSG; # Protocol
  "\n   - Agent's actions: { "                                            -MSG; # Protocol
  :nI=0; :nI<itIm.is.nrec: while                                                # Protocol
    :itIm.is[nI,0]: if "${itIm.is[nI,0]} " -MSG; end                            # Protocol
  nI ++=; end                                                         "}" -MSG; # Protocol
  "\n   - Initial Q-value: $[nDefQ]"                                      -MSG; # Protocol
  "\n   - Q discount     : $[nDctQ]"                                      -MSG; # Protocol
  0 1 -PBAR;                                                                    # Begin progress bar
  0 nIte =; nIte nXIte < while                                                  # Q-learning iteration >>
    ( itWm -WM_enter ) idObs =; :idObs[0,1]: nIni =;                            #   ??% # (Re-)enter world
    0 nIni -1 :idObs[0,3]>0: itIm -WM_addtrans;                                 #   17% # Add entry transition
    "\n   - ${nIte+1}/$[nXIte]: ini=$[nIni]"                             -MSG2; #   Protocol
    :(nIte+1)/nXIte: 1 -PBAR;                                                   #   Display progress

    ## List and rank action options, then choose and perform action             #   35% # - - - - - - - - - - - - - - -
    ( nIni idAct nDefQ itIm -LPA ) idLpa =;                                     #   11% # Get action options from nIni
    idLpa -is_empty if nIte ++=; continue; end                                  #   Cannot do anything here...
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    :idLpa[.__wm_sNcTdQR].==idAux[0,0]: idLpa /comp -dmark;                     #   Mark maximal Q-values
    idLpa 0 0 idLpa /mark -select; idLpa -unmark;                               #   Delete non-maxima
    idLpa ( itIm.NC_TD_TIS idLpa -find_comp ) nRAct -rset; nRAct nAct =;        #   Randomly choose from remaining opts
    ", act=$[nAct] (\"${idAct[nAct,0]}\")"                               -MSG2; #   Protocol
    ( ( :idAct[nAct,0]: itIm -WM_getactionid ) itWm -WM_act ) idObs =;          #   17% # Perform action
#    ( nAct itWm -WM_act ) idObs =;                                              #   17% # Perform action
    :idObs[0,1]: nTer =;                                                        #   New world state
    :idObs[0,3]: nDrw =;                                                        #   Direct reward from world
    " -> ter=$[nTer], reward=$[nDrw]"                                    -MSG2; #   Protocol

    ## Update agent's inner map and compute new Q-values                        #   31% # - - - - - - - - - - - - - - -
    ( nTer idAct nDefQ itIm -LPA ) idLpa =;                                     #   12% # Get action options from nTer
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    ( nIni nTer nAct :nDrw>0: itIm -WM_addtrans ) nT =;                         #   17% # Log action in inner world model
    :itIm.td[nT,.__wm_sNcTdQR]=nDctQ*idAux[0,0]+nDrw;                           #   Set Q-value of action transition
    ", maxQ=${idAux[0,0]} -> Q=$[nDctQ]*${idAux[0,0]}+$[nDrw]"           -MSG2; #   Protocol
    "=${itIm.td[nT,.__wm_sNcTdQR]}"                                      -MSG2; #   Protocol

    nIte ++=;                                                                   #   Next iteration step
  end                                                                           # <<
  "\n  " -MSG2; "done\n"                                                  -MSG; # Protocol
#iXP -break_timer;
#"   Profile\n   - Snippet: $[iP.time] ms"                                -echo;
#", ${round(iP.time/iXP.time*1000)/10} %, $[iP.calls]x"                   -echo;
#"\n   - Total  : $[iXP.time] ms\n"                                       -echo;
}

## Determines if the cognitive agent masters its world. The world is mastered,
## iff there is at least one path from each state in the agents inner map of the
## world to a final state (goal). The function computes the state potentials and
## checks, whether all of them are finite (world automata initialized through 
## <a href="#clp_-WM_init">-WM_init</a> have logarithmic weights, hence states 
## with infinite potential are not conencted with the final state).
##
## @cgen:index
## @param itIm fst
##          The agent's inner map of the world.
## @return <code>TRUE</code> if the world is mastered, <code>FALSE</code> 
##         otherwise.
## @see -WM_pathtogoal
function -WM_ismastered(itIm)
{
  fst  itAux;                                                                   # Auxiliary finite state transducer
  data idAux;                                                                   # Auxiliary data table
  itIm itAux =;                                                                 # Copy world automaton
  0 itAux -potential;                                                           # Compute state potentials
  :itAux.sd["~POT"].>1e308: NULL 0 "sum" idAux /rec -aggregate;                 # Count infinite potentials ...
  :idAux[0,0]==0: return;                                                       # ... world mastered if none
}

## EOF