## UASR: Unified Approach to Speech Synthesis and Recognition
## - Utility functions: Finite state world modeling
##
## AUTHOR : Matthias Wolff, Werner Meyer
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2014-2015 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"$UASR_HOME/scripts/dlabpro/util/cfg.itp"  /noerror include;                    # UASR configutation utilities
"$UASR_HOME/scripts/dlabpro/util/fst.itp"  /noerror include;                    # FST utilities
"$UASR_HOME/scripts/dlabpro/util/os.itp"   /noerror include;                    # OS utilities
"$UASR_HOME/scripts/dlabpro/util/uasr.itp" /noerror include;                    # UASR utilities
"$UASR_HOME/scripts/dlabpro/util/var.itp"  /noerror include;                    # Variable utilities

var __wm_sNcTdQR; "~QR" __wm_sNcTdQR =;                                         # Q-value/reward component

## -- World model editing and rendering functions --

## Creates a new empty world automaton.
##
## @cgen:index
## @param itWm fst
##          Filled with the new world automaton. Any present data will be 
##          deleted.
## @return void
function -WM_init(itWm)
{
  itWm -reset;                                                                  # Reset target
  "world" itWm /fsa /lsr -addunit;                                              # Create weighted acceptor
  "NAME" 255 itWm.sd -addcomp;                                                  # State name
  itWm.NC_TD_RC ( -type int    ) itWm.td -addcomp;                              # Add trans. reference counter comp.
  .__wm_sNcTdQR ( -type double ) itWm.td -addcomp;                              # Add Q-value/reward component
}

## Returns the zero-based index of an action in the input symbol table if the
## world model. If <code>act</code> is numeric or can be converted to a number,
## the function returns the numeric value of <code>act</code>. Otherwise the
## function will look up the action named <code>act</code> in the input symbol
## table and return its zero-based index. If no action named <code>act</code> is
## found, the function will add the action.
##
## @cgen:index
## @param act number or string
##          The zero-based action index or the action name.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the action in the input symbol table. 
function -WM_getactionid(act,itWm)
{
  var nAct;
  act nAct /noerror -vset ?error not if nAct return; end 

  data idAct; { "" } idAct =; :idAct[0,0]=act;
  data idAux;
  
  idAct itWm.is 0 0 idAux /noerror -gen_index ?error not if
    :idAux[0,0]>=0: if :idAux[0,0]: return; end
  end
  
  idAct itWm.is -cat;
  itWm.is.nrec -- return;
}

## Ensures the presence of the specified state ID in a world automaton.
##
## @cgen:index
## @param nS integer
##          The zero-based index of the state to ensure. If the world model in
##          <code>itWm</code> contains fewer than <code>nS</code>+1 states, the
##          function will add new states.
## @param itWm fst
##          The world model in unit 0. If empty, the function will create a new 
##          world model.
## @return void
function -WM_ensurestate(nS,itWm)
{
  itWm.ud -is_empty if itWm -WM_init; end                                       # Init world automaton if empty
  var nXS; :nXS = itWm.ud[0,itWm.IC_UD_XS];                                     # Number of states in current world
  var nIcSn; ( "NAME" itWm.sd -find_comp ) nIcSn =;                             # Component index of state name
  :nS>=nXS: if                                                                  # Need new states? Yes >>
    0 :nS-nXS+1: itWm -addstates;                                               #   Create new states
    nIcSn -1 > if                                                               #   Have state names? Yes >>
      nXS nS =; :nS<itWm.ud[0,itWm.IC_UD_XS]: while                             #     Iterate new states >>
        "$[nS]" nS nIcSn itWm.sd -store;                                        #       Set state name
        nS ++=;                                                                 #       Next state
      end                                                                       #     <<
    end                                                                         #   <<
  end                                                                           # <<
}

## Determines if a goal can be reached from a specified state. The function
## computes the state potentials. A state is forward-connected iff its state
## potential is not infinity (world automata initialized through {@link -WM_init}
## have logarithmic weights).
##
## @cgen:index
## @param nS integer
##          The zero-based index of the state to check.
## @param itWm fst
##          The world automaton.
## @return <code>TRUE</code> if a goal can be reached from the state, 
##         <code>FALSE</code> otherwise.
function -WM_pathtogoal(nS,itWm)
{
  fst itAux; itWm itAux =;                                                      # Copy world automaton
  0 itAux -potential;                                                           # Compute state potentials
  :itAux.sd[nS,"~POT"]<1e308: return;                                           # Return (potential of nS) < infinity
}

## Finds a transition in a world automaton.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition, -1: any terminal state.
## @param nAct integer
##          The action of the transition.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the first matching transision, or -1 if 
##         no matching transition was not found. 
function -WM_findtrans(nIni,nTer,nAct,itWm)
{
  data idTd;   itWm.td 0 :itWm.ud[0,itWm.IC_UD_XT]: idTd /rec -select;          # Get transition table of unit 0
  data idMark;                                                                  # Transition marking list
  idTd -is_empty if -1 return; end                                              # No transitions -> return not found

  "IDX" ( type int ) idTd -addcomp;                                             # Add index component
  :idTd.dim-1: 1 idTd /comp -mark; 0 1 idTd /mark -fill;                        # Fill index component
  :(idTd[itWm.IC_TD_INI].==nIni).&&(idTd[itWm.NC_TD_TIS].==nAct): idMark =;     # Match initial state and action
  nTer 0 >= if :idMark.&&(idTd[itWm.IC_TD_TER].==nTer): idMark =; end           # If term. state specified, match it
  idMark idTd /comp -dmark;                                                     # Mark matching transition(s)
  idTd 0 0 idTd /mark -select;                                                  # Discard unmarked transitions
  :idTd.nrec==0: if -1 return; end                                              # No matching trans. -> ret. not found
  :idTd[0,idTd.dim-1]: return;                                                  # Return index of first match
}

## Adds a transition to a world automaton. If the transition already exists and
## the transition table of <code>itWm</code> contains a reference counter 
## component, the function will increment the reference counter.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition.
## @param act number or string
##          The zero-based action index or the action name.
## @param bFinal boolean
##          Indicates whether the terminal state is final.
## @param itWm fst
##          The world automaton. If empty, the function will create a new world
##          model in unit 0.
## @return The zero-based transition index of the added/updated transition.
function -WM_addtrans(nIni,nTer,act,bFinal,itWm)
{
  var nAct; ( act itWm  -WM_getactionid ) nAct =;                               # Get the action index
  :max(nIni,nTer): itWm -WM_ensurestate;                                        # Ensure states for new transition
  var nT; ( nIni nTer nAct itWm -WM_findtrans ) nT =;                           # Find specified transition
  nT 0 < if                                                                     # Does not yet exist >>
    var sOpts; bFinal if "/final" else "" end sOpts =;                          #   Options to -addtrans
    0 nIni nTer itWm $[sOpts] -addtrans;                                        #   Add transition
    :itWm.ud[0,itWm.IC_UD_XT]-1: nT =;                                          #   Index of newly added transition
    :itWm.td[nT,itWm.NC_TD_TIS]=nAct;                                           #   Set action ID (trans. input symbol)
  end                                                                           # <<
  :itWm.td[nT,itWm.NC_TD_RC]++;                                                 # Increment trans. reference counter
  nT return;                                                                    # Return transition index
}

## Renders a world automaton using the GraphViz toolkit. The function expects
## the GraphViz executables to be found in the path environment variable.
##
## @cgen:index
## @param sFname string
##          The name of the output file.
## @param sTool string
##          The GraphViz rendering tool, can be <code>NULL</code> which is 
##          equivalent to "fdp -Gmaxiter=10000".
## @param sFormat string
##          The output format; "svg", "eps", "png", or any of the file formats
##          supported by GraphViz.
## @param sMode string
##          Empty string (default operation) or any combination of the following 
##          characters:
##          <table cellpadding="3" style="margin-top:6pt; margin-bottom:6pt;">
##            <tr><th>Character</th><th>Description</th></tr>
##            <tr><td>E</td><td>Skip entry transitions (for legibility)</td></tr>
##            <tr><td>L</td><td>Display Q-values/rewards as line widths<sup>1)</sup></td></tr>
##            <tr><td>P</td><td>Use fix state positions<sup>2)</sup></td></tr>
##            <tr><td>Q</td><td>Display Q-values/rewards in transition labels</td></tr>
##          </table>
##          <sup>1)</sup> Effective only if format is "eps"<br>
##          <sup>2)</sup> Requires that the state table <code>itWm.sd</code> of
##          the world automaton contains two numeric components named "POSX" and
##          "POSY" specifying the state positions.
## @param itWm fst
##          The world model to be rendered.
## @return void
function -WM_render(sFname,sTool,sFormat,sMode,itWm)
{
  ## Initial checks                                                             # -------------------------------------
  itWm.ud.nrec 1 != if                                                          # Not exactly one unit in world >>
    "itWm must contain exactly one unit." -ERROR; -list trace;                  #   Error and stack trace
    leave;                                                                      #   No service!
  end                                                                           # <<
  sTool not if "fdp -Gmaxiter=10000" sTool =; end                               # Set default renderer

  ## Local functions and objects                                                # -------------------------------------
  function -get_tis(nT,itWm)                                                    # Get input symbol of transition
  {                                                                             # <<
    var nTis; :itWm.td[nT,itWm.NC_TD_TIS]: nTis =;                              #   Input symbol index
    nTis  0 >= if :itWm.is[nTis,0]: return; end                                 #   Look-up in symbol table
    nTis -1 == if "eps" return; end                                             #   Epsilon symbol
    nTis -2 == if "dlt" return; end                                             #   Delta symbol
    "?" return;                                                                 #   Dunno...
  }                                                                             # <<

  DGen iDG;                                                                     # The DOT document
  data idAux;
  var  nIcsdX; ( "POSX" itWm.sd -find_comp ) nIcsdX =;                          # X-coordinate comp. in state table
  var  nIcsdY; ( "POSY" itWm.sd -find_comp ) nIcsdY =;                          # Y-coordinate comp. in state table
  var  bPin;   ( ( sMode "P" "search" -VAR_strop ) 0 >= ) bPin   =;             # Fix state positions
  var  bNoEnt; ( ( sMode "E" "search" -VAR_strop ) 0 >= ) bNoEnt =;             # Do not render entry transitions
  var  bLw;    ( ( sMode "L" "search" -VAR_strop ) 0 >= ) bLw    =;             # Q-values/rewards as line widths
  var  bQr;    ( ( sMode "Q" "search" -VAR_strop ) 0 >= ) bQr   =;              # Display Q-values/rewards
  var  sAttr;                                                                   # State attributes
  var  nQr;                                                                     # Q-value or reward of transition
  var  nQrMax;                                                                  # Max. Q-value or reward
  var  nQrMin;                                                                  # Min. Q-value or reward
  var  nLw;                                                                     # Line width in inch
  var  i;                                                                       # Loop counter

  ## Some more checks                                                           # -------------------------------------
  :bPin && (nIcsdX<0 || nIcsdY<0): if                                           # "P"-mode but no state pos. found >>
    "State table does not contain state positions. Ignoring mode 'P'."          #   |
    1 -WARNING;                                                                 #   Warning
    FALSE bPin =;                                                               #   Do not fix states
  end                                                                           ## <<

  ## Begin DOT document                                                         # -------------------------------------
  "digraph ${itWm.ud[0,0]} {\n"                                         iDG >>; # DOT output
  bPin not if                                                                   # Fix state positions >>
    "  sep=\"+30\"; overlap=\"vpsc\";\n"                                iDG >>; #   DOT output
  end                                                                           # <<
  "  node [fontname=Helvetica, shape=circle, fixedsize=true];\n"        iDG >>; # DOT output
  "  edge [fontname=Helvetica];\n"                                      iDG >>; # DOT output

  ## States                                                                     # -------------------------------------
  0 i =; i itWm.sd.nrec < while                                                 # Loop over states >>
    :bNoEnt && (i==0): if i ++=; continue; end                                  #   Skip start state
    "" sAttr =;                                                                 #   Clear state attributes
    bPin if                                                                     #   Fix state positions >>
      :sAttr="pos=\"${itWm.sd[i,nIcsdX]},${itWm.sd[i,nIcsdY]}!\"";              #     Create "pos" attribute
    end                                                                         #   <<
    :itWm.sd[i,0]%2==1: if # HACK: should be (itWm.sd[i,0]&0x0001)>0!           #   State is final >>
      :sAttr!="": if :sAttr+=", "; end :sAttr+="peripheries=2";                 #     Create "peripheries" attribute
    end                                                                         #   <<
    ( i itWm -WM_pathtogoal ) not if                                            #   Goal cannot be reached >>
      :sAttr!="": if :sAttr+=", "; end :sAttr+="style=filled";                  #     Create "filled" attribute
    end                                                                         #   <<
    "  \"$[i]\" [ " sAttr + " ];\n" +                                   iDG >>; #   DOT output
    i ++=;                                                                      #   Next state
  end                                                                           # <<
  
  ## Transitions                                                                # -------------------------------------
  bLw if                                                                        # Rendering line widths >>
    1e308 nQrMin =;-1e308 nQrMax =; 0 i =; i itWm.td.nrec < while               #   Loop over transitions >>
      :bNoEnt && (itWm.td[i,itWm.IC_TD_INI]==0): if i ++=; continue; end        #     Skip entry transitions
      :nQrMax=max(nQrMax,itWm.td[i,"~QR"]);                                     #     Aggregate maximum Q-value/reward
      :nQrMin=min(nQrMin,itWm.td[i,"~QR"]);                                     #     Aggregate minimum Q-value/reward
      i ++=;                                                                    #     Next transition
    end                                                                         #   <<
    :nQrMin==nQrMax: if FALSE bLw =; end                                        #   Min==max --> no line weights
  end                                                                           # <<
  0 i =; i itWm.td.nrec < while                                                 # Loop over transitions >>
    :bNoEnt && (itWm.td[i,itWm.IC_TD_INI]==0): if i ++=; continue; end          #   Skip entry transitions
    :nQr=ent(itWm.td[i,"~QR"]*1000)/1000;                                       #   Get Q-value/reward
    "label=\"" ( i itWm -get_tis ) +                                            #   |
      ( bQr if ":$[nQr]" else "" end ) + "\"" +  sAttr =;                       #   Create "label" attribute
    bLw if                                                                      #   Rendering line widths >>
      :nLw = max(0.1,min(5,ent((nQr-nQrMin)/(nQrMax-nQrMin)*50)/10));           #     Compute line width (0.1...5.0 pt)
      ", style=\"setlinewidth($[nLw])\"" sAttr +=;                              #     Create "style" attribute
    end                                                                         #   <<
    "  \"${itWm.td[i,itWm.IC_TD_INI]}\" -> \"${itWm.td[i,itWm.IC_TD_TER]}\""    #   |
      " [ " + sAttr + " ];\n" +                                         iDG >>; #   DOT output (transition)
    i ++=;                                                                      #   Next transition
  end                                                                           # <<

  ## Finish DOT document                                                        # -------------------------------------
  "}\n"                                                                 iDG >>; # DOT output

  ## Render through GraphViz                                                    # -------------------------------------
  "dot" sFormat == if                                                           # Dot format >>
    sFname iDG -write;                                                          #   Write DOT to output file
    "\n   - Generated $[sFname]\n  "                                      -MSG; #   Protocol
  else                                                                          # << Other formats >>
    var sTmpFile; ( "$__SFILE__" -SH_tmpfile ) sTmpFile =;                      #   Get a temporary file name
    sTmpFile iDG -write;                                                        #   Write DOT to temporary file
    "$[sTool] -T$[sFormat] -o$[sFname] " sTmpFile + -system;                    #   Render
    sTmpFile -SH_rm;                                                            #   Remove temporary file
    "\n   - Generated $[sFname] using \"$[sTool]\"\n  "                   -MSG; #   Protocol
  end                                                                           # <<
}

## -- World model execution functions --

## Returns the current state of a world automaton.
##
## @cgen:index
## @param itWm fst
##          The world model in unit 0. 
## @return The zero-based index of the current state.
## @see -WM_setstate
function -WM_getstate(itWm)
{
  itWm.ud.descr0 return;                                                        # State stored in ud.descr0
}

## Sets the current state of a world automaton.
##
## @cgen:index
## @param nS int
##          The zero-based index of the current state. There are no checks 
##          performed.
## @param itWm fst
##          The world model in unit 0. 
## @return void
## @see -WM_getstate
## @see -WM_setrandomstate
function -WM_setstate(nS,itWm)
{
  nS itWm.ud -set descr0;                                                       # State stored in ud.descr0
}

## Randomly sets a new current state of a world automaton.
##
## @cgen:index
## @param itWm fst
##          The world model in unit 0. 
## @return The zero-based index of the newly selected state.
## @see -WM_getstate
## @see -WM_setstate
function -WM_setrandomstate(itWm)
{
  fst  itAux;                                                                   # Auxiliary transducer
  data idAux;                                                                   # Auxiliary data instance
  var  nRS;                                                                     # Random state
  itWm 0 { 0 } 0 NULL 1 itAux /forward -excerpt;                                # Go one transition from beginning
  itAux.td itAux.IC_TD_TER itAux.sd 1 1 idAux -lookup;                          # Get world state IDs
  idAux 0 nRS -rset;                                                            # Select random world state (name)
  $[nRS] itWm.ud -set descr0;                                                   # Convert to int and set current state
  itWm.ud.descr0 return;                                                        # Return current state
}

## Performs one action in a finite state world.
## 
## @cgen:index
## @param act number or string
##          The zero-based action index or the action name.
## @param itWm fst
##          The world model in unit 0. 
## @return A data instance with exactly one record of the following structure:
##    <table>
##      <tr><th>Component</th><th>Type</th><th>Description</th></tr>
##      <tr><td>0</td><td><code>int</code></td><td>State before performing <code>act</code></td></tr>
##      <tr><td>1</td><td><code>int</code></td><td>State after performing <code>act</code></td></tr>
##      <tr><td>2</td><td><code>int</code></td><td><code>act</code> (as index)</td></tr>
##      <tr><td>3</td><td><code>double</code></td><td>The direct reward of <code>act</code></td></tr>
##    </table>
## @see -WM_qlearn
function -WM_act(act,itWm)
{
  data idRes;                                                                   # Result
  var  nDRw; 0 nDRw =;                                                          # Direct reward of action
  var  nIni; itWm.ud.descr0 nIni =;                                             # Current world state
  var  nTer; nIni nTer =;                                                       # World state after action (default)
  var  nAct; ( act itWm  -WM_getactionid ) nAct =;                              # Get the action index
  var  nT; ( nIni -1 nAct itWm -WM_findtrans ) nT =;                            # Get action transition
  :nT<0 || nAct<0: if                                                           # Action trans. or action not found >>
    ( nIni -1 -2 itWm -WM_findtrans ) nT =;                                     #   Get fall-back transition
  end                                                                           # <<
  :nT>=0: if                                                                    # Action transition found >>
    :itWm.td[nT,itWm.IC_TD_TER]: nTer =;                                        #   Get world state after action
    :itWm.td[nT,.__wm_sNcTdQR]:  nDRw =;                                        #   Get direct reward of action
  end                                                                           # <<
  nTer itWm.ud -set descr0;                                                     # Set new world state
  { $[nIni] $[nTer] $[nAct] $[nDRw] } idRes =;                                  # Prepare result
  { "nIni" "nTer" "nAct" "nR" } ' 0 idRes -set_cnames;                          # ...
  idRes return;                                                                 # Return result
}

## -- Learning functions --

## Simple Q-learning. The function interacts with the world model
## <code>itWm</code> only by invoking <a href="#clp_-WM_setrandomstate"
## >-WM_setrandomstate</a> and <a href="#clp_-WM_act">-WM_act</a>. These 
## functions may be overloaded to implement other worlds.
##
## @cgen:index
## @param idAct data
##         A list of actions which can be performed in the world.
## @param nDefQ double
##         Initial Q-value, 3 is a reasonable choice.
## @param nDctQ double
##         Q discount factor, 0.9 is a reasonable choice.
## @param nXIte int
##         Number of iterations.
## @param itWm fst
##          The world model in unit 0. 
## @param itIwm fst
##           Filled with the inner world model of the cognitive agent after 
##           Q-learning.
## @return void
function -WM_qlearn(idAct,nDefQ,nDctQ,nXIte,itWm,itIwm)
{
  function -LPA(nIni,idAct,nDefQ,itIwm)                                         # List possible actions at nIni
  {                                                                             # >>
    data idRes;                                                                 #   Result (transition list)
    data idRes2;                                                                #   List transitions from nIni in itIwm
    data idAux;                                                                 #   Auxiliary data instance
    var  nIcTdTis; ( itIwm.NC_TD_TIS itIwm.td -find_comp ) nIcTdTis =;          #   Transducer input symbol comp. index

    itIwm.td idRes =; 1 idRes -allocate;                                        #   Make one empty dummy transition
    :idRes[0,itIwm.IC_TD_INI]=nIni;                                             #   Set initial state
    :idRes[0,itIwm.IC_TD_TER]=-1;                                               #   Set terminal state
    :idRes[0,.__wm_sNcTdQR]=nDefQ;                                              #   Set initial Q-value
    ( 1  idAct.nrec zeros ) 0 idRes 0 idRes.dim idRes -lookup;                  #   Duplicate trans. idAct.nrec times
    itIwm.NC_TD_TIS nIcTdTis idRes -rindex;                                     #   Fill in action indices
    :itIwm.td[itIwm.IC_TD_INI].==nIni: itIwm.td /comp -dmark;                   #   Mark existing transitions from nIni
    itIwm.td 0 0 idRes2 /mark -select; itIwm.td -unmark;                        #   Copy marked transitions and unmark
    idRes2 -is_empty not if                                                     #   Found existing transitions >>
      idRes idRes2 nIcTdTis nIcTdTis idAux -gen_index;                          #     Find actions in default result
      :idAux.>=0: idRes /comp -dmark; idRes 0 0 idRes /mark -delete;            #     Delete them
      idRes2 idRes -cat;                                                        #     Append existing trans. to result
    end                                                                         #   <<
    -UASR_get_vlevel 3 >= if                                                    #   Verbose level 3 and higher >>
      "\n     Possible actions at state $[nIni]"                         -echo; #     Protocol
      var nR; nR idRes.nrec < while                                             #     Loop over action list >>
        "\n     - ${idRes[nR,itIwm.NC_TD_TIS]}"                          -echo; #       Protocol
        " (\"${idAct[idRes[nR,itIwm.NC_TD_TIS],0]}\"):"                  -echo; #       Protocol
        " -> ter=" :idRes[nR,itIwm.IC_TD_TER]<0: if "?"                         #       Protocol
          else "${idRes[nR,itIwm.IC_TD_TER]}" end +                      -echo; #       ...
        ", Q=${idRes[nR,.__wm_sNcTdQR]}"                                 -echo; #       Protocol
        nR ++=;                                                                 #       Next possible action
      end                                                                       #     <<
      "\n     "                                                          -echo; #   Protocol
    end                                                                         #   <<
    idRes return;                                                               #   Return a transition list
  }                                                                             # <<

  data idLpa;                                                                   # List of possible actions
  data idObs;                                                                   # Observation of the world
  data idAux;                                                                   # Auxiliary data instance
  var  nRAct;                                                                   # Random action
  var  nAct;                                                                    # Current action
  var  nIni;                                                                    # World state (before action)
  var  nTer;                                                                    # World state (after action)
  var  nDrw;                                                                    # Direct reward from world
  var  nT;                                                                      # Transition index in inner world model
  var  nIte;                                                                    # Current Q-learning iteration
  
  ## Initialization                                                             # -------------------------------------  
  itIwm -WM_init;                                                               # Reset agent's inner world model
  idAct itIwm.is -copy;                                                         # Copy action set (input symbols)
  
profile iP; profile iXP; iXP -begin_timer;
iP -cont_timer; # == PROFILE SNIPPET =>
iP -break_timer; # <= PROFILE SNIPPET ==
  ## Q-learning iteration                                                       # -------------------------------------
  "\n\n   Q-Learning ($[nXIte] iterations)"                               -MSG; # Protocol
    "\n   - Initial Q-value: $[nDefQ]"                                    -MSG; # Protocol
    "\n   - Q discount     : $[nDctQ]"                                    -MSG; # Protocol
  0 1 -PBAR;                                                                    # Begin progress bar
  0 nIte =; nIte nXIte < while                                                  # Q-learning iteration >>
    ( itWm -WM_setrandomstate ) nIni =;                                         #   15% # Randomly set a new world state
    0 nIni -1 FALSE itIwm -WM_addtrans;                                         #   17% # This is a possible start state
    "\n   - ${nIte+1}/$[nXIte]: ini=$[nIni]"                             -MSG2; #   Protocol
    :(nIte+1)/nXIte: 1 -PBAR;                                                   #   Display progress

    ## List and rank action options, then choose and perform action             #   35% # - - - - - - - - - - - - - - - - - -
    ( nIni idAct nDefQ itIwm -LPA ) idLpa =;                                    #   11% # Get action options from nIni
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    :idLpa[.__wm_sNcTdQR].==idAux[0,0]: idLpa /comp -dmark;                     #   Mark maximal Q-values
    idLpa 0 0 idLpa /mark -select; idLpa -unmark;                               #   Delete non-maxima
    idLpa ( itIwm.NC_TD_TIS idLpa -find_comp ) nRAct -rset; nRAct nAct =;       #   Randomly choose from remaining opts
    ", act=$[nAct] (\"${idAct[nAct,0]}\")"                               -MSG2; #   Protocol
    ( :idAct[nAct,0]: itWm -WM_act ) idObs =;                                   #   17% # Perform action
    :idObs[0,1]: nTer =;                                                        #   New world state
    :idObs[0,3]: nDrw =;                                                        #   Direct reward from world
    " -> ter=$[nTer], reward=$[nDrw]"                                    -MSG2; #   Protocol

    ## Extend inner world model and compute new Q-values                        #   31% # - - - - - - - - - - - - - - - - - -
    ( nTer idAct nDefQ itIwm -LPA ) idLpa =;                                    #   12% # Get action options from nTer
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    ( nIni nTer nAct :nDrw>0: itIwm -WM_addtrans ) nT =;                        #   17% # Log action in inner world model
    :itIwm.td[nT,.__wm_sNcTdQR]=nDctQ*idAux[0,0]+nDrw;                          #   Set Q-value of action transition
    ", maxQ=${idAux[0,0]} -> Q=$[nDctQ]*${idAux[0,0]}+$[nDrw]"           -MSG2; #   Protocol
    "=${itIwm.td[nT,.__wm_sNcTdQR]}"                                     -MSG2; #   Protocol

    nIte ++=;                                                                   #   Next iteration step
  end                                                                           # <<
  "\n  " -MSG2; "done\n\n"                                                -MSG; # Protocol
iXP -break_timer;
"   Profile\n   - Snippet: $[iP.time] ms"                                -echo;
", ${round(iP.time/iXP.time*1000)/10} %, $[iP.calls]x"                   -echo;
"\n   - Total  : $[iXP.time] ms\n"                                       -echo;
}

## EOF