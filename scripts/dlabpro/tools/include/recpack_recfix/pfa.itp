## UASR: Unified Approach to Speech Synthesis and Recognition
## - Data packaging functions for fixpoint recognizer (recfix)
##
## AUTHOR : Frank Duckhorn
## PACKAGE: uasr/scripts/dlabpro/tools/include/recpack_recfix

## Copyright 2013 UASR contributors (see COPYRIGHT file)
## - Chair of System Theory and Speech Technology, TU Dresden
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

#@uasrdoc: ignore

function -PACK_fil(nFILFAC)
{
	data dMELN;
	data dMELM;

	# TODO: extract data from .__FEA_iPfa => m_lpCnvc (.norm, .a)
	{ 6 6 6 6 6 6 6 6 6 7 8 8 8 8 8 8 8 8 8 8 10 14 18 22 26 30 34 38 42 44 } dMELN =;

	data dL; { 6 6  6  6  6  6  6  6  6  6  8  8  8  8  8  8  8  8  8  8  8 12 16  20  24  28  32  36  40  44 44 } dL =;
	data dO; { 6 9 12 15 18 21 24 27 30 33 37 41 45 49 53 57 61 65 69 73 77 83 91 101 113 127 143 161 181 203 } dO =;
	-type double 257 30 dMELM -array;
	var k;
	0 var i; i dO.dim < while;
		0 k =; k :dL[0,i]: < while;
			:dMELM[i,dO[0,i]-dL[0,i  ]+1+k]=(k+1)/dL[0,i]/dMELN[0,i];
		k ++=; end;
		0 k =; k :dL[0,i+1]: < while;
			:dMELM[i,dO[0,i]+dL[0,i+1]-1-k]=(k+1)/dL[0,i+1]/dMELN[0,i];
		k ++=; end;
	i ++=; end;

	dMELM nFILFAC .* dMELM =;

  # get used positions
  data dMELU; -type int 2 dMELM.nrec dMELU -array;
  data dT;
  0 i =; i dMELM.nrec < while;
    i 1 dMELM /rec -xfetch 0 .!= ' 0 dT -compress;
    :dT[0,0]==0: if :dT[0,2]: else 0 end i 0 dMELU -store;
    :dT[dT.nrec-1,0]==0: if :dT[dT.nrec-1,1]: else dMELM.dim end :dMELU[i,0]: - i 1 dMELU -store;
  i ++=; end;

	dMELM ' 0 :.nMAX_PFA_DIM*.nMAX_FIL_DIM: "pfa.fil" "s16" -PACK;
	dMELU ' 1 :2*.nMAX_FIL_DIM: "pfa.filuse" "u16" -PACK;
}

function -PACK_log(nrm)
{
	65536 var ni;
	32767 var no;
	:2^(-16+1): var quant_energy;
	data dLOG;
	-type double 1 ni dLOG -array;
	0 :nrm/quant_energy/ni: dLOG -fill;
	:dLOG[0,0]=dLOG[1,0]/2;
	dLOG .ln dLOG =;
	"\n  log min: ${dLOG[0,0]}" -MSG2;
	dLOG :no/dLOG[dLOG.nrec-1,0]: dLOG.nrec "pfa.log" "s16" -PACK;
	:dLOG[dLOG.nrec-1,0]: return;
}

function -PACK_wvl(len)
{
	data dWVL;
  .__FEA_iPfa "FWTproc" ?instance if;
    dWVL .__FEA_iPfa -get_coef;
  else;
    1 1 zeros dWVL =;
  end;
	dWVL.nrec          1 "pfa.wvlnum" "s8"  -PACK1;
	dWVL 0 .nMAX_WVL_NUM "pfa.wvl"    "s16" -PACK;
}

function -PACK_pfa(nrm,idWnd)
{
  0 var nFRMSHF;
  0 var nFFTSHF;
	"uasr.pfa.len"   512   -CFG_get var flen;
  "recfix.nrm.frm" 0 "S" -CFG_get_ex var nFRMNRM;                                      #   Shift offset in frameing   
  "recfix.nrm.fft" 0 "S" -CFG_get_ex var nFFTNRM;                                      #   Shift offset after FFT
  "recfix.nrm.fil" 0 "S" -CFG_get_ex var nFILNRM;                                      #   Shift offset after filter
  "recfix.shf.fil" 3 "S" -CFG_get_ex var nFILSHF;                                      #   Shift offset after filter

	"\n  nrm.sig: $[nrm]" -MSG2;
  nFRMNRM 0 != if;
    0 0 idWnd vmax -fetch var wmax;
    :nrm/nFRMNRM: var nchg;
    :nchg*wmax>1.00001: while; :nchg=nchg/2; nFRMSHF ++=; end;
    :idWnd=idWnd*nchg;
	  :nrm=nrm/nchg/2^nFRMSHF; # norm after FRM
  end;
	"\n  nrm.frm: $[nrm] (wmax: $[0 0 idWnd vmax -fetch] shf: $[nFRMSHF])" -MSG2;
  nFFTNRM 0 != if;
    :nFFTNRM>nrm*flen/2: while; :nFFTNRM=nFFTNRM/2; nFFTSHF --=; end;
    :nFFTNRM<nrm*flen/2: while; :nFFTNRM=nFFTNRM*2; nFFTSHF ++=; end;
  end;
	:nrm=nrm*flen/2/2^nFFTSHF; # norm after FFT
	"\n  nrm.fft: $[nrm] (shf: $[nFFTSHF])" -MSG2;
  :2^-nFILSHF: var nFILFAC;
  nFILNRM 0 != if;
    :nFILFAC=nFILFAC*nrm/nFILNRM;
    :nFILFAC>1.00001: while; :nFILFAC=nFILFAC/2; nFILSHF ++=; end;
	  :nrm=nrm/nFILFAC/2^nFILSHF; # norm after FIL
  end;
	"\n  nrm.fil: $[nrm] (fac: $[nFILFAC] shf: $[nFILSHF])" -MSG2;

	"uasr.sig.srate" 16000 -CFG_get 1 "pfa.srate"  "u32" -PACK1;
	"uasr.pfa.crate" 160   -CFG_get 1 "pfa.crate"  "u16" -PACK1;
	"uasr.pfa.wlen"  400   -CFG_get 1 "pfa.wlen"   "u16" -PACK1;
	flen                            1 "pfa.len"    "u16" -PACK1;
	.nPFA_TYP_FFT .nPFA_TYP_LOG .nPFA_TYP_FIL + + 1 "pfa.typ"   "u8" -PACK1; # TODO: from uasr.pfa
	nFRMSHF                         1 "pfa.frmshf" "s8"  -PACK1;
	nFFTSHF                         1 "pfa.fftshf" "s8"  -PACK1;
	nFILSHF                         1 "pfa.filshf" "s8"  -PACK1;
  0                               1 "_blank1"    "s16" -PACK1;
	"uasr.pfa.dim"   30    -CFG_get 1 "pfa.dim"    "u16" -PACK1;
	-0.5 -1 *                       1 "pfa.mgcgam" "u16" -PACK1;
	0.47                            1 "pfa.mgclam" "u16" -PACK1;
  0                               1 "_blank1"    "s8"  -PACK1;
	flen -PACK_wvl;
	idWnd 0 .nMAX_FRAME_DIM           "pfa.wnd"    "u16" -PACK;

	nFILFAC -PACK_fil;
	nrm -PACK_log nrm =;
	"\n  nrm.log: $[nrm]" -MSG2;
	nrm return;
}
