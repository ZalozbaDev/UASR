## UASR: Unified Approach to Speech Synthesis and Recognition
## - Utility functions: Finite state world modeling
##
## AUTHOR : Matthias Wolff, Werner Meyer
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2014-2015 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"$UASR_HOME/scripts/dlabpro/util/fst.itp" include;                              # FST utilities
"$UASR_HOME/scripts/dlabpro/util/var.itp" include;                              # Variable utilities

## Creates a new empty world automaton.
##
## @param itWm fst
##          Filled with the new world automaton. Any present data will be 
##          deleted.
## @return void
function -WM_init(itWm)
{
  itWm -reset;                                                                  # Clear target
  "world" itWm /fsa /lsr -addunit;                                              # Create weighted acceptor
  "NAME" 255 itWm.sd -addcomp;                                                  # State name
  itWm.NC_TD_RC ( type int ) itWm.td -addcomp;                                  # Add trans. reference counter comp.
}

## Ensures the presence of the specified state ID in a world automaton.
##
## @param nS integer
##          The zero-based index of the state to ensure. If the world model in
##          <code>itWm</code> contains fewer than <code>nS</code>+1 states, the
##          function will add new states.
## @param itWm fst
##          The world model in unit 0. If empty, the function will create a new 
##          world model.
## @return void
function -WM_ensurestate(nS,itWm)
{
  itWm.ud -is_empty if itWm -WM_init; end                                       # Init world automaton if empty
  var nXS; :nXS = itWm.ud[0,itWm.IC_UD_XS];                                     # Number of states in current world
  var nIcSn; ( "NAME" itWm.sd -find_comp ) nIcSn =;                             # Component index of state name
  :nS>=nXS: if                                                                  # Need new states? Yes >>
    0 :nS-nXS+1: itWm -addstates;                                               #   Create new states
    nIcSn -1 > if                                                               #   Have state names? Yes >>
      nXS nS =; :nS<itWm.ud[0,itWm.IC_UD_XS]: while                             #     Iterate new states >>
        "$[nS]" nS nIcSn itWm.sd -store;                                        #       Set state name
        nS ++=;                                                                 #       Next state
      end                                                                       #     <<
    end                                                                         #   <<
  end                                                                           # <<
}

## Finds a transition in a world automaton.
##
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition.
## @param nAct integer
##          The action of the transition.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the first matching transision, or -1 if 
##         no matching transition was not found. 
function -WM_findtrans(nIni,nTer,nAct,itWm)
{
  data idTd; itWm.td 0 :itWm.ud[0,itWm.IC_UD_XT]: idTd /rec -select;            # Get transition table of unit 0
  idTd -is_empty if -1 return; end                                              # No transitions -> return not found

  "IDX" ( type int ) idTd -addcomp;                                             # Add index component
  :idTd.dim-1: 1 idTd /comp -mark; 0 1 idTd /mark -fill;                        # Fill index component
  :(idTd[itWm.IC_TD_INI].==nIni).&&(idTd[itWm.IC_TD_TER].==nTer).&&(idTd[itWm.NC_TD_TIS].==nAct):
    idTd /comp -dmark;                                                          # Mark matching transition(s)
  idTd 0 0 idTd /mark -select;                                                  # Discard unmarked transitions
  :idTd.nrec==0: if -1 return; end                                              # No matching trans. -> ret. not found
  :idTd[0,idTd.dim-1]: return;                                                  # Return index of first match
}

## Adds a transition to a world automaton. If the transition already exists and
## the transition table of <code>itWm</code> contains a reference counter 
## componente, the function will increment the reference counter.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition.
## @param nAct integer
##          The action.
## @param bFinal boolean
##          Indicates whether the terminal state is final.
## @param itWm fst
##          The world automaton. If empty, the function will create a new world
##          model in unit 0.
## @return void
function -WM_addtrans(nIni,nTer,nAct,bFinal,itWm)
{
  :max(nIni,nTer): itWm -WM_ensurestate;                                        # Ensure states for new transition
  var nT; ( nIni nTer nAct itWm -WM_findtrans ) nT =;                           # Find specified transition
  nT 0 < if                                                                     # Does not yet exist >>
    var sOpts; bFinal if "/final" else "" end sOpts =;                          #   Options to -addtrans
    0 nIni nTer itWm $[sOpts] -addtrans;                                        #   Add transition
    :itWm.ud[0,itWm.IC_UD_XT]-1: nT =;                                          #   Index of newly added transition
    :itWm.td[nT,itWm.NC_TD_TIS]=nAct;                                           #   Set action ID (trans. input symbol)
  end
  :itWm.td[nT,itWm.NC_TD_RC]++;                                                 # Increment trans. reference counter
}

## Renders a world automaton using the GraphViz toolkit. The function expects
## GraphViz executables to be found in the path environment variable.
##
## @cgen:index
## @param sFname string
##          The name of the output file.
## @param sMode string
##          The output format; "svg", "eps", "png", or any of the file formats
##          supported by GraphViz.
## @param sMode string
##          -- reserved --
## @param itWm fst
##          The world model to be rendered.
## @return void
function -WM_render(sFname,sFormat,sMode,itWm)
{
  ## TODO: Do special rendering as for Coping paper of ESSV'15! 
  sFname itWm.is NULL 0 sFormat itWm -FST_render_ex;
}

## Creates a maze world automaton.
##
## @cgen:index
## @param idMaze data
##          A maze matrix consisting of the following values: 0 - obstacle,
##          1 - path, and 2 - exit.
## @param idAct data
##          List of action names; "0", "N", "E", "S", "W", "NE", "SE", "SW", and
##          "NW" or any subset of these elements.
## @param sMode string
##          Empty string (default operation) or any combination of the following characters
##          <table cellpadding="3" style="margin-top:6pt; margin-bottom:6pt;">
##            <tr><th>Character     </th><th>Description</th></tr>
##            <tr><td><code>F</code></td><td>Use fall-back action transitions</td></tr>
##          </table>
## @param itWm fst
##          Filled with the world automaton.
## @return void
function -WM_mazeworld(idMaze,idAct,sMode,itWm)
{
  ## Local functions                                                            # -------------------------------------
  function -SID(nR,nC,nSidFallback,idMaze)                                      # Get state ID from row and column IDs
  {                                                                             # >>
    ( nR 0 < ) ( nR idMaze.nrec >= ) || if nSidFallback return; end             #   Outside boundaries -> ret. fallback
    ( nC 0 < ) ( nC idMaze.dim  >= ) || if nSidFallback return; end             #   Outside boundaries -> ret. fallback
    :idMaze[nR,nC]==0: if nSidFallback return; end                              #   Obstacle -> ret. fallback
    :nR*idMaze.dim+nC+1: return;                                                #   Return normal state ID
  }                                                                             # <<

  ## Local variables                                                            # -------------------------------------
  data idDefActs; { "0" "N" "E" "S" "W" "NE" "SE" "SW" "NW" } ' idDefActs =;    # Default actions
  data idAux;                                                                   # Auxiliary data
  var  bFallback; ( ( sMode "F" "search" -VAR_strop ) 0 >= ) bFallback =;       # Create fallback transitions 
  var  nR;                                                                      # Row (record) index
  var  nC;                                                                      # Column (component) index
  var  nIni;                                                                    # Initial state
  var  nTer;                                                                    # Terminal state

  ## Create states                                                              # -------------------------------------
  :idMaze.dim*idMaze.nrec: itWm -WM_ensurestate;                                # Create states in world automaton
  ( 1 itWm.sd.nrec zeros ) idAux =; 0 1 idAux -fill;                            # Make state index
  :idAux[0]%idMaze.dim: idAux -join;                                            # Make x-coordinates of state positions
  :idMaze.nrec-ent(idAux[0]/idMaze.dim): idAux -join;                           # Make y-coordinates of state positions
  idAux 0 1 idAux -delete;                                                      # Remove index
  idAux 1 idAux /rec -rotate; :idAux[0,0]=-1; :idAux[0,1]=-1;                   # Rotate an place entry state at -1,-1
  { "POSX" "POSY" } ' 0 idAux -set_cnames; idAux itWm.sd -join;                 # Name pos. comps., join to state tab.
  
  ## Prepare actions                                                            # -------------------------------------
  idAct itWm.is =;                                                              # Set action list as input symbol table
  idDefActs idAct 0 0 idAux /noerror -gen_index;                                # Index action names in idAct
  :idAux.>=0: idDefActs -join; idDefActs ' idDefActs =;                         # Create bool array of actions in idAct
  ( 1 idAct.nrec zeros ) idAux =; 0 1 idAux -fill; idAux itWm.is -join;         # Make IDs for actions
  itWm.is ' idAux =;                                                            # Make action ID lookup table
  
  ## Create transitions                                                         # -------------------------------------
  0 nR =; nR idMaze.nrec < while                                                # Iterate maze rows >>
    0 nC =; nC idMaze.dim < while                                               #   Iterate maze columns >>
      ( nR nC -1 idMaze -SID ) nIni =;                                          #     Get ID of initial state
      nIni nTer =;                                                              #     Get default ID of terminal state
      :idMaze[nR,nC]==2: if :itWm.sd[nIni,0]=1; end                             #     At exit: make nIni final
      :bFallback: if nIni nTer -2 FALSE itWm -WM_addtrans; end                  #     Create Fallback transition
      :idMaze[nR,nC]!=0: if                                                     #     Current state is no obstacle >>

        ## Entry transitions                                                    #       - - - - - - - - - - - - - - - -
        0 nIni -1 FALSE itWm -WM_addtrans;                                      #       Create entry transition 

        ## 0-transitions (no action)                                            #       - - - - - - - - - - - - - - - -
        nIni nTer =;                                                            #       Get terminal state
        :idDefActs[0,"0"] && !bFallback: if                                     #       No action and no fallback >>
          nIni nTer :idAux[0,"0"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## N-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( :nR-1: nC nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"N"] && (nIni!=nTer || !bFallback): if                     #       N effective or no fallback >>
          nIni nTer :idAux[0,"N"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## S-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( :nR+1: nC nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"S"] && (nIni!=nTer || !bFallback): if                     #       N effective or no fallback >>
          nIni nTer :idAux[0,"S"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<

        ## W-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( nR :nC-1: nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"W"] && (nIni!=nTer || !bFallback): if                     #       W effective or no fallback >>
          nIni nTer :idAux[0,"W"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## E-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( nR :nC+1: nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"E"] && (nIni!=nTer || !bFallback): if                     #       E effective or no fallback >>
          nIni nTer :idAux[0,"E"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## NW-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR-1: :nC-1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"NW"] && (nIni!=nTer || !bFallback): if                    #       NW effective or no fallback >>
          nIni nTer :idAux[0,"NW"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## NE-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR-1: :nC+1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"NE"] && (nIni!=nTer || !bFallback): if                    #       NE effective or no fallback >>
          nIni nTer :idAux[0,"NE"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## SW-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR+1: :nC-1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"SW"] && (nIni!=nTer || !bFallback): if                    #       SW effective or no fallback >>
          nIni nTer :idAux[0,"SW"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## SE-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR+1: :nC+1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"SE"] && (nIni!=nTer || !bFallback): if                    #       SE effective or no fallback >>
          "  \"$[nIni]\" -> \"$[nTer]\" [label=\"SE\"];\n" iDG >>;
        end

      end
      nC ++=;                                                                   #     Next maze column
    end                                                                         #   <<
    nR ++=;                                                                     #   Next maze row
  end                                                                           # <<
}

## EOF
