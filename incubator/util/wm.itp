## UASR: Unified Approach to Speech Synthesis and Recognition
## - Utility functions: Finite state world modeling
##
## AUTHOR : Matthias Wolff, Werner Meyer
## PACKAGE: uasr/scripts/dlabpro/util

## Copyright 2014-2015 UASR contributors (see COPYRIGHT file)
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"$UASR_HOME/scripts/dlabpro/util/fst.itp"  /noerror include;                    # FST utilities
"$UASR_HOME/scripts/dlabpro/util/uasr.itp" /noerror include;                    # UASR utilities
"$UASR_HOME/scripts/dlabpro/util/var.itp"  /noerror include;                    # Variable utilities

var __wm_sNcTdQR; "~QR" __wm_sNcTdQR =;                                         # Q-value/reward component

## -- World model editing and rendering functions --

## Creates a new empty world automaton.
##
## @param itWm fst
##          Filled with the new world automaton. Any present data will be 
##          deleted.
## @return void
function -WM_init(itWm)
{
  itWm -reset;                                                                  # Reset target
  "world" itWm /fsa /lsr -addunit;                                              # Create weighted acceptor
  "NAME" 255 itWm.sd -addcomp;                                                  # State name
  itWm.NC_TD_RC ( -type int    ) itWm.td -addcomp;                              # Add trans. reference counter comp.
  .__wm_sNcTdQR ( -type double ) itWm.td -addcomp;                              # Add Q-value/reward component
}

## Ensures the presence of the specified state ID in a world automaton.
##
## @param nS integer
##          The zero-based index of the state to ensure. If the world model in
##          <code>itWm</code> contains fewer than <code>nS</code>+1 states, the
##          function will add new states.
## @param itWm fst
##          The world model in unit 0. If empty, the function will create a new 
##          world model.
## @return void
function -WM_ensurestate(nS,itWm)
{
  itWm.ud -is_empty if itWm -WM_init; end                                       # Init world automaton if empty
  var nXS; :nXS = itWm.ud[0,itWm.IC_UD_XS];                                     # Number of states in current world
  var nIcSn; ( "NAME" itWm.sd -find_comp ) nIcSn =;                             # Component index of state name
  :nS>=nXS: if                                                                  # Need new states? Yes >>
    0 :nS-nXS+1: itWm -addstates;                                               #   Create new states
    nIcSn -1 > if                                                               #   Have state names? Yes >>
      nXS nS =; :nS<itWm.ud[0,itWm.IC_UD_XS]: while                             #     Iterate new states >>
        "$[nS]" nS nIcSn itWm.sd -store;                                        #       Set state name
        nS ++=;                                                                 #       Next state
      end                                                                       #     <<
    end                                                                         #   <<
  end                                                                           # <<
}

## Finds a transition in a world automaton.
##
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition, -1: any terminal state.
## @param nAct integer
##          The action of the transition.
## @param itWm fst
##          The world automaton.
## @return The zero-based index of the first matching transision, or -1 if 
##         no matching transition was not found. 
function -WM_findtrans(nIni,nTer,nAct,itWm)
{
  data idTd;   itWm.td 0 :itWm.ud[0,itWm.IC_UD_XT]: idTd /rec -select;          # Get transition table of unit 0
  data idMark;                                                                  # Transition marking list
  idTd -is_empty if -1 return; end                                              # No transitions -> return not found

  "IDX" ( type int ) idTd -addcomp;                                             # Add index component
  :idTd.dim-1: 1 idTd /comp -mark; 0 1 idTd /mark -fill;                        # Fill index component
  :(idTd[itWm.IC_TD_INI].==nIni).&&(idTd[itWm.NC_TD_TIS].==nAct): idMark =;     # Match initial state and action
  nTer 0 >= if :idMark.&&(idTd[itWm.IC_TD_TER].==nTer): idMark =; end           # If term. state specified, match it
  idMark idTd /comp -dmark;                                                     # Mark matching transition(s)
  idTd 0 0 idTd /mark -select;                                                  # Discard unmarked transitions
  :idTd.nrec==0: if -1 return; end                                              # No matching trans. -> ret. not found
  :idTd[0,idTd.dim-1]: return;                                                  # Return index of first match
}

## Adds a transition to a world automaton. If the transition already exists and
## the transition table of <code>itWm</code> contains a reference counter 
## component, the function will increment the reference counter.
##
## @cgen:index
## @param nIni integer
##          The initial state of the transition.
## @param nTer integer
##          The terminal state of the transition.
## @param nAct integer
##          The action.
## @param bFinal boolean
##          Indicates whether the terminal state is final.
## @param itWm fst
##          The world automaton. If empty, the function will create a new world
##          model in unit 0.
## @return The zero-based transition index of the added/updated transition.
function -WM_addtrans(nIni,nTer,nAct,bFinal,itWm)
{
  :max(nIni,nTer): itWm -WM_ensurestate;                                        # Ensure states for new transition
  var nT; ( nIni nTer nAct itWm -WM_findtrans ) nT =;                           # Find specified transition
  nT 0 < if                                                                     # Does not yet exist >>
    var sOpts; bFinal if "/final" else "" end sOpts =;                          #   Options to -addtrans
    0 nIni nTer itWm $[sOpts] -addtrans;                                        #   Add transition
    :itWm.ud[0,itWm.IC_UD_XT]-1: nT =;                                          #   Index of newly added transition
    :itWm.td[nT,itWm.NC_TD_TIS]=nAct;                                           #   Set action ID (trans. input symbol)
  end                                                                           # <<
  :itWm.td[nT,itWm.NC_TD_RC]++;                                                 # Increment trans. reference counter
  nT return;                                                                    # Return transition index
}

## Renders a world automaton using the GraphViz toolkit. The function expects
## GraphViz executables to be found in the path environment variable.
##
## @cgen:index
## @param sFname string
##          The name of the output file.
## @param sMode string
##          The output format; "svg", "eps", "png", or any of the file formats
##          supported by GraphViz.
## @param sMode string
##          -- reserved --
## @param itWm fst
##          The world model to be rendered.
## @return void
function -WM_render(sFname,sFormat,sMode,itWm)
{
  ## TODO: Do special rendering as for Coping paper of ESSV'15!
  fst itAux; itWm itAux =;
  :itAux.td[itAux.NC_TD_LSR]=itAux.td[.__wm_sNcTdQR];                           # Q-values -> weights
  sFname itWm.is NULL 0 sFormat itAux -FST_render_ex;
}

## -- Special worlds --

## Creates a maze world automaton.
##
## @cgen:index
## @param idMaze data
##          A maze matrix consisting of the following values: 0 - obstacle,
##          1 - path, and 2 - exit.
## @param idAct data
##          List of action names; "0", "N", "E", "S", "W", "NE", "SE", "SW", and
##          "NW" or any subset of these elements.
## @param sMode string
##          Empty string (default operation) or any combination of the following characters
##          <table cellpadding="3" style="margin-top:6pt; margin-bottom:6pt;">
##            <tr><th>Character     </th><th>Description</th></tr>
##            <tr><td><code>F</code></td><td>Use fall-back action transitions</td></tr>
##          </table>
## @param itWm fst
##          Filled with the world automaton.
## @return void
function -WM_mazeworld(idMaze,idAct,sMode,itWm)
{
  ## Local functions                                                            # -------------------------------------
  function -SID(nR,nC,nSidFallback,idMaze)                                      # Get state ID from row and column IDs
  {                                                                             # >>
    ( nR 0 < ) ( nR idMaze.nrec >= ) || if nSidFallback return; end             #   Outside boundaries -> ret. fallback
    ( nC 0 < ) ( nC idMaze.dim  >= ) || if nSidFallback return; end             #   Outside boundaries -> ret. fallback
    :idMaze[nR,nC]==0: if nSidFallback return; end                              #   Obstacle -> ret. fallback
    :nR*idMaze.dim+nC+1: return;                                                #   Return normal state ID
  }                                                                             # <<

  ## Local variables                                                            # -------------------------------------
  data idDefActs; { "0" "N" "E" "S" "W" "NE" "SE" "SW" "NW" } ' idDefActs =;    # Default actions
  data idAux;                                                                   # Auxiliary data
  var  bFallback; ( ( sMode "F" "search" -VAR_strop ) 0 >= ) bFallback =;       # Create fallback transitions 
  var  nR;                                                                      # Row (record) index
  var  nC;                                                                      # Column (component) index
  var  nT;                                                                      # Transition index
  var  nIni;                                                                    # Initial state
  var  nTer;                                                                    # Terminal state
  var  nTis;                                                                    # Transducer input symbol
  var  nFinRew; 1 nFinRew =;                                                    # Direct reward of final state

  ## Create states                                                              # -------------------------------------
  :idMaze.dim*idMaze.nrec: itWm -WM_ensurestate;                                # Create states in world automaton
  ( 1 itWm.sd.nrec zeros ) idAux =; 0 1 idAux -fill;                            # Make state index
  :idAux[0]%idMaze.dim: idAux -join;                                            # Make x-coordinates of state positions
  :idMaze.nrec-ent(idAux[0]/idMaze.dim): idAux -join;                           # Make y-coordinates of state positions
  idAux 0 1 idAux -delete;                                                      # Remove index
  idAux 1 idAux /rec -rotate; :idAux[0,0]=-1; :idAux[0,1]=-1;                   # Rotate an place entry state at -1,-1
  { "POSX" "POSY" } ' 0 idAux -set_cnames; idAux itWm.sd -join;                 # Name pos. comps., join to state tab.
  
  ## Prepare actions                                                            # -------------------------------------
  idAct itWm.is =;                                                              # Set action list as input symbol table
  idDefActs idAct 0 0 idAux /noerror -gen_index;                                # Index action names in idAct
  :idAux.>=0: idDefActs -join; idDefActs ' idDefActs =;                         # Create bool array of actions in idAct
  ( 1 idAct.nrec zeros ) idAux =; 0 1 idAux -fill; idAux itWm.is -join;         # Make IDs for actions
  itWm.is ' idAux =;                                                            # Make action ID lookup table
  
  ## Create transitions                                                         # -------------------------------------
  0 nR =; nR idMaze.nrec < while                                                # Iterate maze rows >>
    0 nC =; nC idMaze.dim < while                                               #   Iterate maze columns >>
      ( nR nC -1 idMaze -SID ) nIni =;                                          #     Get ID of initial state
      nIni nTer =;                                                              #     Get default ID of terminal state
      :idMaze[nR,nC]==2: if :itWm.sd[nIni,0]=1; end                             #     At exit: make nIni final
      :bFallback: if nIni nTer -2 FALSE itWm -WM_addtrans; end                  #     Create fallback transition
      :idMaze[nR,nC]!=0: if                                                     #     Current state is no obstacle >>

        ## Entry transitions                                                    #       - - - - - - - - - - - - - - - -
        0 nIni -1 FALSE itWm -WM_addtrans;                                      #       Create entry transition 

        ## 0-transitions (no action)                                            #       - - - - - - - - - - - - - - - -
        nIni nTer =;                                                            #       Get terminal state
        :idDefActs[0,"0"] && !bFallback: if                                     #       No action and no fallback >>
          nIni nTer :idAux[0,"0"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## N-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( :nR-1: nC nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"N"] && (nIni!=nTer || !bFallback): if                     #       N effective or no fallback >>
          nIni nTer :idAux[0,"N"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## S-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( :nR+1: nC nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"S"] && (nIni!=nTer || !bFallback): if                     #       S effective or no fallback >>
          nIni nTer :idAux[0,"S"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<

        ## W-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( nR :nC-1: nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"W"] && (nIni!=nTer || !bFallback): if                     #       W effective or no fallback >>
          nIni nTer :idAux[0,"W"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## E-transitions                                                        #       - - - - - - - - - - - - - - - -
        ( nR :nC+1: nIni idMaze -SID ) nTer =;                                  #       Get terminal state
        :idDefActs[0,"E"] && (nIni!=nTer || !bFallback): if                     #       E effective or no fallback >>
          nIni nTer :idAux[0,"E"]: FALSE itWm -WM_addtrans;                     #         Create action transition
        end                                                                     #       <<
    
        ## NW-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR-1: :nC-1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"NW"] && (nIni!=nTer || !bFallback): if                    #       NW effective or no fallback >>
          nIni nTer :idAux[0,"NW"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## NE-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR-1: :nC+1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"NE"] && (nIni!=nTer || !bFallback): if                    #       NE effective or no fallback >>
          nIni nTer :idAux[0,"NE"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## SW-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR+1: :nC-1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"SW"] && (nIni!=nTer || !bFallback): if                    #       SW effective or no fallback >>
          nIni nTer :idAux[0,"SW"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<
    
        ## SE-transitions                                                       #       - - - - - - - - - - - - - - - -
        ( :nR+1: :nC+1: nIni idMaze -SID ) nTer =;                              #       Get terminal state
        :idDefActs[0,"SE"] && (nIni!=nTer || !bFallback): if                    #       SE effective or no fallback >>
          nIni nTer :idAux[0,"SE"]: FALSE itWm -WM_addtrans;                    #         Create action transition
        end                                                                     #       <<

      end                                                                       #     <<
      nC ++=;                                                                   #     Next maze column
    end                                                                         #   <<
    nR ++=;                                                                     #   Next maze row
  end                                                                           # <<

  ## Create direct reward at exit transitions                                   # -------------------------------------
  0 nT =; nT itWm.td.nrec < while                                               # Loop over transitions >>
    :nTer = itWm.td[nT,itWm.IC_TD_TER];                                         #   Get terminal state
    :nTis = itWm.td[nT,itWm.NC_TD_TIS];                                         #   Get input symbol
    :(itWm.sd[nTer,0]!=0) && (nTis!=-1): if                                     #   Non-epsilon exit transition >> 
      :itWm.td[nT,.__wm_sNcTdQR]=nFinRew;                                       #     Set direct reward
    end                                                                         #   end
    nT ++=;                                                                     #   Next transition
  end                                                                           # <<
}

## -- World model execution functions --

## Returns the current state of a world automaton.
##
## @param itWm fst
##          The world model in unit 0. 
## @return The zero-based index of the current state.
## @see -WM_setstate
function -WM_getstate(itWm)
{
  itWm.ud.descr0 return;                                                        # State stored in ud.descr0
}

## Sets the current state of a world automaton.
##
## @param nS int
##          The zero-based index of the current state. There are no checks 
##          performed.
## @param itWm fst
##          The world model in unit 0. 
## @return void
## @see -WM_getstate
## @see -WM_setrandomstate
function -WM_setstate(nS,itWm)
{
  nS itWm.ud -set descr0;                                                       # State stored in ud.descr0
}

## Randomly sets a new current state of a world automaton.
##
## @param itWm fst
##          The world model in unit 0. 
## @return The zero-based index of the newly selected state.
## @see -WM_getstate
## @see -WM_setstate
function -WM_setrandomstate(itWm)
{
  fst  itAux;                                                                   # Auxiliary transducer
  data idAux;                                                                   # Auxiliary data instance
  var  nRS;                                                                     # Random state
  itWm 0 { 0 } 0 NULL 1 itAux /forward -excerpt;                                # Go one transition from beginning
  itAux.td itAux.IC_TD_TER itAux.sd 1 1 idAux -lookup;                          # Get world state IDs
  idAux 0 nRS -rset;                                                            # Select random world state (name)
  $[nRS] itWm.ud -set descr0;                                                   # Convert to int and set current state
  itWm.ud.descr0 return;                                                        # Return current state
}

## Performs one action in a finite state world.
## 
## @param nAct int
##          Zero-based index of the action to be performed, -1 for no action.
## @param itWm fst
##          The world model in unit 0. 
## @return A data instance with exactly one record of the following structure:
##    <table>
##      <tr><th>Component</th><th>Type</th><th>Description</th></tr>
##      <tr><td>0</td><td><code>int</code></td><td>State before performing <code>nAct</code></td></tr>
##      <tr><td>1</td><td><code>int</code></td><td>State after performing <code>nAct</code></td></tr>
##      <tr><td>2</td><td><code>int</code></td><td><code>nAct</code></td></tr>
##      <tr><td>3</td><td><code>double</code></td><td>The direct reward of <code>nAct</code></td></tr>
##    </table>
## @see -WM_qlearn
function -WM_act(nAct,itWm)
{
  data idRes;                                                                   # Result
  var  nDRw; 0 nDRw =;                                                          # Direct reward of action
  var  nIni; itWm.ud.descr0 nIni =;                                             # Current world state
  var  nTer; nIni nTer =;                                                       # World state after action (default)
  var  nT; ( nIni -1 nAct itWm -WM_findtrans ) nT =;                            # Get action transition
  :(nT>=0) && (nAct>=0): if                                                     # Action transition found >>
    :itWm.td[nT,itWm.IC_TD_TER]: nTer =;                                        #   Get world state after action
    :itWm.td[nT,.__wm_sNcTdQR]:  nDRw =;                                        #   Get direct reward of action
  end                                                                           # <<
  nTer itWm.ud -set descr0;                                                     # Set new world state
  { $[nIni] $[nTer] $[nAct] $[nDRw] } idRes =;                                  # Prepare result
  { "nIni" "nTer" "nAct" "nR" } ' 0 idRes -set_cnames;                          # ...
  idRes return;                                                                 # Return result
}

## -- Learning functions --

## Simple Q-learning. The function interacts with the world model
## <code>itWm</code> only by invoking <a href="#clp_-WM_setrandomstate"
## >-WM_setrandomstate</a> and <a href="#clp_-WM_act">-WM_act</a>. These 
## functions may be overloaded to implement other worlds.
##
## @param idAct data
##         A list of actions which can be performed in the world.
## @param nDefQ double
##         Initial Q-value, 3 is a reasonable choice.
## @param nDctQ double
##         Q discount factor, 0.9 is a reasonable choice.
## @param nXIte int
##         Number of iterations.
## @param itWm fst
##          The world model in unit 0. 
## @param itIwm fst
##           Filled with the inner world model of the cognitive agent after 
##           Q-learning.
## @return void
function -WM_qlearn(idAct,nDefQ,nDctQ,nXIte,itWm,itIwm)
{
  function -LPA(nIni,idAct,nDefQ,itIwm)                                         # List possible actions at nIni
  {                                                                             # >>
    data idRes;                                                                 #   Result (transition list)
    data idRes2;                                                                #   List transitions from nIni in itIwm
    data idAux;                                                                 #   Auxiliary data instance
    var  nIcTdTis; ( itIwm.NC_TD_TIS itIwm.td -find_comp ) nIcTdTis =;          #   Transducer input symbol comp. index

    itIwm.td idRes =; 1 idRes -allocate;                                        #   Make one empty dummy transition
    :idRes[0,itIwm.IC_TD_INI]=nIni;                                             #   Set initial state
    :idRes[0,itIwm.IC_TD_TER]=-1;                                               #   Set terminal state
    :idRes[0,.__wm_sNcTdQR]=nDefQ;                                              #   Set initial Q-value
    ( 1  idAct.nrec zeros ) 0 idRes 0 idRes.dim idRes -lookup;                  #   Duplicate trans. idAct.nrec times
    itIwm.NC_TD_TIS nIcTdTis idRes -rindex;                                     #   Fill in action indices
    :itIwm.td[itIwm.IC_TD_INI].==nIni: itIwm.td /comp -dmark;                   #   Mark existing transitions from nIni
    itIwm.td 0 0 idRes2 /mark -select; itIwm.td -unmark;                        #   Copy marked transitions and unmark
    idRes2 -is_empty not if                                                     #   Found existing transitions >>
      idRes idRes2 nIcTdTis nIcTdTis idAux -gen_index;                          #     Find actions in default result
      :idAux.>=0: idRes /comp -dmark; idRes 0 0 idRes /mark -delete;            #     Delete them
      idRes2 idRes -cat;                                                        #     Append existing trans. to result
    end                                                                         #   <<
    -UASR_get_vlevel 3 >= if                                                    #   Verbose level 3 and higher >>
      "\n     Possible actions at state $[nIni]"                         -echo; #     Protocol
      var nR; nR idRes.nrec < while                                             #     Loop over action list >>
        "\n     - ${idRes[nR,itIwm.NC_TD_TIS]}"                          -echo; #       Protocol
        " (\"${idAct[idRes[nR,itIwm.NC_TD_TIS],0]}\"):"                  -echo; #       Protocol
        " -> ter=" :idRes[nR,itIwm.IC_TD_TER]<0: if "?"                         #       Protocol
          else "${idRes[nR,itIwm.IC_TD_TER]}" end +                      -echo; #       ...
        ", Q=${idRes[nR,.__wm_sNcTdQR]}"                                 -echo; #       Protocol
        nR ++=;                                                                 #       Next possible action
      end                                                                       #     <<
      "\n     "                                                          -echo; #   Protocol
    end                                                                         #   <<
    idRes return;                                                               #   Return a transition list
  }                                                                             # <<

  data idLpa;                                                                   # List of possible actions
  data idObs;                                                                   # Observation of the world
  data idAux;                                                                   # Auxiliary data instance
  var  nRAct;                                                                   # Random action
  var  nAct;                                                                    # Current action
  var  nIni;                                                                    # World state (before action)
  var  nTer;                                                                    # World state (after action)
  var  nDrw;                                                                    # Direct reward from world
  var  nT;                                                                      # Transition index in inner world model
  var  nIte;                                                                    # Current Q-learning iteration
  
  ## Initialization                                                             # -------------------------------------  
  itIwm -WM_init;                                                               # Reset agent's inner world model
  
profile iP; profile iXP; iXP -begin_timer;
iP -cont_timer; # == PROFILE SNIPPET =>
iP -break_timer; # <= PROFILE SNIPPET ==
  ## Q-learning iteration                                                       # -------------------------------------
  "\n\n   Q-Learning ($[nXIte] iterations)"                               -MSG; # Protocol
    "\n   - Initial Q-value: $[nDefQ]"                                    -MSG; # Protocol
    "\n   - Q discount     : $[nDctQ]"                                    -MSG; # Protocol
  0 1 -PBAR;                                                                    # Begin progress bar
  0 nIte =; nIte nXIte < while                                                  # Q-learning iteration >>
    ( itWm -WM_setrandomstate ) nIni =;                                         #   15% # Randomly set a new world state
    0 nIni -1 FALSE itIwm -WM_addtrans;                                         #   17% # This is a possible start state
    "\n   - ${nIte+1}/$[nXIte]: ini=$[nIni]"                             -MSG2; #   Protocol
    :(nIte+1)/nXIte: 1 -PBAR;                                                   #   Display progress

    ## List and rank action options, then choose and perform action             #   35% # - - - - - - - - - - - - - - - - - -
    ( nIni idAct nDefQ itIwm -LPA ) idLpa =;                                    #   11% # Get action options from nIni
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    :idLpa[.__wm_sNcTdQR].==idAux[0,0]: idLpa /comp -dmark;                     #   Mark maximal Q-values
    idLpa 0 0 idLpa /mark -select; idLpa -unmark;                               #   Delete non-maxima
    idLpa ( itIwm.NC_TD_TIS idLpa -find_comp ) nRAct -rset; nRAct nAct =;       #   Randomly choose from remaining opts
    ", act=$[nAct] (\"${idAct[nAct,0]}\")"                               -MSG2; #   Protocol
    ( nAct itWm -WM_act ) idObs =;                                              #   17% # Perform action
    :idObs[0,1]: nTer =;                                                        #   New world state
    :idObs[0,3]: nDrw =;                                                        #   Direct reward from world
    " -> ter=$[nTer], reward=$[nDrw]"                                    -MSG2; #   Protocol

    ## Extend inner world model and compute new Q-values                        #   31% # - - - - - - - - - - - - - - - - - -
    ( nTer idAct nDefQ itIwm -LPA ) idLpa =;                                    #   12% # Get action options from nTer
    :idLpa[.__wm_sNcTdQR]: NULL 0 "max" idAux /rec -aggregate;                  #   Get maximal Q-value
    ( nIni nTer nAct :nDrw>0: itIwm -WM_addtrans ) nT =;                        #   17% # Log action in inner world model
    :itIwm.td[nT,.__wm_sNcTdQR]=nDctQ*idAux[0,0]+nDrw;                          #   Set Q-value of action transition
    ", maxQ=${idAux[0,0]} -> Q=$[nDctQ]*${idAux[0,0]}+$[nDrw]"           -MSG2; #   Protocol
    "=${itIwm.td[nT,.__wm_sNcTdQR]}"                                     -MSG2; #   Protocol

    nIte ++=;                                                                   #   Next iteration step
  end                                                                           # <<
  "\n  " -MSG2; "done\n\n"                                                -MSG; # Protocol
iXP -break_timer;
"   Profile\n   - Snippet: $[iP.time] ms"                                -echo;
", ${round(iP.time/iXP.time*1000)/10} %, $[iP.calls]x"                   -echo;
"\n   - Total  : $[iXP.time] ms\n"                                       -echo;
}

## EOF