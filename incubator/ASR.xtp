#!/usr/bin/env dlabpro
## Unified Approach to Speech Synthesis and Recognition
## - Experimental offline speecg recognizer
##
## AUTHOR : Matthias Wolff
## PACKAGE: (uasr/scripts/dlabpro)
##
## ARGUMENTS:
##   $1: Configuration file

## Copyright 2014 UASR contributors (see COPYRIGHT file)
## - Chair of System Theory and Speech Technology, TU Dresden
## - Chair of Communications Engineering, BTU Cottbus
##
## This file is part of UASR.
##
## UASR is free software: you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation, either version 3 of the License, or (at your option)
## any later version.
##
## UASR is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
## details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with UASR. If not, see <http://www.gnu.org/licenses/>.

"$UASR_HOME/scripts/dlabpro/util/cfg.itp"  include;                             # Include configuration utilities
"$UASR_HOME/scripts/dlabpro/util/fea.itp"  include;                             # Include feature utilities
"$UASR_HOME/scripts/dlabpro/util/fst.itp"  include;                             # Include fst utilities
"$UASR_HOME/scripts/dlabpro/util/lab.itp"  include;                             # Include label utilities
"$UASR_HOME/scripts/dlabpro/util/sig.itp"  include;                             # Include signal utilities
"$UASR_HOME/scripts/dlabpro/util/uasr.itp" include;                             # Include UASR utilities
"$UASR_HOME/scripts/dlabpro/util/var.itp"  include;                             # Include UASR variables' utilities

"$UASR_HOME/incubator/util/confidence.itp" include;                             # Include ASR confidence utilities

## -- Overloadable functions ---------------------------------------------------

## Standard speech recognition confidence computation for a segment of the
## recognition result.
##
## @param idRes data
##          The post-processed recognition result as returned by
##          {@link -ASR_postprocess}.
## @param iSi object
##          The recognizer session information.
## @param nFirstFrame integer
##          The zero-based first frame index, inclusive. 
## @param nLastFrame integer
##          The zero-based last frame index, inclusive; -1 for "end of sequence".
## @global nNadT R
## @return
##   The recognizer confidence ranging from -1 for "sure to reject" to 1 for
##   "sure to accept". If a positive value is returned, the recognition result
##   should be accepted.
function -ASR_confidence(idRes,iSi,nFirstFrame,nLastFrame)
{
  data idRes2;                                                                  # Copy of recognition result

  ## HACK: Magic confidence parameters; better implementation pending...        # From Leonard Foerster's BA thesis
  ".__CNF_nNadM" "rej.nad.mean" 0.0612 -CFG_get_persistent;                     # NAD mean
  ".__CNF_nNadS" "rej.nad.sdev" 0.0260 -CFG_get_persistent;                     # NAD std. dev.
  ".__CNF_sNadO" "rej.nad.op"   "neg"  -CFG_get_persistent;                     # NAD standardization extra operation
  ".__CNF_nNadT" "rej.nad.thrs" 0.36   -CFG_get_persistent;                     # NAD threshold

  ## Copy subsequence of recognition result                                     # -------------------------------------
  nLastFrame 0 < if idRes.nrec nLastFrame =; end                                # Handle "until end of sequence"
  idRes nFirstFrame ( nLastFrame nFirstFrame - ) idRes2 /rec -select;           # Select frames
  idRes.nrec 0 == if NAN return; end                                            # No frames left --> conf.=NAN

  ## Compute recognition confidence                                             # -------------------------------------
  var nNad; ( idRes2 iSi -CNFS_nad ) nNad  =;                                   # Normalized acoustic distance
  :nNad = $[.__CNF_sNadO](nNad-.__CNF_nNadM)/.__CNF_nNadS;                      # Standardize score
  ( nNad isnan ) if -1 return; end                                              # Nan scores -> to be rejected
  :min(max(nNad-.__CNF_nNadT,-1),1): return;                                    # Compute and return confidence
}

## Standard post-processing of a speech recognition result.
##
## @param itRR fst
##          The recognition result (with grammar).
## @param itRRr fst
##          The reference recognition result (phoneme loop).
## @param idNld data
##          The neg. log. density array of the recognition.
## @param iSi object
##          The recognizer session information.
## @return
##   A data instance containing extactly one record per speech frame. The
##   components are:
##   <table>
##     <tr><th>Name</th><th>Description</th></tr>
##     <tr><td>GMM </th><th>GMM indices of speech recognition</th></tr>
##     <tr><td>GMMr</th><th>GMM indices of reference recognition</th></tr>
##     <tr><td>PHN </th><th>Phoneme indices of speech recognition</th></tr>
##     <tr><td>PHNr</th><th>Phoneme indices of reference recognition</th></tr>
##     <tr><td>NLL </th><th>Neg. log. likelihoods of speech recognition</th></tr>
##     <tr><td>NLLr</th><th>Neg. log. likelihoods of reference recognition</th></tr>
##     <tr><td>dNLL</th><th>Neg. log. likelihood difference</th></tr>
##     <tr><td>PLB </th><th>Phoneme labels of speech recognition</th></tr>
##     <tr><td>PLBr</th><th>Phoneme labels of reference recognition</th></tr>
##     <tr><td>OLB </th><th>Output labels of speech recognition</th></tr>
##   </table>
##   A text representation of the speech recognition result is stored in
##   <code>ftext</code>.
function -ASR_postprocess(itRR,itRRr,idNld,iSi)
{
  ## Local functions and instances                                              # -------------------------------------
  function -phnlabel(itGP,itRes)                                                # Recover per-frame phoneme labels
  {                                                                             # >>
    fst itAux;                                                                  #   Auxiliary transducer
    data idAux;                                                                 #   Auxiliary data
    itRes itAux -copy;                                                          #   Copy recognition result
    0 itAux -invert;                                                            #   Invert
    itAux itGP 0 0 itAux -compose;                                              #   Compose with labeling transducer
    itAux 0 1 -1 itAux -best_n;                                                 #   Best path (if solution not unique)
    :itAux.td["~TOS"]: idAux -copy;                                             #   Copy recovered labels
    idAux.nrec itRes.td.nrec != if "phnlabel: " .S_WRONGNOFRAMES + -ERROR; end  #   Wrong # of recovered labels
    0 "~PHN" idAux -set_cname;                                                  #   Name label component
    idAux itRes.td -join;                                                       #   Join to recognition result
  }                                                                             # <<
  function -outlabel(itRes)                                                     # Get per-frame output labels
  {                                                                             # >>
    data idAux;                                                                 #   Auxiliary data
    var  nR;                                                                    #   Record counter
    var  nXR;                                                                   #   Last non-epsilon-input record
    var  sL;                                                                    #   Aggregated label
    var  sOut; "" sOut =;                                                       #   Output string
  
    :itRes.td["~TOS"]: 0 itRes.os 0 1 idAux -lookup;                            #   Get transition output labels
    "" sL =; -1 nXR =; 0 nR =; nR idAux.nrec < while                            #   Loop over result transitions >>
      :sL+=idAux[nR,0];                                                         #     Aggregate output label
      :sOut+=idAux[nR,0];                                                       #     Aggregate output string
      :itRes.td[nR,"~TIS"]<0: if                                                #     Transition input is epsilon >>
        :idAux[nR,0]="";                                                        #       No output label
      else                                                                      #     << Trans. input is not epsilon >>
        :idAux[nR,0]=sL;                                                        #       Store aggregated output label
        "" sL =;                                                                #       Clear aggregated output label
        nR nXR =;                                                               #       Remember transition index
      end                                                                       #     <<
      nR ++=;                                                                   #     Next transition
    end                                                                         #   <<
    ( sL "" != ) ( nXR 0 >= ) && if                                             #   Remaining aggregated label >>
      :idAux[nXR,0]+=sL;                                                        #     Append to last label written
    end                                                                         #   <<
    0 "~OUT" idAux -set_cname; idAux itRes.td -join;                            #   Join output labels to rec. result
    sOut return;                                                                #   Return output string
  }                                                                             # <<
  function -epsremove(idSrc,idDst)                                              # Removes epsilon transitions
  {                                                                             # >>
    # HACK: Inaccurate because epsilon transition weights get lost!             #   #
    idSrc idDst -copy;                                                          #   Copy source
    :idDst["~TIS"].<0: idDst -dmark;                                            #   Mark epsilon transitions
    idDst 0 0 idDst /mark -delete;                                              #   Delete marked records 
  }                                                                             # <<
  function -reweight(idNld,idRes)                                               # Reweight with GMM neg. log. densities
  {                                                                             # >>
    data idAux;                                                                 #   Auxiliary data
    idNld.nrec idRes.nrec != if "Re-weight: " .S_WRONGNOFRAMES + -ERROR; end    #   Check number of records
    "~RID" -1 idRes -rindex;                                                    #   Add record index component
    :idRes["~RID"]: 0 :idRes["~TIS"]: 0 idNld idAux -lookup_2;                  #   Get GMM neg. log. densities
    0 "~NLL" idAux -set_cname; idAux idRes -join;                               #   Add to recognition result
    idRes ( "~RID" idRes -find_comp ) 1 idRes -delete;                          #   Delete record index component
  }                                                                             # <<
  data idRR;                                                                    # Per-frame recognition result
  data idRRr;                                                                   # Per-frame reference recog. result
  data idRes;                                                                   # Post-processed recognition result
  data idAux;                                                                   # Auxiliary data
  var  sOut;                                                                    # Output string of speech recognition

  ## Get per-frame labels of recognition results                                # -------------------------------------
  iSi.itGP itRR  -phnlabel;                                                     # Phonemes of speech recognition 
  iSi.itGP itRRr -phnlabel;                                                     # Phonemes of reference recognition
  ( itRR -outlabel ) sOut =;                                                    # Output symbols of speech recognition 

  ## Remove epsilon transitions                                                 # ------------------------------------- 
  itRR.td  idRR  -epsremove;                                                    # ... from speech recognition result
  itRRr.td idRRr -epsremove;                                                    # ... from reference recognition result

  ## Recover pure acoustic neg. log. likelihoods                                # -------------------------------------
  ## (i. e. remove the time-invariant HMM, lexicon and grammar weights)         #
  idNld idRR  -reweight;                                                        # ... of speech recognition result
  idNld idRRr -reweight;                                                        # ... of reference recognition result

  ## Collect useful data into recognition result                                # -------------------------------------
  :idRR["~TIS"]:  idRes -copy;                                                  # GMM indices of speech recog. result 
  :idRRr["~TIS"]: idRes -join;                                                  # GMM indices of ref. recog. result
  :idRR["~PHN"]:  idRes -join;                                                  # Phoneme indices of speech recog. res.
  :idRRr["~PHN"]: idRes -join;                                                  # Phoneme indices of ref. recog. res.
  :idRR["~NLL"]:  idRes -join;                                                  # Neg.log.likelihoods of sp. rec. res.
  :idRRr["~NLL"]: idRes -join;                                                  # Neg.log.likelihoods of ref. rec. res.
  :idRes[4]-idRes[5]: idRes -join;                                              # Add NLL difference component...
  :idRR["~PHN"]:  0 iSi.itRNr.os 0 1 idAux -lookup; idAux idRes -join;          # Phoneme labels of speech recog. rec.
  :idRRr["~PHN"]: 0 iSi.itRNr.os 0 1 idAux -lookup; idAux idRes -join;          # Phoneme labels of ref. recog. rec.
  :idRR["~OUT"]:  idRes -join;                                                  # Output  labels of speech recog. rec.
  { "GMM" "GMMr" "PHN" "PHNr" "NLL" "NLLr" "dNLL" "PLB"  "PLBr" "OLB" } '       # |
    0 idRes -set_cnames;                                                        # Rename result components 

  ## Finish                                                                     # -------------------------------------
  idNld.rinc idRes -set rinc;                                                   # Copy record increment from NLL array
  sOut idRes -set ftext;                                                        # Store output string
  "0,Oscillogram\n0,Oscillogram\n0,Oscillogram\n0,Oscillogram\n"                # |
  "1,Oscillogram\n1,Oscillogram\n-1,Oscillogram\n" +                            # |
  "-1,LabelDisplay\n-1,LabelDisplay\n-1,LabelDisplay" + idRes -set rtext;       # Make display hint for Eclipse
  idRes return;                                                                 # Return post-processed recog. result
}

## TODO: ...
##
## @param idRes data
##          The post-processed recognition result as returned by 
##          {@link -ASR_postprocess}.
## @return TODO: ...
function -FVR_fromrecresult(idRes)
{
  fst  itFvr;                                                                   # Feature-value-relation
  data idTok;                                                                   # Output token sequence
  data idStk;                                                                   # State stack
  data idAux;                                                                   # Auxiliary data
  data idAux2;                                                                  # Auxiliary data #2
  var  nTok;                                                                    # Token counter
  var  nPlv;   0  nPlv =;                                                       # Parentheses level
  var  sCmt;   "" sCmt =;                                                       # Agregated FVR comment string

  ## Create output token sequence                                               # -------------------------------------
  :idRes["OLB"]: "[]()" "splitd" idTok -strop;                                  # Split output preserving brackets
  ( type long ) idTok.dim idTok.nrec idAux -array; 0 1 idAux -fill;             # Create frame index
  idTok ' ( idTok.dim idTok.nrec * ) 1 idTok -reshape;                          # Sequence output tokens
  idAux ' ( idAux.dim idAux.nrec * ) 1 idAux -reshape;                          # Sequence frame index
  idAux idTok -join;                                                            # Join frame index to token sequence
  :idTok[0]: "" "len" idAux -strop; :idAux.==0: idTok -dmark;                   # Mark empty tokens...
  idTok 0 0 idTok /mark -delete;                                                # ... and delete them
  { "TOK" "FRM" } ' 0 idTok -set_cnames;                                        # Name components
  #idTok /list -print; 1 brk;                                                    # Break point

  ## Build FVR tree                                                             # -------------------------------------
  "wFVR" itFvr -addunit;                                                        # Add a unit
  "FFRM" ( -type long ) itFvr.sd -addcomp;                                      # First feature vector of state
  "LFRM" ( -type long ) itFvr.sd -addcomp;                                      # Last feature vector of state
  "LAB"  255            itFvr.sd -addcomp;                                      # State label (temporary)
  0 nTok =; nTok idTok.nrec < while                                             # Loop over tokens >>
    :idTok[nTok,"TOK"]=="[": if                                                 #   Open state >>
      0 1 itFvr -addstates;                                                     #     Add new state
      idStk.nrec 0 > if 0 :idStk[0,0]: :itFvr.sd.nrec-1: itFvr -addtrans; end   #     Connect to parent
      :itFvr.sd[itFvr.sd.nrec-1,"FFRM"]=idTok[nTok,"FRM"];                      #     Store first speech frame index
      { ${itFvr.sd.nrec-1} } idStk -cat; idStk 1 idStk /rec -rotate;            #     Push state
    else :idTok[nTok,"TOK"]=="]": if                                            #   << Close state >>
      idStk.nrec 0 > if                                                         #     Stack not empty >>
        :itFvr.sd[idStk[0,0],"LFRM"]=idTok[nTok,"FRM"];                         #       Store last speech frame index
        idStk 0 1 idStk /rec -delete;                                           #       Pop state
      else                                                                      #     << Stack empty >>
        "Too many ']' in FVR string" 1 -WARNING;                                #       Syntax error
      end                                                                       #     <<
    else :idTok[nTok,"TOK"]=="(": if                                            #   << Begin comment sequence >>
      nPlv ++=;                                                                 #     Increment parentheses level
      :sCmt+=idTok[nTok,"TOK"];                                                 #     Append token to comment
    else :idTok[nTok,"TOK"]==")": if                                            #   << End comment sequence >>
      nPlv 0 > if nPlv --=; else "Too many ')' in FVR string" 1 -WARNGING; end  #     Decrement parentheses level
      :sCmt+=idTok[nTok,"TOK"];                                                 #     Append token to comment
    else                                                                        #   << Fill in state or comment >>
      nPlv 0 > if                                                               #     Fill in comment >>
        :sCmt+=idTok[nTok,"TOK"];                                               #       Append token to comment
      else                                                                      #     << Fill in state >>
        idStk.nrec 0 > if :itFvr.sd[idStk[0,0],"LAB"]+=idTok[nTok,"TOK"]; end   #       Append token to state label
      end                                                                       #     <<
    end end end end                                                             #   <<
    nTok ++=;                                                                   #   Next token
  end                                                                           # <<
  idStk -is_empty not if "Too many '[' in FVR string" 1 -WARNING; end           # Stack not empty: syntax error
  nPlv 0 >            if "Too many '(' in FVR string" 1 -WARNING; end           # Parentheses open: syntax error
  
  "\n***sCmt=\"" sCmt + "\"" + -echo; "FVR.svg" NULL NULL 0 itFvr -FST_render;  # Debug protocol
  itFvr -print; 1 brk;                                                          # Break point

  ## TODO: Cascade equally labelled siblings!
}

function -FVR_fromrecresult_(idRes)
{
## -- BOWZ -->
  data idTok;                                                                   # Output token sequence
  data idLvl;                                                                   # Bracket level data
  data idAux;                                                                   # Auxiliary data
  var  nTok;                                                                    # Current token index
  var  nBlvl;                                                                   # Current bracket level
  var  nBeginFrame;                                                             # Beginning frame for confidence comp.
  var  nEndFrame;                                                               # Ending frame for confidence comp.
  var  nLabFrame;                                                               # Label frame to store confidence in
  var  nConf;                                                                   # Segment confidence
  var  sWfvr;                                                                   # The result string
  
  ## Create output token sequence                                               # -------------------------------------
  :idRes["OLB"]: "[]" "splitd" idTok -strop;                                    # Split output preserving brackets
  ( type long ) idTok.dim idTok.nrec idAux -array; 0 1 idAux -fill;             # Create frame index
  idTok ' ( idTok.dim idTok.nrec * ) 1 idTok -reshape;                          # Sequence output tokens
  idAux ' ( idAux.dim idAux.nrec * ) 1 idAux -reshape;                          # Sequence frame index
  idAux idTok -join;                                                            # Join frame index to token sequence
  :idTok[0]: "" "len" idAux -strop; :idAux.==0: idTok -dmark;                   # Mark empty tokens...
  idTok 0 0 idTok /mark -delete;                                                # ... and delete them
  :-ones(1,idTok.nrec): idTok -join;                                            # Add opening bracket's record index
  :-ones(1,idTok.nrec): idTok -join;                                            # Add label's record index
  { "TOK" "FRM" "[@" "LAB@" } ' 0 idTok -set_cnames;                            # Name components
  idTok /list -print; 1 brk;                                                    # Break point

  ## Create bracket level data                                                  # -------------------------------------
  :idTok[0]: "[" "cmp" idAux -strop;                                            # Count opening brackets
  :idAux.==0: NULL 0 "sum" idAux /rec -aggregate;                               # ...
  :idLvl=-ones(2,idAux[0,0]+1);                                                 # Most recent '[' and label on level
  #idLvl -print; 1 brk;                                                          # Break point
  
  ## Loop over tokens                                                           # -------------------------------------
  0  nBlvl =;                                                                   # Initialize bracket level counter
  0 nTok =; nTok idTok.nrec < while                                             # Loop over tokens >>
    :idTok[nTok,0]=="[": if                                                     #   Current token is "[" >>
      nBlvl ++=;                                                                #     Increase bracket level
      :idLvl[nBlvl,0]=nTok;                                                     #     Remember bracket token index
    else :idTok[nTok,0]=="]": if                                                #   << Current token is "]" >>
      :idTok[nTok,2]=idLvl[nBlvl,0];                                            #     Matching opening bracket
      :idTok[nTok,3]=idLvl[nBlvl,1];                                            #     (Last) label token
      :nBeginFrame=idTok[idLvl[nBlvl,0],1];                                     #     Get begin frame
      :nEndFrame=idTok[nTok,1];                                                 #     Get end frame
      0.99 nConf =;
      #( idRes iSi nBeginFrame nEndFrame -ASR_confidence ) nConf =;              #     Compute confidence
      :nLabFrame=idTok[nTok,3];                                                 #     Get label frame
      "${idTok[nLabFrame,0]}:${round(nConf*100)/100}" nLabFrame 0 idTok -store; #     Store confidence in token
      :idLvl[nBlvl,0]=-1;                                                       #     Clear matching opening bracket
      nBlvl --=;                                                                #     Decrease bracket level
    else                                                                        #   << Current token is a label >>
      :idLvl[nBlvl,1]=nTok;                                                     #     Remember label token index
    end end                                                                     #   <<
    nTok ++=;                                                                   #   Next token 
  end                                                                           # <<
  nBlvl 0 < if "Error: FVR string contains too many ']'" -echo; end             # Syntax error 
  nBlvl 0 > if "Error: FVR string contains too many '['" -echo; end             # Syntax error 
  idTok /list -print; 1 brk;                                                    # Break point

  ## Collect wFVR string                                                        # -------------------------------------
  "" sWfvr =;                                                                   # Initialize result string
  0 nTok =; nTok idTok.nrec < while                                             # Loop over tokens >>
    "${idTok[nTok,0]}" sWfvr +=;                                                #   Collect output
    nTok ++=;                                                                   #   Next token 
  end                                                                           # <<
  "\n" sWfvr + "\n\n" + -echo; 1 brk;                                           # Break point
  
  sWfvr return;                                                                 # Return result 
## <-- EOWZ --
}

## -- Utility functions --------------------------------------------------------

## Returns a hash code for a recognizer session information object.
##
## @param iSi object
##          The session information object.
## @return The hash code as string.
function -SI_hash(iSi)
{
  data idAux;                                                                   # Auxiliary data
  iSi.itRN.td 255 idAux /force -tconvert;                                       # String version of itRN's trans. table
  idAux "CRC-32" "hash" idAux -strop;                                           # Hashing
  :idAux[0,0]: return;                                                          # Return hash code
}

## -- Worker functions ---------------------------------------------------------

## Speech recognition of a list of audio files.
##
## @param sFlist string
##          Name of recognition file list (see {@link -CFG_get_flist}).
## @param sLogMode string
##          Controlls writing log files for each recognized turn; Empty (no 
##          logging) or any combination of the following letters:
##          <table>
##            <tr></td>N</td><td>Gaussian neg. log. densities</td></tr>
##            <tr></td>P</td><td>Primary feature vectors     </td></tr>
##            <tr></td>R</td><td>Recognition result          </td></tr>
##            <tr></td>S</td><td>Secondary feature vectors   </td></tr>
##          </table>
## @param sReuMode string
##          Controlls loading previous log files and re-using the respective 
##          data for each recognized turn; Empty (re-compute everyting) or any
##          combination of the following letters:
##          <table>
##            <tr></td>R</td><td>Recognition result (skips the decoding and 
##                               {@link -ASR_postprocess})</td></tr>
##          </table>
function -ASR_recognizer(sFlist,sLogMode,sReuMode)
{
  ## Local functions and instances                                              # -------------------------------------
  function -label(idRes,idVs)                                                   # Label vector sequence with rec.result
  {                                                                             # >>
    :idRes["PLB"]:  idVs -join;                                                 #   Phoneme labels of speech recog.
    :idRes["PLBr"]: idVs -join;                                                 #   Phoneme labels of reference recog.
  }                                                                             # <<
  function -load_res(sFname,sMode,idRes)                                        # Load logged recognition result
  {                                                                             # >>
    "\n     - R: $[sFname]"                                            3 -MSGX; #   Screen protocol
    ( sMode "R" "search" -VAR_strop ) 0 < if                                    #   Loading disabled >>
      " (disabled)"                                      3 -MSGX; FALSE return; #     Screen protocol, return
    end                                                                         #   <<
    sFname idRes /noerror -restore ?error if                                    #   Load failed >>
      " (failed)"                                        3 -MSGX; FALSE return; #     Screen protocol, return
    else                                                                        #   << Load successful >> 
      "R" -MSG2; " (ok)"                                 3 -MSGX; TRUE  return; #     Screen protocol, return
    end                                                                         #   <<
  }                                                                             # <<
  function -log(sFname,idData,sMode,sID)                                        # Log data to a file
  {                                                                             # >>
    ( sMode sID "search" -VAR_strop ) 0 < if leave; end                         #   Abort if this log is disabled
    "\n     - " 3 -MSGX; "L" -MSG2; ": $[sFname]"                      3 -MSGX; #   Screen protocol
    sFname idData -save;                                                        #   Save log data
  }                                                                             # <<

  ## Define instances                                                           # ------------------------------------- 
  data      idPfv;                                                              # Primary feature vector sequence
  data      idSfv;                                                              # Secondary feature vector sequence
  data      idNld;                                                              # GMM neg. log. density array
  data      idRes;                                                              # Recognition result (post-processed)
  data      idAux;                                                              # Auxiliary data
  fst       itRR;                                                               # Recognition result (with grammar)
  fst       itRRr;                                                              # Reference recognition result
  fstsearch iRR;                                                                # Speech decoder (with grammar) 
  fstsearch iRRr;                                                               # Reference decoder phoneme loop)
  var       sSiHash;                                                            # Session info hash code
  var       sWlb;                                                               # Recognized word label string
  var       sWlbr;                                                              # Reference word label string
  var       sLogFn;                                                             # Log file name (w/o extension)
  var       nConf;                                                              # Recognizer confidence [-1...1]

  ## Get paths and recognition file list                                        # -------------------------------------
  "\n\n// Offline speech recognition"                                     -MSG; # Screen protocol
  var  nRNU;    ( "dlg.state" 1     "S" -CFG_get_ex ) nRNU   =;                 # Recognition network unit to use
  var  sAmMod;  ( "am.model" "3_20" "S" -CFG_get_ex ) sAmMod =;                 # Acoustic model identifier 
  var  sModDir; ( "model" "" -CFG_get_path  ) sModDir =;                        # Get model folder
  var  sLogDir; ( "log"   "" -CFG_get_path  ) sLogDir =;                        # Get log folder
  var  sSigDir; ( "sig"   "" -CFG_get_path  ) sSigDir =;                        # Get signal folder
  var  sTrlDir; ( "trl"   "" -CFG_get_path  ) sTrlDir =;                        # Get transliteration folder
  file iF;      ( sFlist  "" -CFG_get_flist ) iF -set flist;                    # Recognition file list

  ## Load models                                                                # -------------------------------------
  object iFi;   "$[sModDir]/feainfo.object"  iFi  -restore;                     # Feature information
  object iSi;   "$[sModDir]/sesinfo.object"  iSi  -restore;                     # Recognizer session information
  gmm    iGmm;  "$[sModDir]/$[sAmMod].gmm"   iGmm -restore;                     # Gaussian mixture models
  ( iSi -SI_hash ) sSiHash =;                                                   # Get hash code of session info object
  "\n   - Feature info  : $[sModDir]/feainfo.object"                      -MSG; # Screen protocol
  "\n   - Session info  : $[sModDir]/sesinfo.object"                      -MSG; # Screen protocol
  "\n                     #$[sSiHash]"                                    -MSG; # Screen protocol
  "\n   - GMMs          : $[sModDir]/$[sAmMod].gmm"                       -MSG; # Screen protocol
  "\n   - Log mode      : " sLogMode not if "(none)" else sLogMode end +  -MSG; # Screen protocol
  "\n   - Re-use mode   : " sReuMode not if "(none)" else sReuMode end +  -MSG; # Screen protocol

  ## Initialize decoders                                                        # -------------------------------------
  "tp"  iRR -set algo; "tp" iRRr -set algo;                                     # Use token passing algorithm
  "t"   iRR -set bt;   "t"  iRRr -set bt;                                       # Output frame labels
  FALSE iRR -set stkprn;                                                        # No stack pruning; TODO: why??

  ## Loop over speech files                                                     # -------------------------------------
  "\n\n   Recognizing $[iF.len] turn(s) ..."                              -MSG; # Screen protocol

  0 1 -PBAR;                                                                    # Begin progress bar
  iF -reset; iF -next while                                                     # Get next file from file list >>
    "\n   - $[iF.nfile 1 +]/$[iF.len] $[iF.sfile]: ..."                  -MSG2; #   Screen protocol (verbose level 2)
    :(iF.nfile+1)/iF.len: 1                                              -PBAR; #   Display progress

    ## - Try loading previous recognition result                                #   - - - - - - - - - - - - - - - - - -
    "$[sLogDir]/SI-$[sSiHash]/$[iF.sfile]" sLogFn =;                            #   Make log file name
    ( "$[sLogFn].res.dn3" sReuMode idRes -load_res ) not if                     #   Load result; failed (or disabled)>>
    
      ## - Do speech recognition                                                #     - - - - - - - - - - - - - - - - -
      ( iF NULL "" idPfv -FEA_get ) not if " SKIP" -MSG2; continue; end         #     Do primary feature analysis
      idPfv iFi iGmm.mean.dim idSfv NULL -FEA_sfa;                   "." -MSG2; #     Do secondary feature analysis
      idSfv NULL idNld iGmm /neglog -density;                        "." -MSG2; #     Compute neg. log. densities
      iSi.itRN  nRNU idNld itRR  iRR  -search;                       "." -MSG2; #     Recognition with grammar
      iSi.itRNr 0    idNld itRRr iRRr -search;                       "." -MSG2; #     Reference recognition
      ( itRR itRRr idNld iSi -ASR_postprocess ) idRes =;             "." -MSG2; #     Post-process recognition result

      ## - Log                                                                  #     - - - - - - - - - - - - - - - - -
      "$[sLogFn].res.dn3" idRes sLogMode "R" -log;                              #     Log recognition result
      idRes idPfv -label; "$[sLogFn].pfv.dn3" idPfv sLogMode "P" -log           #     Log primary features
      idRes idSfv -label; "$[sLogFn].sfv.dn3" idSfv sLogMode "S" -log           #     Log secondary features
      idRes idNld -label; "$[sLogFn].nld.dn3" idNld sLogMode "N" -log           #     Log neg. log. densities

    end                                                                         #   <<
    ( idRes -FVR_fromrecresult ) iFvr  =;                            "." -MSG2; #   Get weighted feature-value rel.
#    " REC=\"" iFvr.sComment + "\"" +                                     -MSG2; #   Screen protocol
    " REC=\"" idRes.ftext + "\"" +                                       -MSG2; #   Screen protocol

    ( 0 1 iF.recfile -fetch ) sWlbr =;                                          #   Get reference word label string
    sWlbr not if                                                                #   No word labels in file list >>
      sTrlDir iF.sfile idAux -TRL_import;                                       #     Load transliteration
      idAux ' " " "ccat" idAux -strop; ( 0 0 idAux -fetch ) sWlbr =;            #     Convert to string
    end                                                                         #   <<
    " REF=\"" sWlbr + "\"" +                                             -MSG2; #   Protocol

    ## - Post-processing                                                        #   - - - - - - - - - - - - - - - - - -
    ( idRes iSi 0 -1 -ASR_confidence ) nConf =; 
    " C=" ( nConf 4 2 ) -FMT_f +                                         -MSG2; #   Compule confidence
        
  end                                                                           # <<
  "\n   " -MSG2; "done\n"                                                 -MSG; # Finish progress bar

  ## Aftermath                                                                  # -------------------------------------
  # TODO: ...

  #idEvl return;
}

## == MAIN PROGRAM ==                                                           # =====================================

## Magic constants                                                              # -------------------------------------
var sCfgFile; "$1"sCfgFile =;                                                   # The UASR configuration file

## Initialize UASR session                                                      # -------------------------------------
"\n// $__SFILE__.xtp revision " -UASR_version + "/" + -version +          -MSG; # Screen protocol
"\n// Process         : $HOSTNAME/" -pid +                                -MSG; # Screen protocol
"\n// Configuration   : $[sCfgFile]"                                      -MSG; # Screen protocol
sCfgFile TRUE -CFG_init;                                                        # Configure session
"$UASR_HOME/scripts/dlabpro/util/uasr_session.itp" include;                     # Include UASR session startup script
"\n\n// AUTOMATIC SPEECH RECOGNITION"                                     -MSG; # Screen protocol
"sig.label" "none" -CFG_set;                                                    # Disable signal labeling

"asr" "R" "" -ASR_recognizer;

quit

## EOF
