## Unified Approach to Speech Synthesis and Recognition
## - Verbmobil data base functions
##
## AUTHOR : Hussein Hussein
## UPDATE : 
##          $Revision: 		 $
## PACKAGE: 
## RCS-ID : 
##


##	==========================================================
##	PAC file (Fujisaki parameter):
##	==============================
##	line number 		content
##	----------------------------------------------------------
##	1 				Path and name of PAC file
##	2 				reserved
##	3 				reserved
##	4 				reserved
##	5 				reserved
##	6 				reserved
##	7 				number of F0 values
##	8 				number of Fujisaki phrase commands I
##	9 				number of Fujisaki accent commands J
##	10 				base frequency value (Fb)
##	11 				time step used for F0 analysis
##	12 				reserved
##	13 				reserved
##	14 				reserved
##	15 				reserved
##	16 				reserved
##	17 				reserved
##	18 				reserved
##	19 				reserved
##	20 				reserved
##	21 				1st phrase command
##	21+I-1      	I-th phrase command
##	21+I 			1st accent command
##	21+I+J-1		J-th accent command
##	==========================================================




## <p>Annotate accents to the sentence.</p>
## @param idPAC data
##          Data instance of Fujisaki parameters (PAC file) (input)
## @param idOrthographic data
##          Data instance of orthographic words without extra words (d or T) [Using (-Delete_Extra_Ortho_Word_LAB_WORD) if there is extra word] (input)
## @param idLabWord data
##          Data instance of word labels, extracted with (-LAB_WORD_extract_vm) (input)
## @param nSampRate
##			Sample rate
## @param nAccLevel
##			Number of levels for accent annotation
## @param idLab data
##          Data instance to be filled with prosodic (accent) annotated words  (output)
function -Accent_Annotation(idPAC,idOrthographic,idLabWord,nSampRate,nAccLevel,idLab)
{
	var nAccAmpMajorThresh;															# Threshold of minimal amplitude of major accent
	var nAccBetaMajorThresh;														# Threshold of Beta of major accent
	var nAccAmpBottom;																# Overall minimal accent amplitude
	var nAccDurBottom;																# Overall minimal Duration of Accent
	var nAccDurTop;																	# Overall maximal Duration of Accent
	var nAccDurMajorThresh;															# Threshold of minimal duration of major accent
	var nPercentAccDurWord;															# Minimal Duration of Accent in Word (in percent)
	var nAccentedWordDurBottom;														# Minimal Duration of accented word

	data idAux;																		# Auxiliary data instance
	data idLabWordEndTime;															# Data object of Word-Label with End-Time of words
	data idTa1DiffArray;															# Difference between Onset time of accent and End time of words
	data idTa2DiffArray;															# Difference between Offset time of accent and End time of words
	data idAccentIndex;																# Index of accent command (Start word and End word)
	data idAa;																		# Data object of Accent Amplitude
	data idBeta;																	# Data object of Beta (Time constant for accent control mechanism)
	data idTa1Array;																# Array for Onset time of accent
	data idTa2Array;																# Array for Offset time of accent
	data idAccentWordIndex;															# Index of accented word in sentence
	data idAccentTimeArray;															# Length of accent in accented word
	data idWordLengthArray;															# Length of accented word
	data idWordAccentTime;															# Time of word in an accent command

  	var nRecPAC; 														  			# Get the number of records (number of records of PAC) 
  	var nRecOrtho; 														  			# Get the number of records (number of orthographic words)
  	var nRecLabWord; 																# Get the number of records (number of word labels with pauses)
	var nAux;
	var nAuxMax;
	
	var sMinorAccent;																# Minor Accent
	var sMajorAccent;																# Major Accent
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase
    var nPhraseI;																	# Number of phrases 
    var nAccentJ;																	# Number of accents
	var Ta1;																		# Onset time of accent command
	var Ta2;																		# Offset time of accent command     
	var Aa;																			# Amplitude of accent command
	var Beta;																		# Time constant for accent control mechanism
	var nAccDur;																	# Duration of accent command
	var nTa1Diff;																	# Difference between Onset time of accent and End time of word
	var nTa2Diff;																	# Difference between Offset time of accent and End time of words
	var nAccStartIndex;																# Index of word, whereas an accent starts
	var nAccEndIndex;  																# Index of word, whereas an accent ended
	var sPause;	        															# A word is a pause
	var sWord;																		# Ortho. word
	var nWordLeng;																	# Length of word
	var nWordTime;																	# Word time in accent command
	var nWordTimeAbs;																# Absolute value of word time
	var nAccMultiIndex;																# Index of word in an accent command
	var nAccSeveralWordsIndex;														# Index of accented word in the sentence

	var i;
	var j;
	var jj;
	var jjj;
	var g;
	var f;

  	## Initialize                                                                 	# -------------------------------------
	0.8 nAccAmpMajorThresh =;														# Major Accent (Aa > 0.8)
	15 nAccBetaMajorThresh =;														# Major Accent (Beta > 15)
	0.01 nAccAmpBottom =;															# Delete an accent, which has a small amplitude (Aa<=0.01)
	0.08 nAccDurBottom =;															# Delete an accent, which has a small duration (Ta_2-Ta_1<0.08 sec)
	1.5 nAccDurTop =;																# Delete an accent, which has a large duration (Ta_2-Ta_1>=1.5 sec)
	0.400 nAccDurMajorThresh =;														# An Accent, which has a larger duration as (400 msec), is Major Accent
	0.60 nPercentAccDurWord =;														# A Duration of accent must be larger than (60%) of word duration
	0.200 nAccentedWordDurBottom =;													# Minimal Duration of accented word (200 msec)

  	idPAC.nrec  nRecPAC =;          												# Get the number of records
  	idOrthographic.nrec  nRecOrtho =;          										# Get the number of records
  	idLabWord.nrec  nRecLabWord =;          										# Get the number of records
	# "#" sMinorAccent =;															# Init a minor Accent variable
	# "#" "#" + sMajorAccent =;														# Init a major Accent variable
	"<a>" sMinorAccent =;															# Init a minor Accent variable
	"<aa>" sMajorAccent =;															# Init a major Accent variable
	#"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	#"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;

    :idPAC[1,0]: nPhraseI =;														# Read a number of phrases from PAC
    :idPAC[2,0]: nAccentJ =;														# Read a number of accents from PAC
	0 g =;

  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLabWordEndTime -reset;
	idTa1DiffArray -reset;
	idTa2DiffArray -reset;
	idAccentIndex -reset;
	idAa -reset;
	idBeta -reset;
	idTa1Array -reset;
	idTa2Array -reset;
	idAccentWordIndex -reset;
	idAccentTimeArray -reset;
	idWordLengthArray -reset;
	idWordAccentTime -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"WordAcc" 25 idLab -addcomp;													# Output data object

	"EndTime" type double idLabWordEndTime -addcomp;

	"StarAcc" type long idAccentIndex -addcomp;
	"EndAcc" type long idAccentIndex -addcomp;

	"Ta1" type double idTa1Array -addcomp;	
	"Ta2" type double idTa2Array -addcomp;	
	"Aa" type double idAa -addcomp;
	"Beta" type double idBeta -addcomp;

	"AccInd" type long idAccentWordIndex -addcomp;	
	"AccTyp" type long idAccentWordIndex -addcomp;		
	
	"AccTime" type double idAccentTimeArray -addcomp;	

	"WordLen" type double idWordLengthArray -addcomp;		
	
	"WordTim" type double idWordAccentTime -addcomp;	


	## Calculate the End-Time of Word-Label and convert it from sample to second   	# -------------------------------------
	0 i =; 																			# Init a loop counter i	
	label L1;                                             							# Define a jump label named L1
	i nRecLabWord < if                                            	 				# If loop counter < (number of records)
		:idLabWord[i,1]: :idLabWord[i,2]: + nAux =; 								# End time = Start time + Length
		i 1 + idLabWordEndTime -reallocate;										    # Reallocates a new record of memory keeping the contents
		:idLabWordEndTime[i,0]=nAux;												# Assign end time
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	idLabWordEndTime nSampRate / idLabWordEndTime =;								# Convert End time from Sample to Second


	## Find the index of Accent														# -------------------------------------		
	nAccentJ 0 == if                                            	 				# If there is no accent >>
		idOrthographic.nrec 1 == if													# Sentence consist of one word
			idOrthographic 0 1 idLab -select;										# Copy Orthographic word into output
			leave;																	# Exit from this function		
		else																		# Sentence consist of more than one word
			idOrthographic 0 idOrthographic.nrec 1 - idLab -select;					# Copy Orthographic words into output
			leave;																	# Exit from this function
		end
	else
	nAccentJ 0 > if																	# There is at least one accent
		5 nPhraseI + j =; 															# Init a loop counter j	(The first five records: F0-Nr., Phrase Nr., Accent-Nr., Fb, F0-rate)
		label L2;                                             						# Define a jump label named L2
		j nRecPAC < if                                            	 				# If loop counter < (number of records)

			:idPAC[j,0]: Ta1 =;														# Onset time of accent command
			Ta1 0 < if																# Onset time of accent command is negative >>
				0 Ta1 =;															# Onset time = 0
			end																	# <<

			:idPAC[j,1]: Ta2 =;														# Offset time of accent command
			Ta2 :idLabWordEndTime[idLabWordEndTime.nrec-1,0]: > if					# Offset time of accent is greater than end time of signal >>
				:idLabWordEndTime[idLabWordEndTime.nrec-1,0]: Ta2 =;				# Offset time = end time of signal
			end																	# <<

			:idPAC[j,2]: Aa =;														# Amplitude of accent command
			:idPAC[j,3]: Beta =;													# Time constant for accent control mechanism
			Ta2 Ta1 - nAccDur =;													# Duration of accent command

			nAccDur nAccDurBottom >= nAccDur nAccDurTop < Aa nAccAmpBottom > && && if # Offset time > Onset time
				## Difference between Onset time of accent and End-Time of word		#   - - - - - - - - - - - - - - - - - -	
				## And Difference between  Offset time and End-Time of the word		#   - - - - - - - - - - - - - - - - - -	
				idTa1DiffArray -reset;												# Reset data object
				"DiffTa1" type double idTa1DiffArray -addcomp;						# Difference between Onset time of accent and End-Time of word
				idTa2DiffArray -reset;												# Reset data object
				"DiffTa2" type double idTa2DiffArray -addcomp;						# Difference between Offset time of accent and End-Time of word

				0 jj =; 															# Init a loop counter jj
				label L3;                                             				# Define a jump label named L3
				jj idLabWordEndTime.nrec < if                                       # If loop counter < (number of records)
					## Difference between Onset time of accent and End-Time of word
					Ta1 :idLabWordEndTime[jj,0]: - nTa1Diff =;						# Difference between Onset time of accent and End-Time of word
					jj 1 + idTa1DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idTa1DiffArray[jj,0]=nTa1Diff;									# Copy the value to data object
					## Difference between Offset time of accent and End-Time of word
					Ta2 :idLabWordEndTime[jj,0]: - nTa2Diff =;						# Difference between Offset time of accent and End-Time of word
					jj 1 + idTa2DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idTa2DiffArray[jj,0]=nTa2Diff;									# Copy the value to data object
					jj ++=;                                              			# Increment loop counter jj
  					goto L3;                                            			# Jump to label L3
				end                                                 				# End of conditional branch

				## Find the index of word, whereas an accent start					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L4;                                             				# Define a jump label named L4
				jj idTa1DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idTa1DiffArray[jj,0]: 0 < if									# Find the first negative value
						jj nAccStartIndex =;										# Index of word
						goto L5; # Exit from loop                       			# Jump to label L5
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L4;                                            			# Jump to label L4
				end                                                 				# End of conditional branch
			
				label L5;                                             				# Define a jump label named L5

				## Find the index of word, whereas an accent ended					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L6;                                             				# Define a jump label named L6
				jj idTa2DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idTa2DiffArray[jj,0]: 0 <= if									# Find the first negative value
						jj nAccEndIndex =;											# Index of word
						goto L7; # Exit from loop                       			# Jump to label L7
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L6;                                            			# Jump to label L6
				end                                                 				# End of conditional branch

				label L7;                                             				# Define a jump label named L7

				g 1 + idAccentIndex -reallocate;									# Reallocates a new record of memory keeping the contents
				:idAccentIndex[g,0]=nAccStartIndex;									# Start index of accent
				:idAccentIndex[g,1]=nAccEndIndex;									# End index of accent

				g 1 + idTa1Array -reallocate;										# Reallocates a new record of memory keeping the contents
				g 1 + idTa2Array -reallocate;										# Reallocates a new record of memory keeping the contents
				g 1 + idAa -reallocate;												# Reallocates a new record of memory keeping the contents
				g 1 + idBeta -reallocate;											# Reallocates a new record of memory keeping the contents
				:idTa1Array[g,0]=Ta1;												# Onset time of accent command
				:idTa2Array[g,0]=Ta2;												# Offset time of accent command
				:idAa[g,0]=Aa;														# Amplitude of accent command
				:idBeta[g,0]=Beta;													# Time constant for accent control mechanism
				
				## Test if the accent is in one word or extended in several words	#   - - - - - - - - - - - - - - - - - -                    
				nAccStartIndex nAccEndIndex == if									# Accent command is in one word
					:idLabWord[nAccStartIndex,0]: sWord =;							# Read the word
					sWord sPause != if												# Word is not a pause (Accent is in a word and not in a pause)
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=nAccStartIndex;						# Index of word
						:idAccentWordIndex[g,1]=1;									# 1 = accent, 0 = no accent
					else
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=0;									# Index = 0 (Pause)
						:idAccentWordIndex[g,1]=0;									# 1 = accent, 0 = no accent
					end
				
					g 1 + idAccentTimeArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idAccentTimeArray[g,0]=Ta2-Ta1;								# Length of accent in one word

					## Length of accented word
					nAccStartIndex 0 > if
						:idLabWordEndTime[nAccStartIndex,0]: :idLabWordEndTime[nAccStartIndex-1,0]: - nWordLeng =;
					else
					nAccStartIndex 0 == if
						:idLabWordEndTime[nAccStartIndex,0]: nWordLeng =;
					end
					end

					g 1 + idWordLengthArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idWordLengthArray[g,0]=nWordLeng;

				else
				nAccStartIndex nAccEndIndex < if									# Accent command extended in several words
					0 f =;															# Init a variable f
					nAccStartIndex jjj =; 											# Init a loop counter jjj
					label L8;                                             			# Define a jump label named L8
					jjj nAccEndIndex <= if                                       	# If loop counter <= EndIndex

						jjj nAccStartIndex == if									# Accent command is in the first word
							Ta1 :idLabWordEndTime[jjj,0]: - nWordTime =;			# Difference between Begin-Time of accent and End-Time of word
							:nWordTimeAbs=abs(nWordTime);							# Absolute value of difference
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTimeAbs;
							f ++=;
						else
						jjj nAccStartIndex > jjj nAccEndIndex < && if
							:idLabWordEndTime[jjj,0]: :idLabWordEndTime[jjj-1,0]: - nWordTime =;# Difference between End-Time of word and Begin-Time of word 
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTime;
							f ++=;
						else
						jjj nAccEndIndex == if
							Ta2 :idLabWordEndTime[jjj-1,0]: - nWordTime =;			# Difference between End-Time of accent End-Time of word
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTime;
							f ++=;						
						end						
						end
						end			
						
						jjj ++=;                                              		# Increment loop counter jjj
  						goto L8;                                            		# Jump to label L8
					end                                                 			# End of conditional branch				

					## Find the maximal time for words in an accent command			#   - - - - - - - - - - - - - - - - - -
					0 nAuxMax =;
					0 jj =; 														# Init a loop counter jj
					label L9;                                             			# Define a jump label named L9
					jj idWordAccentTime.nrec < if                                   # If loop counter < (number of records)
						:idWordAccentTime[jj,0]: nAuxMax > if						# Find the maximum value
							:idWordAccentTime[jj,0]: nAuxMax =;						# maximum value
						end			
						jj ++=;                                              		# Increment loop counter jj
  						goto L9;                                            		# Jump to label L9
					end                                                 			# End of conditional branch				

					g 1 + idAccentTimeArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idAccentTimeArray[g,0]=nAuxMax;								# Length of accent in one word

					## Index of accented word in accent command with several words	#   - - - - - - - - - - - - - - - - - -
					0 nAccMultiIndex =;
					0 jj =; 														# Init a loop counter jj
					label L90;                                             			# Define a jump label named L90
					jj idWordAccentTime.nrec < if                                   # If loop counter < (number of records)
						:idWordAccentTime[jj,0]: nAuxMax == if						# Find the maximum value
							jj nAccMultiIndex =;									# Index of a maximum value in an accent command
						end			
						jj ++=;                                              		# Increment loop counter jj
  						goto L90;                                            		# Jump to label L90
					end                                                 			# End of conditional branch						

					## Index of accented word in sentence							#   - - - - - - - - - - - - - - - - - -
					nAccStartIndex nAccMultiIndex + nAccSeveralWordsIndex =;		# Index of word in idLabWordEndTime (with pauses)

					## Length of accented word
					nAccSeveralWordsIndex 0 > if
						:idLabWordEndTime[nAccSeveralWordsIndex,0]: :idLabWordEndTime[nAccSeveralWordsIndex-1,0]: - nWordLeng =;
					else
					nAccSeveralWordsIndex 0 == if
						:idLabWordEndTime[nAccSeveralWordsIndex,0]: nWordLeng =;
					end
					end

  					g 1 + idWordLengthArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idWordLengthArray[g,0]=nWordLeng;

					## Test, whereas the accent is in word or in pause
					:idLabWord[nAccSeveralWordsIndex,0]: sWord =;					# Read the word
					sWord sPause != if												# Word is not a pause (Accent is in a word and not in a pause)
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=nAccSeveralWordsIndex;				# Index of word
						:idAccentWordIndex[g,1]=1;									# 1 = accent, 0 = no accent
					else
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=0;									# Index = 0 (Pause)
						:idAccentWordIndex[g,1]=0;									# 1 = accent, 0 = no accent
					end

				end
				end
				g ++=; 
			end                                      								# End of conditional branch
			j ++=;                                              					# Increment loop counter j
  			goto L2;                                            					# Jump to label L2
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch <<
	end                                                 							# End of conditional branch <<

	
#00 break;


	var nAccCount;
	0 nAccCount =;
	
	## Number of accented words
	idAccentWordIndex.nrec nAccCount =;

		
	## Two complete accents are in the same word 									# -------------------------------------
	nAccCount 1 > if																# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L10;                                             						# Define a jump label named L10
		jj nAccCount 1 - < if                                   					# If loop counter < (number of records)
			:idAccentIndex[jj,0]: :idAccentIndex[jj+1,1]: == :idAccentIndex[jj,1]: :idAccentIndex[jj+1,0]: == && if	
				# There are two accents in the same word --> Delete the first accent
				:idAccentIndex[jj,0]=0;
				:idAccentIndex[jj,1]=0;

				:idAccentWordIndex[jj,0]=0;
				:idAccentWordIndex[jj,1]=0;
				
				:idAccentTimeArray[jj,0]=0;
				:idAccentTimeArray[jj+1,0]=idTa2Array[jj+1,0]-idTa1Array[jj,0];		# Begin: Begin of first accent and End: End of second accent
				
				:idWordLengthArray[jj,0]=0;
				
				:idAa[jj,0]=0;
				
				:idBeta[jj,0]=0;								
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L10;                                            					# Jump to label L10
		end                                                 						# End of conditional branch	
	end

#01 break;
	
	data idAccentIndexNew;
	data idAccentWordIndexNew;
	data idAccentTimeArrayNew;
	data idWordLengthArrayNew;
	data idAaNew;
	data idBetaNew;

  	## Reset data                                                                 	# -------------------------------------	
	idAccentIndexNew -reset;
	idAccentWordIndexNew -reset;
	idAccentTimeArrayNew -reset;
	idWordLengthArrayNew -reset;
	idAaNew -reset;
	idBetaNew -reset;

  	## Define a data object structure                                              	# -------------------------------------
	"StarAcc" type long idAccentIndexNew -addcomp;
	"EndAcc" type long idAccentIndexNew -addcomp;

	"AccInd" type long idAccentWordIndexNew -addcomp;	
	"AccTyp" type long idAccentWordIndexNew -addcomp;		
	
	"AccTime" type double idAccentTimeArrayNew -addcomp;	

	"WordLen" type double idWordLengthArrayNew -addcomp;
	
	"Aa" type double idAaNew -addcomp;
	"Beta" type double idBetaNew -addcomp;
	
	## Delete 0 value, if two accents are in the same word or if accent in pause	# -------------------------------------				
	0 jjj =;																		# New counter for accents
	
	0 jj =; 																		# Init a loop counter jj
	label L11;                                             							# Define a jump label named L11
	jj idAccentWordIndex.nrec < if                                   				# If loop counter < (number of records)
		:idAccentWordIndex[jj,0]: 0 != :idAccentWordIndex[jj,1]: 0 != && if	
			jjj 1 + idAccentIndexNew -reallocate;									# Reallocates a new record of memory keeping the contents
			:idAccentIndexNew[jjj,0]=idAccentIndex[jj,0];
			:idAccentIndexNew[jjj,1]=idAccentIndex[jj,1];

			jjj 1 + idAccentWordIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
			:idAccentWordIndexNew[jjj,0]=idAccentWordIndex[jj,0];
			:idAccentWordIndexNew[jjj,1]=idAccentWordIndex[jj,1];

			jjj 1 + idAccentTimeArrayNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idAccentTimeArrayNew[jjj,0]=idAccentTimeArray[jj,0];

			jjj 1 + idWordLengthArrayNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idWordLengthArrayNew[jjj,0]=idWordLengthArray[jj,0];

			jjj 1 + idAaNew -reallocate;											# Reallocates a new record of memory keeping the contents				
			:idAaNew[jjj,0]=idAa[jj,0];
			
			jjj 1 + idBetaNew -reallocate;											# Reallocates a new record of memory keeping the contents				
			:idBetaNew[jjj,0]=idBeta[jj,0];			
			jjj ++=;
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L11;                                            						# Jump to label L11
	end                                                 							# End of conditional branch		

#02 break;

	## New number of accented words
	idAccentWordIndexNew.nrec nAccCount =;
	

	## Two accents are in the same word, therefore delete the second accent			# -------------------------------------
	nAccCount 1 > if																# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L12;                                             						# Define a jump label named L12
		jj idAccentWordIndexNew.nrec 1 - < if                                   	# If loop counter < (number of records)
			:idAccentWordIndexNew[jj,0]: :idAccentWordIndexNew[jj+1,0]: == if		# If there are two accents in one word
				# There are two accents in the same word --> Delete the second accent
				:idAccentIndexNew[jj+1,0]=0;
				:idAccentIndexNew[jj+1,1]=0;

				:idAccentWordIndexNew[jj+1,0]=0;
				:idAccentWordIndexNew[jj+1,1]=0;
		
				:idAccentTimeArrayNew[jj,0]=idAccentTimeArrayNew[jj,0]+idAccentTimeArrayNew[jj+1,0];
				:idAccentTimeArrayNew[jj+1,0]=0;				
			
				:idWordLengthArrayNew[jj+1,0]=0;
				
				:idAaNew[jj+1,0]=0;
				
				:idBetaNew[jj+1,0]=0;								
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L12;                                            					# Jump to label L12
		end                                                 						# End of conditional branch	
	end

#03 break;  
        
	## Delete 0 value, if two accents are in the same word							# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L13;                                             							# Define a jump label named L13
	jj idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
		:idAccentWordIndexNew[jj,0]: 0 == :idAccentWordIndexNew[jj,1]: 0 == && if	# Accent index = 0
			idAccentIndexNew jj 1 idAccentIndexNew /rec -delete;

			idAccentWordIndexNew jj 1 idAccentWordIndexNew /rec -delete;				

			idAccentTimeArrayNew jj 1 idAccentTimeArrayNew /rec -delete;					

			idWordLengthArrayNew jj 1 idWordLengthArrayNew /rec -delete;
				
			idAaNew jj 1 idAaNew /rec -delete;
				
			idBetaNew jj 1 idBetaNew /rec -delete;								
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L13;                                            						# Jump to label L13
	end                                                 							# End of conditional branch

	## New number of accented words
	idAccentWordIndexNew.nrec nAccCount =;

#04 break;   		


	var nWordLengPercent;															# 60% of word duration
	0 nWordLengPercent =;

	## Delete an accent, if accent duration is smaller than 60% of word duration	# -------------------------------------
	## AND if duration of accented word is smaller than 180 msec					# -------------------------------------
	nAccCount 0 > if																# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L14;                                             						# Define a jump label named L14
		jj idAccentWordIndexNew.nrec < if                                   		# If loop counter < (number of records)
			:idWordLengthArrayNew[jj,0]: nPercentAccDurWord * nWordLengPercent =;	# 60% of word duration
			# accent duration is smaller than 60% of word duration AND duration of accented word is smaller than 180 msec
			:idAccentTimeArrayNew[jj,0]: nWordLengPercent <= :idWordLengthArrayNew[jj,0]: nAccentedWordDurBottom <= && if 

				:idAccentIndexNew[jj,0]=0;
				:idAccentIndexNew[jj,1]=0;

				:idAccentWordIndexNew[jj,0]=0;
				:idAccentWordIndexNew[jj,1]=0;
		
				:idAccentTimeArrayNew[jj,0]=0;				
			
				:idWordLengthArrayNew[jj,0]=0;
				
				:idAaNew[jj,0]=0;
				
				:idBetaNew[jj,0]=0;
			end
			jj ++=;                                              					# Increment loop counter jj
  			goto L14;                                            					# Jump to label L14
		end                                                 						# End of conditional branch	
	end


#05 break;  
  
	## Delete 0 value, if accent duration is smaller than 60% of word duration		# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L15;                                             							# Define a jump label named L15
	jj idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
		:idAccentWordIndexNew[jj,0]: 0 == :idAccentWordIndexNew[jj,1]: 0 == && if	# Accent index = 0
			idAccentIndexNew jj 1 idAccentIndexNew /rec -delete;

			idAccentWordIndexNew jj 1 idAccentWordIndexNew /rec -delete;				

			idAccentTimeArrayNew jj 1 idAccentTimeArrayNew /rec -delete;					

			idWordLengthArrayNew jj 1 idWordLengthArrayNew /rec -delete;
				
			idAaNew jj 1 idAaNew /rec -delete;
				
			idBetaNew jj 1 idBetaNew /rec -delete;								
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L15;                                            						# Jump to label L15
	end                                                 							# End of conditional branch



	## Adjustment the orthographic data object by adding new records				# -------------------------------------
	## In order to equal the length of idOrthographic and idLabWord					# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	data idOrthographicNew;
	idOrthographicNew -reset;
	"ORTHO" 25 idOrthographicNew -addcomp;	
	
	idOrthographic 0 idOrthographic.nrec 1 - idOrthographicNew -select;	

	idOrthographic.nrec jj =; 														# Init a loop counter jj
	label L16;                                             							# Define a jump label named L16
	jj idLabWord.nrec < if                                   						# If loop counter < (number of records)
		jj 1 + idOrthographicNew -reallocate;										# Reallocates a new record of memory keeping the contents
		:idOrthographicNew[jj,0]=sEmptyWord;
		jj ++=;                                              						# Increment loop counter jj
  		goto L16;                                            						# Jump to label L16
	end                                                 							# End of conditional branch

                
	## New number of accented words
	idAccentWordIndexNew.nrec nAccCount =;        
	
#06 break;
					
	## Search after the index of accented words in orthographic sentence			# -------------------------------------
	data idAccentOrthoIndex;
	idAccentOrthoIndex -reset;
	"AccInd" type long idAccentOrthoIndex -addcomp;	
	"AccTyp" type long idAccentOrthoIndex -addcomp;	
	
	var nAkzentWordIndex;
	var nAkzentTime;
	var nAkzentAmp;
	var nAkzentBeta;	
	
	0 nAkzentWordIndex =;
	0 nAkzentTime =;
	0 nAkzentAmp =;
	0 nAkzentBeta =;
	
	var sWordOrtho;																	# Word of orthographic data
	var sAccentedWordLabel;															# Word of Label data

	var ii;
	var iii;
	0 ii =;
	0 iii =;
	
	nAccCount 0 > if																# There are at least two accents
		0 i =; 																		# Init a loop counter i
		label L17;                                             						# Define a jump label named L17
		i idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
			:idAccentWordIndexNew[i,0]: nAkzentWordIndex =;		
			:idAccentTimeArrayNew[i,0]: nAkzentTime =;
			:idAaNew[i,0]: nAkzentAmp =;
			:idBetaNew[i,0]: nAkzentBeta =;

			nAkzentWordIndex ii =; 													# Init a loop counter ii
			label L19;                                             					# Define a jump label named L19
			ii 0 >= if                                   							# If loop counter >= 0

				:idLabWord[nAkzentWordIndex,0]: sAccentedWordLabel =;
				:idOrthographicNew[ii,0]: sWordOrtho =;				

					sAccentedWordLabel sWordOrtho == if								# Words are equal
						# Only one level of accent (#) (Major and Minor accent TOGETHER)
						nAccLevel 1 == if
							iii 1 + idAccentOrthoIndex -reallocate;					# Reallocates a new record of memory keeping the contents
							:idAccentOrthoIndex[iii,0]=ii;
							:idAccentOrthoIndex[iii,1]=2;
							iii ++=;
							goto L20;                                            	# Jump to label L20 (Exit from loop)
						# Two levels of accent (<aa> for Major and <a> for Minor accent)
						else
						nAccLevel 2 == if
							# Major Accent (Accent time >= Threshold || Aa >= Threshold && Beta >= Threshold)
							nAkzentTime nAccDurMajorThresh >= nAkzentAmp nAccAmpMajorThresh >= nAkzentBeta nAccBetaMajorThresh >= || && if
								iii 1 + idAccentOrthoIndex -reallocate;				# Reallocates a new record of memory keeping the contents
								:idAccentOrthoIndex[iii,0]=ii;
								:idAccentOrthoIndex[iii,1]=1;						# 1 for Major Accent
								iii ++=;
								goto L20;                                           # Jump to label L20 (Exit from loop)
							else				
								# Minor Accent (Accent time < Threshold || Aa < Threshold && Beta < Threshold)
								iii 1 + idAccentOrthoIndex -reallocate;				# Reallocates a new record of memory keeping the contents
								:idAccentOrthoIndex[iii,0]=ii;
								:idAccentOrthoIndex[iii,1]=2;						# 2 for Minor Accent
								iii ++=;
								goto L20;                                           # Jump to label L20 (Exit from loop)
							end

						end
						end

					end

				ii --=;                                              				# Decrement loop counter ii
  				goto L19;                                            				# Jump to label L19
			end                                                 					# End of conditional branch	

			label L20;                                             					# Define a jump label named L20

			i ++=;                                              					# Increment loop counter i
  			goto L17;                                            					# Jump to label L17
		end                                                 						# End of conditional branch	
	end

#07 break;

	## Delete the same values of accent index and if the next index is smaller		# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L18;                                             							# Define a jump label named L18
	jj idAccentOrthoIndex.nrec 1 - < if                                   			# If loop counter < (number of records -1)
		:idAccentOrthoIndex[jj,0]: :idAccentOrthoIndex[jj+1,0]: >= if
			idAccentOrthoIndex jj 1 idAccentOrthoIndex /rec -delete;
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L18;                                            						# Jump to label L18
	end                                                 							# End of conditional branch

#08 break;

	## Final number of accented words
	var nAccCountFinal;
	idAccentOrthoIndex.nrec nAccCountFinal =;


	## Annotate accents to the sentence (orthographic words)						# -------------------------------------
	## Minor Accent (Neben) = <a>
	## Major Accent (Haupt) = <aa> 
	var k;

	0 i =;
	0 j =;	
	0 k =;	

    nAccCountFinal 0 != if															# There are accents
		label L21;                                             						# Define a jump label named L21
		i idOrthographic.nrec  < if                                   				# If loop counter < (number of records)
			:idOrthographic[i,0]: sWordOrtho =;										# Read the orthographic word
			## Accent-Index is smaller than Word-Index
			j idAccentOrthoIndex.nrec < if                                          # If loop counter < (number of records)
				## Accent
				:idAccentOrthoIndex[j,0]: i == if									# There is an Accent in this word
					## Minor Accent													#   - - - - - - - - - - - - - - - - - -
					:idAccentOrthoIndex[j,1]: 2 == if								# Minor Accent with index 2 <a>
						# Copy the Orthographic Word
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sWordOrtho;									# Copy the word  to the output data object
						k ++=;														# Increment the counter k for annotated words
						# Copy the Minor Accent
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sMinorAccent;									# Copy minor Accent <a> to the output data object
						k ++=;														# Increment the counter k for annotated words
					
						j ++=; 														# Increment the Accent Index j 
					## Major Accent													#   - - - - - - - - - - - - - - - - - -
					else
					:idAccentOrthoIndex[j,1]: 1 == if								# Major Accent with index 1 <aa>
						# Copy the Orthographic Word
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sWordOrtho;									# Copy the word to the output data object
						k ++=;														# Increment the counter k for annotated words
						# Copy the Major Accent
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sMajorAccent;									# Copy major Accent <aa> to the output data object
						k ++=;														# Increment the counter k for annotated words
					
						j ++=; 														# Increment the Accent Index j 			
					end
					end
				## No Accent in this word
				else
				:idAccentOrthoIndex[j,0]: i != if									# There is no Accent
					# Copy the Orthographic Word
					k 1 + idLab -reallocate;										# Reallocates a new record of memory keeping the contens
					:idLab[k,0] = sWordOrtho;										# Copy the word to the output data object
					k ++=;															# Increment the counter k for annotated words
				end
				end
			## Accent-Index is greater than Word-Index
			else
			j idAccentOrthoIndex.nrec >= if
				# Copy the Orthographic Word
				k 1 + idLab -reallocate;										  	# Reallocates a new record of memory keeping the contens
				:idLab[k,0] = sWordOrtho;											# Copy the word to the output data object
				k ++=; 																# Increment the counter k for annotated words
			end	
			end


			i ++=;                                              					# Increment loop counter i
  			goto L21;                                            					# Jump to label L21
		end                                                 						# End of conditional branch
	else
	nAccCountFinal 0 == if															# No accents in the sentence
		idOrthographic.nrec 1 == if													# Sentence consist of one word
			idOrthographic 0 1 idLab -select;										# Copy Orthographic word into output
		else																		# Sentence consist of more than one word
			idOrthographic 0 idOrthographic.nrec 1 - idLab -select;					# Copy Orthographic words into output
		end
	end
	end

			
#100 break;

}





## <p>Annotate phrases to the sentence (alignment of phrase command to a pause).</p>
## @param idPAC data
##          Data instance of Fujisaki parameters (PAC file) (input)
## @param idOrthographic data
##          Data instance of orthographic words without extra words (d or T) [Using (-Delete_Extra_Ortho_Word_LAB_WORD) if there is extra word] (input)
## @param idLabWord data
##          Data instance of word labels, extracted with (-LAB_WORD_extract_vm) (input)
## @param nSampRate
##			Sample rate
## @param nPhrLevel
##			Number of levels for phrase annotation
## @param idLab data
##          Data instance to be filled with prosodic (phrase) annotated words  (output)
function -Phrase_Annotation_Pause_Alignment(idPAC,idOrthographic,idLabWord,nSampRate,nPhrLevel,idLab)
{
	var nPhrAmpBottom;																# Overall minimal phrase amplitude
	var nPhrDurMajorThresh;															# Threshold of minimal duration of major phrase
	var nPhrAmpMajorThresh;															# Threshold of minimal amplitude of major phrase
	var nPhrAlphaMajorThresh;														# Threshold of minimal constant (alpha) of major phrase

	data idAux;																		# Auxiliary data instance
	data idLabWordEndTime;															# Data object of Word-Label with End-Time of words
	data idT0DiffArray;																# Difference between Onset time of phrase and End time of words
	data idPhraseIndex;																# Index of phrase command (index of word)

	data idAp;																		# Data object of Phrase Amplitude
	data idAlpha;																	# Data object of Alpha(Time constant for phrase control mechanism)
	data idT0Array;																	# Array for Onset time of phrase

  	var nRecPAC; 														  			# Get the number of records (number of records of PAC) 
  	var nRecOrtho; 														  			# Get the number of records (number of orthographic words)
  	var nRecLabWord; 																# Get the number of records (number of word labels with pauses)
	var nAux;
	
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase
    var nPhraseI;																	# Number of phrases 
    var nAccentJ;																	# Number of accents
	var Ap;																			# Amplitude of phrase command
	var Alpha;																		# Time constant for phrase control mechanism
	var T0;																			# Onset time of phrase command
	var nT0Diff;																	# Difference between Onset time of phrase and End time of word
	var nPhrasePosition;															# Index of word, whereas a phrase starts

	var i;
	var j;
	var jj;
	var r;
	
	0 i =;
	0 j =;
	0 jj =;
	0 r =;

  	## Initialize                                                                 	# -------------------------------------
	0.01 nPhrAmpBottom =;															# Delete an phrase, which has a small amplitude (Ap<=0.01)
	0.700 nPhrDurMajorThresh =;														# An Phrase, which has a larger duration as (700 msec), is Major Phrase
	0.5 nPhrAmpMajorThresh =;														# Phrase with greater amplitude as threshold is major phrase
	2 nPhrAlphaMajorThresh =;														# Phrase with greater constant as threshold id major phrase
	
  	idPAC.nrec  nRecPAC =;          												# Get the number of records
  	idOrthographic.nrec  nRecOrtho =;          										# Get the number of records
  	idLabWord.nrec  nRecLabWord =;          										# Get the number of records (label words with pauses)
	"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	"<ss>" sMajorPhrase =;															# Init a major phrase variable 


    :idPAC[1,0]: nPhraseI =;														# Read a number of phrases from PAC
    :idPAC[2,0]: nAccentJ =;														# Read a number of accents from PAC

  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLabWordEndTime -reset;
	idT0DiffArray -reset;
	idPhraseIndex -reset;
	
	idAp -reset;
	idAlpha -reset;
	idT0Array -reset;

	
  	## Define a data object structure                                              	# -------------------------------------	
	"WordPhr" 25 idLab -addcomp;													# Output data object

	"EndTime" type double idLabWordEndTime -addcomp;
	"PhrInd" type long idPhraseIndex -addcomp;
	
	"Ap" type double idAp -addcomp;
	"Alpha" type double idAlpha -addcomp;
	"T0" type double idT0Array -addcomp;
	

	## Calculate the End-Time of Word-Label and convert it from sample to second   	# -------------------------------------
	0 i =; 																			# Init a loop counter i	
	label L1;                                             							# Define a jump label named L1
	i nRecLabWord < if                                            	 				# If loop counter < (number of records)
		:idLabWord[i,1]: :idLabWord[i,2]: + nAux =; 								# End time = Start time + Length
		i 1 + idLabWordEndTime -reallocate;										    # Reallocates a new record of memory keeping the contents
		:idLabWordEndTime[i,0]=nAux;												# Assign end time
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	idLabWordEndTime nSampRate / idLabWordEndTime =;								# Convert End time from Sample to Second


	
	## Find the index of Phrase														# -------------------------------------
	nPhraseI 0 == if                                            	 				# If there is no phrases >>
		idOrthographic.nrec 1 == if													# Sentence consist of one word
			idOrthographic 0 1 idLab -select;										# Copy Orthographic word into output
			leave;																	# Exit from this function		
		else																		# Sentence consist of more than one word
			idOrthographic 0 idOrthographic.nrec 1 - idLab -select;					# Copy Orthographic words into output
			leave;																	# Exit from this function
		end
	else
	nPhraseI 0 > if																	# There is at least one phrase

		5 j =; 																		# Init a loop counter j	(The first five records: F0-Nr., Phrase Nr., Accent-Nr., Fb, F0-rate)
		label L2;                                             						# Define a jump label named L2
		j nPhraseI 5 + < if                                            	 			# If loop counter < (number of records)

			:idPAC[j,0]: T0 =;														# Onset time of phrase command
			T0 0 < if																# Onset time of phrase command is negative >>
				0 T0 =;																# Onset time = 0
			end																	# <<

			T0 :idLabWordEndTime[idLabWordEndTime.nrec-1,0]: > if					# Onset time of phrase is greater than end time of signal >>
				:idLabWordEndTime[idLabWordEndTime.nrec-1,0]: T0 =;					# Onset time = end time of signal
			end																	# <<

			:idPAC[j,2]: Ap =;														# Amplitude of phrase command
			:idPAC[j,3]: Alpha =;													# Time constant for phrase control mechanism

			Ap nPhrAmpBottom > if 													# Delete the phrases with a very small amplitude
				## Difference between Onset time of phrase and End-Time of word		#   - - - - - - - - - - - - - - - - - -
				idT0DiffArray -reset;												# Reset data object
				"DiffT0" type double idT0DiffArray -addcomp;						# Difference between Onset time of phrase and End-Time of word

				0 jj =; 															# Init a loop counter jj
				label L3;                                             				# Define a jump label named L3
				jj idLabWordEndTime.nrec < if                                       # If loop counter < (number of records)
					## Difference between Onset time of phrase and End-Time of word
					T0 :idLabWordEndTime[jj,0]: - nT0Diff =;						# Difference between Onset time of phrase and End-Time of word
					jj 1 + idT0DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idT0DiffArray[jj,0]=nT0Diff;									# Copy the value to data object
					jj ++=;                                              			# Increment loop counter jj
  					goto L3;                                            			# Jump to label L3
				end                                                 				# End of conditional branch

				## Find the index of word, whereas a phrase starts					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L4;                                             				# Define a jump label named L4
				jj idT0DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idT0DiffArray[jj,0]: 0 <= if									# Find the first negative value or zero
						jj nPhrasePosition =;										# Index of word

						goto L5; # Exit from loop                       			# Jump to label L5
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L4;                                            			# Jump to label L4
				end                                                 				# End of conditional branch

				label L5;                                             				# Define a jump label named L5

				#nPhrasePosition 0 != if												# Delete a phrase command, if it is in the first word (pause)
					r 1 + idPhraseIndex -reallocate;								# Reallocates a new record of memory keeping the contents
					r 1 + idT0Array -reallocate;									# Reallocates a new record of memory keeping the contents
					r 1 + idAp -reallocate;											# Reallocates a new record of memory keeping the contents
					r 1 + idAlpha -reallocate;										# Reallocates a new record of memory keeping the contents

					:idPhraseIndex[r,0]=nPhrasePosition;							# Start index of phrase
					:idT0Array[r,0]=T0;												# Onset time of phrase command
					:idAp[r,0]=Ap;													# Amplitude of phrase command
					:idAlpha[r,0]=Alpha;											# Time constant for phrase control mechanism

					r ++=;															# Increment loop counter r
				#end

			end                                      								# End of conditional branch
			j ++=;                                              					# Increment loop counter j
  			goto L2;                                            					# Jump to label L2
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch <<
	end                                                 							# End of conditional branch <<

	
#00 brk;

	## Find the index of Phrase, if it is located in a pause or near a pause		# -------------------------------------
	data idPhraseIndexNew;															# New index of phrase after alignment a phrase to the near pause
	idPhraseIndexNew -reset;
	"PhrInd" type long idPhraseIndexNew -addcomp;
	"PhrTyp" type long idPhraseIndexNew -addcomp;	
	
	var nPhrCount;
	var nPhraseWordIndex;															# Position of phrase as word index
	var nWordIndex1;																# Word, whereas a phrase starts
	var nWordIndex2;																# Word after a phrase command
	var nWordIndex3;																# Word before a phrase command
	var nPauseTime;																	# Length of pause

	var sPause;	        															# A word is a pause
	var sWord1;																		# Word, whereas a phrase starts
	var sWord2;																		# Word after a phrase command
	var sWord3;																		# Word before a phrase command

	0 nPhrCount =;
	0 nPhraseWordIndex =;
	0 nWordIndex1 =;
	0 nWordIndex2 =;
	0 nWordIndex3 =;
	0 nPauseTime =;
	
	"<p:>" sPause =;
		
	## Number of phrases
	idPhraseIndex.nrec nPhrCount =;

	var rr;
	var ii;
	0 rr =;
	0 ii =;
	

	nPhrCount 0 > if																# There are at least one phrase
		0 ii =; 																	# Init a loop counter ii
		label L6;                                             						# Define a jump label named L6
		ii idPhraseIndex.nrec < if                                   				# If loop counter < (number of records)
			:idPhraseIndex[ii,0]: nPhraseWordIndex =;								# Position of phrase (word index)

			# Phrase locate in the first pause										#   - - - - - - - - - - - - - - - - - -
			nPhraseWordIndex 0 == if
				rr 1 + idPhraseIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
				:idPhraseIndexNew[rr,0]=0;											# Phrase locates at the beginning of sentence
				:idLabWordEndTime[0,0]: nPauseTime =; 								# Pause duration
				nPauseTime nPhrDurMajorThresh > if									# Pause duration > Threshold
					:idPhraseIndexNew[rr,1]=1;										# 1 for major phrase
				else
				nPauseTime nPhrDurMajorThresh <= if									# Pause duration <= Threshold
					:idPhraseIndexNew[rr,1]=2;										# 2 for minor phrase	
				end
				end

				goto L7; # Exit from loop                       					# Jump to label L7

			# Phrase locate within sentence ( between the first pause and last word)#   - - - - - - - - - - - - - - - - - -
			else
			nPhraseWordIndex 0 > nPhraseWordIndex idLabWord.nrec 1 - < && if
				:idPhraseIndex[ii,0]: nWordIndex1 =;								# Index of word, whereas a phrase starts
				:idLabWord[nWordIndex1,0]: sWord1 =;
				nWordIndex1 1 + nWordIndex2 =;										# Word after a phrase command
				:idLabWord[nWordIndex2,0]: sWord2 =;
				nWordIndex1 1 - nWordIndex3 =;										# Word before a phrase command
				:idLabWord[nWordIndex3,0]: sWord3 =;

				sWord1 sPause == if													# Phrase command locates in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex1;
					:idLabWordEndTime[nWordIndex1,0]: :idLabWordEndTime[nWordIndex1-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase	
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord2 sPause == if													# Phrase command is in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex2;
					:idLabWordEndTime[nWordIndex2,0]: :idLabWordEndTime[nWordIndex2-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord3 sPause == if													# Phrase command is in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex3;
					:idLabWordEndTime[nWordIndex3,0]: :idLabWordEndTime[nWordIndex3-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase	
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord1 sPause != sWord2 sPause != sWord3 sPause != && && if			# There is no pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents		
					:idPhraseIndexNew[rr,0]=nWordIndex1;							# Phrase begins with the next word
					:idPhraseIndexNew[rr,1]=2;										# 2 for minor phrase
					goto L7; # Exit from loop                       				# Jump to label L7
				end
				end
				end
				end
			# Phrase is in the last word of sentence								#   - - - - - - - - - - - - - - - - - -
			else
			nPhraseWordIndex idLabWord.nrec 1 - == if
				rr 1 + idPhraseIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
				:idPhraseIndexNew[rr,0]=idLabWord.nrec-1;							# Phrase locates at the end of sentence
				:idPhraseIndexNew[rr,1]=2;											# 2 for minor phrase
				goto L7; # Exit from loop                       					# Jump to label L7

			end
			end
			end
			
			label L7;                                             					# Define a jump label named L7

			rr ++=;                                              					# Increment loop counter rr
			ii ++=;                                              					# Increment loop counter ii
  			goto L6;                                            					# Jump to label L6
		end                                                 						# End of conditional branch	
	end

#01 brk;	

	## Delete one of the same values of phrase-index and if a next index is smaller	# -------------------------------------				
	idPhraseIndexNew.nrec 1 > if													# There are at least two phrase
		0 jj =; 																	# Init a loop counter jj
		label L8;                                             						# Define a jump label named L8
		jj idPhraseIndexNew.nrec 1 - < if                                   		# If loop counter < (number of records -1)
			:idPhraseIndexNew[jj,0]: :idPhraseIndexNew[jj+1,0]: >= if
				idPhraseIndexNew jj 1 idPhraseIndexNew /rec -delete;
				
				idT0Array jj 1 idT0Array /rec -delete;
				
				idAp jj 1 idAp /rec -delete;
				
				idAlpha jj 1 idAlpha /rec -delete;
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L8;                                            					# Jump to label L8
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch

#02 brk;

	var nPhrStartSent;																# Variable shows if the sentence begins with a phrase
	0 nPhrStartSent =;																# No phrase in the beginning of sentence

	## Alignment of phrase after the previous word, if pharse locates in pause	 	# -------------------------------------	
	data idPhraseIndexNew1;
	idPhraseIndexNew1 -reset;
	"PhrInd" type long idPhraseIndexNew1 -addcomp;
	"PhrTyp" type long idPhraseIndexNew1 -addcomp;	
	
	var rrrr;
	var nPhraseLocation;															# Location of phrase
	var sWordPhrase;
	
	0 rrrr =;
	0 nPhraseLocation =;
	
	idPhraseIndexNew.nrec 0 > if													# There are at least one phrase
		0 i =; 																		# Init a loop counter i
		label L9;                                             						# Define a jump label named L9
		i idPhraseIndexNew.nrec < if                                   				# If loop counter < (number of records)
			:idPhraseIndexNew[i,0]: nPhraseLocation =;								# Location of phrase
			:idLabWord[nPhraseLocation,0]: sWordPhrase =;							# Read the word at location of phrase
			sWordPhrase sPause == if												# Phrase command is in a pause
				nPhraseLocation 0 == if												# Phrase is at the beginning of sentence
					1 nPhrStartSent =;												# There is a phrase at the beginning of sentence
				else																# Phrase is not at the beginning of sentence
					rrrr 1 + idPhraseIndexNew1 -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew1[rrrr,0]=nPhraseLocation-1;					# Put Phrase after the previous word
					:idPhraseIndexNew1[rrrr,1]=idPhraseIndexNew[i,1];
					rrrr ++=;                                              			# Increment loop counter rrrr
				end
			else																	# Phrase command is not in a pause
				rrrr 1 + idPhraseIndexNew1 -reallocate;								# Reallocates a new record of memory keeping the contents
				:idPhraseIndexNew1[rrrr,0]=idPhraseIndexNew[i,0];					# Phrase begins with the next word
				:idPhraseIndexNew1[rrrr,1]=idPhraseIndexNew[i,1];
				rrrr ++=;                                              				# Increment loop counter rrrr
			end

			i ++=;                                              					# Increment loop counter i
  			goto L9;                                            					# Jump to label L9
		end                                                 						# End of conditional branch
	end																			# End of conditional branch

#03 brk;

	## Adjustment the orthographic data object by adding new records				# -------------------------------------
	## In order to equal the length of idOrthographic and idLabWord					# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	data idOrthographicNew;
	idOrthographicNew -reset;
	"ORTHO" 25 idOrthographicNew -addcomp;	
	
	idOrthographic 0 idOrthographic.nrec 1 - idOrthographicNew -select;	

	idOrthographic.nrec jj =; 														# Init a loop counter jj
	label L10;                                             							# Define a jump label named L10
	jj idLabWord.nrec < if                                   						# If loop counter < (number of records)
		jj 1 + idOrthographicNew -reallocate;										# Reallocates a new record of memory keeping the contents
		:idOrthographicNew[jj,0]=sEmptyWord;
		jj ++=;                                              						# Increment loop counter jj
  		goto L10;                                            						# Jump to label L10
	end                                                 							# End of conditional branch

                
	## New number of phrases
	idPhraseIndexNew1.nrec nPhrCount =;
	
#04 brk;
					
	## Search after the index of phrase in orthographic sentence					# -------------------------------------
	data idPhraseOrthoIndex;
	idPhraseOrthoIndex -reset;
	"PhrInd" type long idPhraseOrthoIndex -addcomp;	
	"PhrTyp" type long idPhraseOrthoIndex -addcomp;	
	
	var nPhraseAmp;
	var nPhraseAlpha;
		
	0 nPhraseWordIndex =;
	0 nPhraseAmp =;
	0 nPhraseAlpha =;
	
	var sWordOrtho;																	# Word of orthographic data
	var sPhraseWordLabel;															# Word of Label data

	var iii;
	0 ii =;
	0 iii =;
	
	nPhrCount 0 > if																# There are at least one phrase
		0 i =; 																		# Init a loop counter i
		label L11;                                             						# Define a jump label named L11
		i idPhraseIndexNew1.nrec < if                                   			# If loop counter < (number of records)
			:idPhraseIndexNew1[i,0]: nPhraseWordIndex =;	
			:idAp[i,0]: nPhraseAmp =;
			:idAlpha[i,0]: nPhraseAlpha =;

			nPhraseWordIndex ii =; 													# Init a loop counter ii
			label L12;                                             					# Define a jump label named L12
			ii 0 >= if                                   							# If loop counter >= 0

				:idLabWord[nPhraseWordIndex,0]: sPhraseWordLabel =;
				:idOrthographicNew[ii,0]: sWordOrtho =;				

					sPhraseWordLabel sWordOrtho == if								# Words are equal
						# Only one level of phrase (<s>) (Major and Minor phrases TOGETHER)
						nPhrLevel 1 == if
							iii 1 + idPhraseOrthoIndex -reallocate;					# Reallocates a new record of memory keeping the contents
							:idPhraseOrthoIndex[iii,0]=ii;
							:idPhraseOrthoIndex[iii,1]=2;
							iii ++=;
							goto L13;                                            	# Jump to label L13 (Exit from loop)
						# Two levels of phrase (<ss> for Major and <s> for Minor phrase)
						else
						nPhrLevel 2 == if
							# Major phrase (pause time >= Threshold || Ap >= Threshold && Alpha >= Threshold)
							:idPhraseIndexNew1[i,1]: 1 == nPhraseAmp nPhrAmpMajorThresh >= nPhraseAlpha nPhrAlphaMajorThresh >= || && if
								iii 1 + idPhraseOrthoIndex -reallocate;				# Reallocates a new record of memory keeping the contents
								:idPhraseOrthoIndex[iii,0]=ii;
								:idPhraseOrthoIndex[iii,1]=1;						# 1 for Major phrase
								iii ++=;
								goto L13;                                           # Jump to label L13 (Exit from loop)
							else				
								# Minor phrase (pause time < Threshold || Ap < Threshold && Alpha < Threshold)
								iii 1 + idPhraseOrthoIndex -reallocate;				# Reallocates a new record of memory keeping the contents
								:idPhraseOrthoIndex[iii,0]=ii;
								:idPhraseOrthoIndex[iii,1]=2;						# 2 for Minor phrase
								iii ++=;
								goto L13;                                           # Jump to label L13 (Exit from loop)
							end

						end
						end

					end

				ii --=;                                              				# Decrement loop counter ii
  				goto L12;                                            				# Jump to label L12
			end                                                 					# End of conditional branch	

			label L13;                                             					# Define a jump label named L13

			i ++=;                                              					# Increment loop counter i
  			goto L11;                                            					# Jump to label L11
		end                                                 						# End of conditional branch	
	end

#05 brk;

	## Delete the same values of phrase index and if the next index is smaller		# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L14;                                             							# Define a jump label named L14
	jj idPhraseOrthoIndex.nrec 1 - < if                                   			# If loop counter < (number of records -1)
		:idPhraseOrthoIndex[jj,0]: :idPhraseOrthoIndex[jj+1,0]: >= if
			idPhraseOrthoIndex jj 1 idPhraseOrthoIndex /rec -delete;
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L14;                                            						# Jump to label L14
	end                                                 							# End of conditional branch

#06 brk;

	## Final number of phrases
	var nPhrCountFinal;
	idPhraseOrthoIndex.nrec nPhrCountFinal =;


	## Annotate phrases to the sentence (orthographic words)						# -------------------------------------
	## Minor phrase (Neben) = <s>
	## Major phrase (Haupt) = <ss> 
	var k;

	0 i =;
	0 j =;	
	0 k =;	


	# There is a phrase at the beginning of sentence 
	nPhrStartSent 1 == if
		# Copy the Minor phrase
		k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
		:idLab[k,0] = sMinorPhrase;									# Copy minor phrase (<s>) to the output data object
		k ++=;														# Increment the counter k for annotated words
	end

    nPhrCountFinal 0 != if															# There are phrases
		label L15;                                             						# Define a jump label named L15
		i idOrthographic.nrec  < if                                   				# If loop counter < (number of records)
			:idOrthographic[i,0]: sWordOrtho =;										# Read the orthographic word
			## Phrase-Index is smaller than Word-Index
			j idPhraseOrthoIndex.nrec < if                                          # If loop counter < (number of records)
				## Phrase
				:idPhraseOrthoIndex[j,0]: i == if									# There is an phrase in this word
					## Minor phrase													#   - - - - - - - - - - - - - - - - - -
					:idPhraseOrthoIndex[j,1]: 2 == if								# Minor phrase with index 2 (<s>)
						# Copy the Orthographic Word
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sWordOrtho;									# Copy the word  to the output data object
						k ++=;														# Increment the counter k for annotated words
						# Copy the Minor phrase
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sMinorPhrase;									# Copy minor phrase (<s>) to the output data object
						k ++=;														# Increment the counter k for annotated words

						j ++=; 														# Increment the phrase Index j 
					## Major phrase													#   - - - - - - - - - - - - - - - - - -
					else
					:idPhraseOrthoIndex[j,1]: 1 == if								# Major phrase with index 1 (<ss>)
						# Copy the Orthographic Word
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sWordOrtho;									# Copy the word to the output data object
						k ++=;														# Increment the counter k for annotated words
						# Copy the Major phrase
						k 1 + idLab -reallocate;									# Reallocates a new record of memory keeping the contens
						:idLab[k,0] = sMajorPhrase;									# Copy major phrase (<ss>) to the output data object
						k ++=;														# Increment the counter k for annotated words

						j ++=; 														# Increment the phrase Index j 			
					end
					end
				## No phrase in this word
				else
				:idPhraseOrthoIndex[j,0]: i != if									# There is no phrase
					# Copy the Orthographic Word
					k 1 + idLab -reallocate;										# Reallocates a new record of memory keeping the contens
					:idLab[k,0] = sWordOrtho;										# Copy the word to the output data object
					k ++=;															# Increment the counter k for annotated words
				end
				end
			## phrase-Index is greater than Word-Index
			else
			j idPhraseOrthoIndex.nrec >= if
				# Copy the Orthographic Word
				k 1 + idLab -reallocate;										  	# Reallocates a new record of memory keeping the contens
				:idLab[k,0] = sWordOrtho;											# Copy the word to the output data object
				k ++=; 																# Increment the counter k for annotated words
			end	
			end


			i ++=;                                              					# Increment loop counter i
  			goto L15;                                            					# Jump to label L15
		end                                                 						# End of conditional branch
	else
	nPhrCountFinal 0 == if															# No phrases in the sentence
		idOrthographic.nrec 1 == if													# Sentence consist of one word
			idOrthographic 0 1 idLab -select;										# Copy Orthographic word into output
		else																		# Sentence consist of more than one word
			idOrthographic 0 idOrthographic.nrec 1 - idLab -select;					# Copy Orthographic words into output
		end
		
	end
	end

			
#100 brk;

}










## <p>Calculate the Fujisaki parameter of phrase (onset time of phrase, phrase amplitude and time constant for phrase control mechanism).</p>
## @param idPAC data
##          Data instance of Fujisaki parameters (PAC file) (input)
## @param idOrthographic data
##          Data instance of orthographic words without extra words (d or T) [Using (-Delete_Extra_Ortho_Word_LAB_WORD) if there is extra word] (input)
## @param idLabWord data
##          Data instance of word labels, extracted with (-LAB_WORD_extract_vm) (input)
## @param nSampRate
##			Sample rate
## @param idLab data
##          Data instance to be filled with Fujisaki parameter of phrase (onset time of phrase, phrase amplitude and time constant for phrase control mechanism)  (output)
function -Fujisaki_Parameter_Phrase(idPAC,idOrthographic,idLabWord,nSampRate,idLab)
{
	var nPhrAmpBottom;																# Overall minimal phrase amplitude
	var nPhrDurMajorThresh;															# Threshold of minimal duration of major phrase
	var nPhrAmpMajorThresh;															# Threshold of minimal amplitude of major phrase
	var nPhrAlphaMajorThresh;														# Threshold of minimal constant (alpha) of major phrase

	data idAux;																		# Auxiliary data instance
	data idLabWordEndTime;															# Data object of Word-Label with End-Time of words
	data idT0DiffArray;																# Difference between Onset time of phrase and End time of words
	data idPhraseIndex;																# Index of phrase command (index of word)

	data idAp;																		# Data object of Phrase Amplitude
	data idAlpha;																	# Data object of Alpha(Time constant for phrase control mechanism)
	data idT0Array;																	# Array for Onset time of phrase

  	var nRecPAC; 														  			# Get the number of records (number of records of PAC) 
  	var nRecOrtho; 														  			# Get the number of records (number of orthographic words)
  	var nRecLabWord; 																# Get the number of records (number of word labels with pauses)
	var nAux;
	
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase
    var nPhraseI;																	# Number of phrases 
    var nAccentJ;																	# Number of accents
	var Ap;																			# Amplitude of phrase command
	var Alpha;																		# Time constant for phrase control mechanism
	var T0;																			# Onset time of phrase command
	var nT0Diff;																	# Difference between Onset time of phrase and End time of word
	var nPhrasePosition;															# Index of word, whereas a phrase starts

	var i;
	var j;
	var jj;
	var r;
	
	0 i =;
	0 j =;
	0 jj =;
	0 r =;

  	## Initialize                                                                 	# -------------------------------------
	0.01 nPhrAmpBottom =;															# Delete an phrase, which has a small amplitude (Ap<=0.01)
	0.700 nPhrDurMajorThresh =;														# An Phrase, which has a larger duration as (700 msec), is Major Phrase
	0.5 nPhrAmpMajorThresh =;														# Phrase with greater amplitude as threshold is major phrase
	2 nPhrAlphaMajorThresh =;														# Phrase with greater constant as threshold id major phrase
	
  	idPAC.nrec  nRecPAC =;          												# Get the number of records
  	idOrthographic.nrec  nRecOrtho =;          										# Get the number of records
  	idLabWord.nrec  nRecLabWord =;          										# Get the number of records (label words with pauses)
	"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	"<ss>" sMajorPhrase =;															# Init a major phrase variable 


    :idPAC[1,0]: nPhraseI =;														# Read a number of phrases from PAC
    :idPAC[2,0]: nAccentJ =;														# Read a number of accents from PAC

  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLabWordEndTime -reset;
	idT0DiffArray -reset;
	idPhraseIndex -reset;
	
	idAp -reset;
	idAlpha -reset;
	idT0Array -reset;

	
  	## Define a data object structure                                              	# -------------------------------------	
	"PhrBegT" type double idLab -addcomp;											# Output data object
	"Empty" type double idLab -addcomp;
	"Ap" type double idLab -addcomp;
	"Alpha" type double idLab -addcomp;

	"EndTime" type double idLabWordEndTime -addcomp;
	"PhrInd" type long idPhraseIndex -addcomp;
	
	"Ap" type double idAp -addcomp;
	"Alpha" type double idAlpha -addcomp;
	"T0" type double idT0Array -addcomp;
	

	## Calculate the End-Time of Word-Label and convert it from sample to second   	# -------------------------------------
	0 i =; 																			# Init a loop counter i	
	label L1;                                             							# Define a jump label named L1
	i nRecLabWord < if                                            	 				# If loop counter < (number of records)
		:idLabWord[i,1]: :idLabWord[i,2]: + nAux =; 								# End time = Start time + Length
		i 1 + idLabWordEndTime -reallocate;										    # Reallocates a new record of memory keeping the contents
		:idLabWordEndTime[i,0]=nAux;												# Assign end time
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	idLabWordEndTime nSampRate / idLabWordEndTime =;								# Convert End time from Sample to Second


	
	## Find the index of Phrase														# -------------------------------------
	nPhraseI 0 == if                                            	 				# If there is no phrases >>
		idOrthographic.nrec 1 == if													# Sentence consist of one word
			idOrthographic 0 1 idLab -select;										# Copy Orthographic word into output
			leave;																	# Exit from this function		
		else																		# Sentence consist of more than one word
			idOrthographic 0 idOrthographic.nrec 1 - idLab -select;					# Copy Orthographic words into output
			leave;																	# Exit from this function
		end
	else
	nPhraseI 0 > if																	# There is at least one phrase

		5 j =; 																		# Init a loop counter j	(The first five records: F0-Nr., Phrase Nr., Accent-Nr., Fb, F0-rate)
		label L2;                                             						# Define a jump label named L2
		j nPhraseI 5 + < if                                            	 			# If loop counter < (number of records)

			:idPAC[j,0]: T0 =;														# Onset time of phrase command
			#T0 0 < if																# Onset time of phrase command is negative >>
			#	0 T0 =;																# Onset time = 0
			#end																	# <<

			T0 :idLabWordEndTime[idLabWordEndTime.nrec-1,0]: > if					# Onset time of phrase is greater than end time of signal >>
				:idLabWordEndTime[idLabWordEndTime.nrec-1,0]: T0 =;					# Onset time = end time of signal
			end																	# <<

			:idPAC[j,2]: Ap =;														# Amplitude of phrase command
			:idPAC[j,3]: Alpha =;													# Time constant for phrase control mechanism

			Ap nPhrAmpBottom > if 													# Delete the phrases with a very small amplitude
				## Difference between Onset time of phrase and End-Time of word		#   - - - - - - - - - - - - - - - - - -
				idT0DiffArray -reset;												# Reset data object
				"DiffT0" type double idT0DiffArray -addcomp;						# Difference between Onset time of phrase and End-Time of word

				0 jj =; 															# Init a loop counter jj
				label L3;                                             				# Define a jump label named L3
				jj idLabWordEndTime.nrec < if                                       # If loop counter < (number of records)
					## Difference between Onset time of phrase and End-Time of word
					T0 :idLabWordEndTime[jj,0]: - nT0Diff =;						# Difference between Onset time of phrase and End-Time of word
					jj 1 + idT0DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idT0DiffArray[jj,0]=nT0Diff;									# Copy the value to data object
					jj ++=;                                              			# Increment loop counter jj
  					goto L3;                                            			# Jump to label L3
				end                                                 				# End of conditional branch

				## Find the index of word, whereas a phrase starts					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L4;                                             				# Define a jump label named L4
				jj idT0DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idT0DiffArray[jj,0]: 0 <= if									# Find the first negative value or zero
						jj nPhrasePosition =;										# Index of word
						goto L5; # Exit from loop                       			# Jump to label L5
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L4;                                            			# Jump to label L4
				end                                                 				# End of conditional branch

				label L5;                                             				# Define a jump label named L5

				#nPhrasePosition 0 != if												# Delete a phrase command, if it is in the first word (pause)
					r 1 + idPhraseIndex -reallocate;								# Reallocates a new record of memory keeping the contents
					r 1 + idT0Array -reallocate;									# Reallocates a new record of memory keeping the contents
					r 1 + idAp -reallocate;											# Reallocates a new record of memory keeping the contents
					r 1 + idAlpha -reallocate;										# Reallocates a new record of memory keeping the contents

					:idPhraseIndex[r,0]=nPhrasePosition;							# Start index of phrase
					:idT0Array[r,0]=T0;												# Onset time of phrase command
					:idAp[r,0]=Ap;													# Amplitude of phrase command
					:idAlpha[r,0]=Alpha;											# Time constant for phrase control mechanism

					r ++=;															# Increment loop counter r
				#end

			end                                      								# End of conditional branch
			j ++=;                                              					# Increment loop counter j
  			goto L2;                                            					# Jump to label L2
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch <<
	end                                                 							# End of conditional branch <<

	
#00 break;

	## Find the index of Phrase, if it is located in a pause or near a pause		# -------------------------------------
	data idPhraseIndexNew;															# New index of phrase after alignment a phrase to the near pause
	idPhraseIndexNew -reset;
	"PhrInd" type long idPhraseIndexNew -addcomp;
	"PhrTyp" type long idPhraseIndexNew -addcomp;	
	
	var nPhrCount;
	var nPhraseWordIndex;															# Position of phrase as word index
	var nWordIndex1;																# Word, whereas a phrase starts
	var nWordIndex2;																# Word after a phrase command
	var nWordIndex3;																# Word before a phrase command
	var nPauseTime;																	# Length of pause

	var sPause;	        															# A word is a pause
	var sWord1;																		# Word, whereas a phrase starts
	var sWord2;																		# Word after a phrase command
	var sWord3;																		# Word before a phrase command

	0 nPhrCount =;
	0 nPhraseWordIndex =;
	0 nWordIndex1 =;
	0 nWordIndex2 =;
	0 nWordIndex3 =;
	0 nPauseTime =;
	
	"<p:>" sPause =;
		
	## Number of phrases
	idPhraseIndex.nrec nPhrCount =;

	var rr;
	var ii;
	0 rr =;
	0 ii =;
	

	nPhrCount 0 > if																# There are at least one phrase
		0 ii =; 																	# Init a loop counter ii
		label L6;                                             						# Define a jump label named L6
		ii idPhraseIndex.nrec < if                                   				# If loop counter < (number of records)
			:idPhraseIndex[ii,0]: nPhraseWordIndex =;								# Position of phrase (word index)

			# Phrase locate at the first word of sentence							#   - - - - - - - - - - - - - - - - - -
			nPhraseWordIndex 0 == if
				rr 1 + idPhraseIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
				:idPhraseIndexNew[rr,0]=0;											# Phrase locates at the beginn of sentence
				:idPhraseIndexNew[rr,1]=2;											# 2 for minor phrase
				goto L7; # Exit from loop                       					# Jump to label L7			
			
			else
			# Phrase don't locate in the last word of sentence (within sentence)	#   - - - - - - - - - - - - - - - - - -
			nPhraseWordIndex 0 > nPhraseWordIndex idLabWord.nrec 1 - < && if
				:idPhraseIndex[ii,0]: nWordIndex1 =;								# Index of word, whereas a phrase starts
				:idLabWord[nWordIndex1,0]: sWord1 =;
				nWordIndex1 1 + nWordIndex2 =;										# Word after a phrase command
				:idLabWord[nWordIndex2,0]: sWord2 =;
				nWordIndex1 1 - nWordIndex3 =;										# Word before a phrase command
				:idLabWord[nWordIndex3,0]: sWord3 =;
				
				sWord1 sPause == if													# Phrase command locates in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex1;
					:idLabWordEndTime[nWordIndex1,0]: :idLabWordEndTime[nWordIndex1-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase	
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord2 sPause == if													# Phrase command is in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex2;
					:idLabWordEndTime[nWordIndex2,0]: :idLabWordEndTime[nWordIndex2-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord3 sPause == if													# Phrase command is in a pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents
					:idPhraseIndexNew[rr,0]=nWordIndex3;
					:idLabWordEndTime[nWordIndex3,0]: :idLabWordEndTime[nWordIndex3-1,0]: - nPauseTime =; # Pause duration
					nPauseTime nPhrDurMajorThresh > if								# Pause duration > Threshold
						:idPhraseIndexNew[rr,1]=1;									# 1 for major phrase
					else
					nPauseTime nPhrDurMajorThresh <= if								# Pause duration <= Threshold
						:idPhraseIndexNew[rr,1]=2;									# 2 for minor phrase	
					end
					end
					goto L7; # Exit from loop                       				# Jump to label L7
				else
				sWord1 sPause != sWord2 sPause != sWord3 sPause != && && if			# There is no pause
					rr 1 + idPhraseIndexNew -reallocate;							# Reallocates a new record of memory keeping the contents		
					:idPhraseIndexNew[rr,0]=nWordIndex1;							# Phrase begins with the next word
					:idPhraseIndexNew[rr,1]=2;										# 2 for minor phrase
					goto L7; # Exit from loop                       				# Jump to label L7
				end
				end
				end
				end
			# Phrase is in the last word of sentence								#   - - - - - - - - - - - - - - - - - -
			else
			nPhraseWordIndex idLabWord.nrec 1 - == if
				rr 1 + idPhraseIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
				:idPhraseIndexNew[rr,0]=idLabWord.nrec-1;							# Phrase locates at the end of sentence
				:idPhraseIndexNew[rr,1]=2;											# 2 for minor phrase
				goto L7; # Exit from loop                       					# Jump to label L7			
			end
			end
			end
			
			label L7;                                             					# Define a jump label named L7

			rr ++=;                                              					# Increment loop counter rr
			ii ++=;                                              					# Increment loop counter ii
  			goto L6;                                            					# Jump to label L6
		end                                                 						# End of conditional branch	
	end

#01 break;	

	## Delete one of the same values of phrase-index and if a next index is smaller	# -------------------------------------				
	idPhraseIndexNew.nrec 1 > if													# There are at least two phrase
		0 jj =; 																	# Init a loop counter jj
		label L8;                                             						# Define a jump label named L8
		jj idPhraseIndexNew.nrec 1 - < if                                   		# If loop counter < (number of records -1)
			:idPhraseIndexNew[jj,0]: :idPhraseIndexNew[jj+1,0]: >= if
				idPhraseIndexNew jj 1 idPhraseIndexNew /rec -delete;
				
				idT0Array jj 1 idT0Array /rec -delete;
				
				idAp jj 1 idAp /rec -delete;
				
				idAlpha jj 1 idAlpha /rec -delete;
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L8;                                            					# Jump to label L8
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch

#02 break;


	## Save Fujisaki parameter of phrase command (Phrase time, Ap, alpha)			# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L16;                                             							# Define a jump label named L16
	jj idPhraseIndexNew.nrec < if                                   				# If loop counter < (number of records)
		jj 1 + idLab -reallocate;													# Reallocates a new record of memory keeping the contents

		:idLab[jj,0]=idT0Array[jj,0];
		:idLab[jj,1]=0.000;		
		:idLab[jj,2]=idAp[jj,0];
		:idLab[jj,3]=idAlpha[jj,0];				
		jj ++=;                                              						# Increment loop counter jj
  		goto L16;                                            						# Jump to label L16
	else
	idPhraseIndexNew.nrec 0 == if                                   				# No phrase commands	
		idLab -reset;
	end
	end                                                 							# End of conditional branch
	
#100 break;

}





## <p>Convert an automatic prosodic annotated sentence to a BAS Partitur Format.</p>
## @param idProsAnnoSent data
##          Data instance of an automatic prosodic annotated sentence  (input)
## @param idLab data
##          Data instance of a BAS Partitur Format  (output)
function -Convert_AccAnnoSent2Partitur(idProsAnnoSent,idLab)
{
	var sTierDefinit;	        													# Definition of tier (Spur)
	var i;																			# Loop counter

  	## Initialize                                                                 	# -------------------------------------
	"ACC:" sTierDefinit =;															# Definition of tier (Spur)
	0 i =;
	
  	## Reset data                                                                 	# -------------------------------------
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Tier" 5 idLab -addcomp;														# Output data object (Tier (Spur))
	"WordNum" type long idLab -addcomp;												# Output data object (number of word (begin with 0))
	"Word" 50 idLab -addcomp;														# Output data object (word)
	idProsAnnoSent.dim idLab -allocate;												# Allocates (n) records

  	## Copy the informations to the output data object                              # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i idProsAnnoSent.dim < if                                   					# If loop counter < (number of records)
		:idLab[i,0] = sTierDefinit;													# Copy the tier (Spur)
		:idLab[i,1] = i;															# copy the number of word
		:idLab[i,2] = idProsAnnoSent[0,i];											# Copy the word

		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

#100 break;

}




## <p>Convert an automatic prosodic annotated sentence to a BAS Partitur Format.</p>
## @param idProsAnnoSent data
##          Data instance of an automatic prosodic annotated sentence  (input)
## @param idLab data
##          Data instance of a BAS Partitur Format  (output)
function -Convert_PhrAnnoSent2Partitur(idProsAnnoSent,idLab)
{
	var sTierDefinit;	        													# Definition of tier (Spur)
	var i;																			# Loop counter

  	## Initialize                                                                 	# -------------------------------------
	"PHR:" sTierDefinit =;															# Definition of tier (Spur)
	0 i =;
	
  	## Reset data                                                                 	# -------------------------------------
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Tier" 5 idLab -addcomp;														# Output data object (Tier (Spur))
	"WordNum" type long idLab -addcomp;												# Output data object (number of word (begin with 0))
	"Word" 50 idLab -addcomp;														# Output data object (word)
	idProsAnnoSent.dim idLab -allocate;												# Allocates (n) records

  	## Copy the informations to the output data object                              # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i idProsAnnoSent.dim < if                                   					# If loop counter < (number of records)
		:idLab[i,0] = sTierDefinit;													# Copy the tier (Spur)
		:idLab[i,1] = i;															# copy the number of word
		:idLab[i,2] = idProsAnnoSent[0,i];											# Copy the word

		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

#100 break;

}






## <p>Evaluation of major and minor accents.</p>
## @param idProsoTest data
##          Data instance of automatic prosodic annotated sentence (Test) (input)
## @param idProsoRef data
##          Data instance of manual prosodic annotated sentence (Reference) (input)
## @param idLab data
##          Data instance for the result of evaluation  (output)
function -Accent_Evaluation_Major_Minor(idProsoTest,idProsoRef,idLab)
{
	data idAux;																		# Auxiliary data instance

	var sMinorAccent;																# Minor Accent
	var sMajorAccent;																# Major Accent
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase

	var sPause;	        															# A word is a pause
	var sAuxWord;

	var nMajorRef;																	# Number of major annotation symbols in reference file
	var nMajorTest;																	# Number of major annotation symbols in test file
	var nMajorCorr;																	# Number of major corrected symbols
	var nMajorDel;																	# Number of major deleted symbols
	var nMajorIns;																	# Number of major inserted symbols
	var nMajorSub;																	# Number of major substituted symbols (Substitution = Ersatz)

	var nMinorRef;																	# Number of minor annotation symbols in reference file
	var nMinorTest;																	# Number of minor annotation symbols in test file
	var nMinorCorr;																	# Number of minor corrected symbols
	var nMinorDel;																	# Number of minor deleted symbols
	var nMinorIns;																	# Number of minor inserted symbols
	var nMinorSub;																	# Number of minor substituted symbols (Substitution = Ersatz)

	var nNumWordsSentTest;															# Number of words in Test sentence
	var nNumWordsSentRef;															# Number of words in Reference sentence

	var i;
	var j;


  	## Initialize                                                                 	# -------------------------------------
	"<a>" sMinorAccent =;															# Init a minor Accent variable
	"<aa>" sMajorAccent =;															# Init a major Accent variable
	#"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	#"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;

	0 nMajorRef =;																	# Number of major annotation symbols in reference file
	0 nMajorTest =;																	# Number of major annotation symbols in test file
	0 nMajorCorr =;																	# Number of major corrected symbols
	0 nMajorDel =;																	# Number of major deleted symbols
	0 nMajorIns =;																	# Number of major inserted symbols
	0 nMajorSub =;																	# Number of major substituted symbols
	
	0 nMinorRef =;																	# Number of minor annotation symbols in reference file
	0 nMinorTest =;																	# Number of minor annotation symbols in test file
	0 nMinorCorr =;																	# Number of minor corrected symbols
	0 nMinorDel =;																	# Number of minor deleted symbols
	0 nMinorIns =;																	# Number of minor inserted symbols
	0 nMinorSub =;																	# Number of minor substituted symbols

	idProsoTest.dim nNumWordsSentTest =;											# Number of words in Test sentence
	idProsoRef.dim nNumWordsSentRef =;												# Number of words in Reference sentence
	
  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Report" 50 idLab -addcomp;														# Output data object
	"FeaNum" type long idLab -addcomp;												# Output data object
	12 idLab -allocate;																# Allocates (n) records

	## Init a data object structure                                              	# -------------------------------------	
	"Number of major symbols in reference file:" sAuxWord =;
	:idLab[0,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[0,1] = 0;																# Init a number with 0

	"Number of minor symbols in reference file:" sAuxWord =;
	:idLab[1,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[1,1] = 0;																# Init a number with 0
	
	"Number of major symbols in test file:" sAuxWord =;
	:idLab[2,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[2,1] = 0;																# Init a number with 0

	"Number of minor symbols in test file:" sAuxWord =;
	:idLab[3,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[3,1] = 0;																# Init a number with 0

	"Correct major symbols:" sAuxWord =;
	:idLab[4,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[4,1] = 0;																# Init a number with 0

	"Correct minor symbols:" sAuxWord =;
	:idLab[5,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[5,1] = 0;																# Init a number with 0

	"Substitution major symbols:" sAuxWord =;
	:idLab[6,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[6,1] = 0;																# Init a number with 0

	"Substitution minor symbols:" sAuxWord =;
	:idLab[7,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[7,1] = 0;																# Init a number with 0

	"Deleted major symbols:" sAuxWord =;
	:idLab[8,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[8,1] = 0;																# Init a number with 0

	"Deleted minor symbols:" sAuxWord =;
	:idLab[9,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[9,1] = 0;																# Init a number with 0

	"Inserted major symbols:" sAuxWord =;
	:idLab[10,0] = sAuxWord;														# Copy the word  to the output data object
	:idLab[10,1] = 0;																# Init a number with 0

	"Inserted minor symbols:" sAuxWord =;
	:idLab[11,0] = sAuxWord;														# Copy the word  to the output data object
	:idLab[11,1] = 0;																# Init a number with 0


  	## Calculate the number of prosodic symbols in Test file                        # -------------------------------------	
	## Minor symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMinorAccent == if										# A word is a minor symbol >>
			nMinorTest ++=;															# Increment the number of minor symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	## Major symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L2;                                             							# Define a jump label named L2
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMajorAccent == if										# A word is a major symbol >>
			nMajorTest ++=;															# Increment the number of major symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L2;                                            						# Jump to label L2
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Reference file                   # -------------------------------------
	## Minor symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L3;                                             							# Define a jump label named L3
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMinorAccent == if										# A word is a minor symbol >>
			nMinorRef ++=;															# Increment the number of minor symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L3;                                            						# Jump to label L3
	end                                                 							# End of conditional branch

	## Major symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L4;                                             							# Define a jump label named L4
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMajorAccent == if										# A word is a major symbol >>
			nMajorRef ++=;															# Increment the number of major symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L4;                                            						# Jump to label L4
	end                                                 							# End of conditional branch

#00 break;

  	## Add one word to the end of both sentences (to stay in sentence domain) 		# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	25 1 idAux -addncomps;															# Add component of type (char) to data object
	1 idAux -allocate;																# Allocates (n) records of memory
	:idAux[0,0] = sEmptyWord;

	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoTest -join; 														# Append component to idProsoTest
	idAux idProsoTest -join; 														# Append component to idProsoTest

#01 break;

	nNumWordsSentTest ++=;
	nNumWordsSentRef ++=;	


	################################
	##### Example(ROVER Fis97) #####
	################################
	#####  a   b   c   d   -   ##### Reference sentence
	#####  -   b   z   d   e   ##### Test sentence
	#####  C1  C2  C3  C4  C5  ##### The Number of Character
	################################
	##### Correct: 		C2, C4 #####
	##### Substitution: C3	   #####
	##### Deletion:		C1     #####
	##### Insertion:	C5     #####
	################################

  	## Evaluation of Minor symbols (Correct, Substitution, Deletion)                # -------------------------------------
	var sWordRef;																	# A word in a reference file
	var sWordPreviousRef;															# Previous word to the minor symbol in Reference sentence
	var sWordNextRef;																# Next word to the minor symbol in Reference sentence
	var sWordTest;																	# A word in a test file	
	var sWordPreviousTest;															# Previous word to the minor symbol in Test sentence
	var sWordNextTest;																# Next word to the minor symbol in Test sentence

	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L5;                                             							# Define a jump label named L5
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMinorAccent == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L6;                                             					# Define a jump label named L6
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMinorAccent == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorCorr ++=;													# Increment the Correct
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				sWordTest sMajorAccent == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorSub ++=;													# Increment the Substitution
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMinorDel ++=;													# Increment the Deletion
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				end
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L6;                                            				# Jump to label L6
			end                                                 					# End of conditional branch
		end																		# <<
		label L7;                                             						# Define a jump label named L7
		i ++=;                                              						# Increment loop counter i
  		goto L5;                                            						# Jump to label L5
	end                                                 							# End of conditional branch


  	## Evaluation of Minor symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L8;                                             							# Define a jump label named L8
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMinorAccent == if												# The word in Test sentence is a minor symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L9;                                             					# Define a jump label named L9
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMinorIns ++=;													# Increment the Insertion
					goto L10;                                            			# Jump to label L10 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L9;                                            				# Jump to label L9
			end                                                 					# End of conditional branch
		end																		# <<
		label L10;                                             						# Define a jump label named L10
		i ++=;                                              						# Increment loop counter i
  		goto L8;                                            						# Jump to label L8
	end                                                 							# End of conditional branch



  	## Evaluation of Major symbols (Correct, Substitution, Deletion)                # -------------------------------------
	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L11;                                             							# Define a jump label named L11
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMajorAccent == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L12;                                             					# Define a jump label named L12
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMajorAccent == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMajorCorr ++=;													# Increment the Correct
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				else
				sWordTest sMinorAccent == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMajorSub ++=;													# Increment the Substitution
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMajorDel ++=;													# Increment the Deletion
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				end
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L12;                                            				# Jump to label L12
			end                                                 					# End of conditional branch
		end																		# <<
		label L13;                                             						# Define a jump label named L13
		i ++=;                                              						# Increment loop counter i
  		goto L11;                                            						# Jump to label L11
	end                                                 							# End of conditional branch


  	## Evaluation of Major symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L14;                                             							# Define a jump label named L14
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMajorAccent == if												# The word in Test sentence is a major symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L15;                                             					# Define a jump label named L15
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMajorIns ++=;													# Increment the Insertion
					goto L16;                                            			# Jump to label L16 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L15;                                            				# Jump to label L15
			end                                                 					# End of conditional branch
		end																		# <<
		label L16;                                             						# Define a jump label named L16
		i ++=;                                              						# Increment loop counter i
  		goto L14;                                            						# Jump to label L14
	end                                                 							# End of conditional branch


	## Test if the values are correct                  								# -------------------------------------	
	nMajorCorr nMajorDel + nMajorSub + i =;
	i nMajorRef != if
		4646 break;
	end
	
	nMinorCorr nMinorDel + nMinorSub + i =;
	i nMinorRef != if
		4747 break;
	end	


	nMajorCorr nMajorIns + nMinorSub + i =;
	i nMajorTest != if
		4848 break;
	end
	
	nMinorCorr nMinorIns + nMajorSub + i =;
	i nMinorTest != if
		4949 break;
	end	


	## Save the values in output data object                  						# -------------------------------------
	:idLab[0,1] = nMajorRef;
	:idLab[1,1] = nMinorRef;
	:idLab[2,1] = nMajorTest;
	:idLab[3,1] = nMinorTest;
	:idLab[4,1] = nMajorCorr;
	:idLab[5,1] = nMinorCorr;
	:idLab[6,1] = nMajorSub;
	:idLab[7,1] = nMinorSub;
	:idLab[8,1] = nMajorDel;
	:idLab[9,1] = nMinorDel;
	:idLab[10,1] = nMajorIns;
	:idLab[11,1] = nMinorIns;
		
			
#100 break;

}






## <p>Evaluation of minor accents.</p>
## @param idProsoTest data
##          Data instance of automatic prosodic annotated sentence (Test) (input)
## @param idProsoRef data
##          Data instance of manual prosodic annotated sentence (Reference) (input)
## @param idLab data
##          Data instance for the result of evaluation  (output)
function -Accent_Evaluation_Minor(idProsoTest,idProsoRef,idLab)
{
	data idAux;																		# Auxiliary data instance

	var sMinorAccent;																# Minor Accent
	var sMajorAccent;																# Major Accent
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase

	var sPause;	        															# A word is a pause
	var sAuxWord;

	var nMinorRef;																	# Number of minor annotation symbols in reference file
	var nMinorTest;																	# Number of minor annotation symbols in test file
	var nMinorCorr;																	# Number of minor corrected symbols
	var nMinorDel;																	# Number of minor deleted symbols
	var nMinorIns;																	# Number of minor inserted symbols

	var nNumWordsSentTest;															# Number of words in Test sentence
	var nNumWordsSentRef;															# Number of words in Reference sentence

	var i;
	var j;


  	## Initialize                                                                 	# -------------------------------------
	"<a>" sMinorAccent =;															# Init a minor Accent variable
	"<aa>" sMajorAccent =;															# Init a major Accent variable
	#"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	#"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;
	
	0 nMinorRef =;																	# Number of minor annotation symbols in reference file
	0 nMinorTest =;																	# Number of minor annotation symbols in test file
	0 nMinorCorr =;																	# Number of minor corrected symbols
	0 nMinorDel =;																	# Number of minor deleted symbols
	0 nMinorIns =;																	# Number of minor inserted symbols

	idProsoTest.dim nNumWordsSentTest =;											# Number of words in Test sentence
	idProsoRef.dim nNumWordsSentRef =;												# Number of words in Reference sentence
	
  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Report" 50 idLab -addcomp;														# Output data object
	"FeaNum" type long idLab -addcomp;												# Output data object
	5 idLab -allocate;																# Allocates (n) records

	## Init a data object structure                                              	# -------------------------------------	
	"Number of minor symbols in reference file:" sAuxWord =;
	:idLab[0,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[0,1] = 0;																# Init a number with 0
	
	"Number of minor symbols in test file:" sAuxWord =;
	:idLab[1,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[1,1] = 0;																# Init a number with 0

	"Correct minor symbols:" sAuxWord =;
	:idLab[2,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[2,1] = 0;																# Init a number with 0

	"Deleted minor symbols:" sAuxWord =;
	:idLab[3,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[3,1] = 0;																# Init a number with 0

	"Inserted minor symbols:" sAuxWord =;
	:idLab[4,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[4,1] = 0;																# Init a number with 0


  	## Convert the major symbols to minor symbols in Test file                      # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L111;                                             						# Define a jump label named L111
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMajorAccent == if										# A word is a major symbol >>
			:idProsoTest[0,i] = sMinorAccent;										# Convert major symbol to minor symbol
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L111;                                            						# Jump to label L111
	end                                                 							# End of conditional branch


  	## Convert the major symbols to minor symbols in Reference file                 # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L222;                                             						# Define a jump label named L222
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMajorAccent == if										# A word is a major symbol >>
			:idProsoRef[0,i] = sMinorAccent;										# Convert major symbol to minor symbol
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L222;                                            						# Jump to label L222
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Test file                        # -------------------------------------	
	## Minor symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMinorAccent == if										# A word is a minor symbol >>
			nMinorTest ++=;															# Increment the number of minor symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Reference file                   # -------------------------------------
	## Minor symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L3;                                             							# Define a jump label named L3
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMinorAccent == if										# A word is a minor symbol >>
			nMinorRef ++=;															# Increment the number of minor symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L3;                                            						# Jump to label L3
	end                                                 							# End of conditional branch


#00 break;

  	## Add one word to the end of both sentences (to stay in sentence domain) 		# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	25 1 idAux -addncomps;															# Add component of type (char) to data object
	1 idAux -allocate;																# Allocates (n) records of memory
	:idAux[0,0] = sEmptyWord;

	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoTest -join; 														# Append component to idProsoTest
	idAux idProsoTest -join; 														# Append component to idProsoTest

#01 break;

	nNumWordsSentTest ++=;
	nNumWordsSentRef ++=;	


	################################
	##### Example(ROVER Fis97) #####
	################################
	#####  a   b   c   d   -   ##### Reference sentence
	#####  -   b   z   d   e   ##### Test sentence
	#####  C1  C2  C3  C4  C5  ##### The Number of Character
	################################
	##### Correct: 		C2, C4 #####
	##### Substitution: C3	   #####
	##### Deletion:		C1     #####
	##### Insertion:	C5     #####
	################################

  	## Evaluation of Minor symbols (Correct, Deletion)                				# -------------------------------------
	var sWordRef;																	# A word in a reference file
	var sWordPreviousRef;															# Previous word to the minor symbol in Reference sentence
	var sWordNextRef;																# Next word to the minor symbol in Reference sentence
	var sWordTest;																	# A word in a test file	
	var sWordPreviousTest;															# Previous word to the minor symbol in Test sentence
	var sWordNextTest;																# Next word to the minor symbol in Test sentence

	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L5;                                             							# Define a jump label named L5
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMinorAccent == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L6;                                             					# Define a jump label named L6
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMinorAccent == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorCorr ++=;													# Increment the Correct
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMinorDel ++=;													# Increment the Deletion
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L6;                                            				# Jump to label L6
			end                                                 					# End of conditional branch
		end																		# <<
		label L7;                                             						# Define a jump label named L7
		i ++=;                                              						# Increment loop counter i
  		goto L5;                                            						# Jump to label L5
	end                                                 							# End of conditional branch


  	## Evaluation of Minor symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L8;                                             							# Define a jump label named L8
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMinorAccent == if												# The word in Test sentence is a minor symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L9;                                             					# Define a jump label named L9
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMinorIns ++=;													# Increment the Insertion
					goto L10;                                            			# Jump to label L10 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L9;                                            				# Jump to label L9
			end                                                 					# End of conditional branch
		end																		# <<
		label L10;                                             						# Define a jump label named L10
		i ++=;                                              						# Increment loop counter i
  		goto L8;                                            						# Jump to label L8
	end                                                 							# End of conditional branch


	## Test if the values are correct                  								# -------------------------------------	
	nMinorCorr nMinorDel + i =;
	i nMinorRef != if
		4747 break;
	end	


	nMinorCorr nMinorIns + i =;
	i nMinorTest != if
		4949 break;
	end	



	## Save the values in output data object                  						# -------------------------------------
	:idLab[0,1] = nMinorRef;
	:idLab[1,1] = nMinorTest;
	:idLab[2,1] = nMinorCorr;
	:idLab[3,1] = nMinorDel;
	:idLab[4,1] = nMinorIns;
	
	
#100 break;

}





## <p>Evaluation of major and minor phrases.</p>
## @param idProsoTest data
##          Data instance of automatic prosodic annotated sentence (Test) (input)
## @param idProsoRef data
##          Data instance of manual prosodic annotated sentence (Reference) (input)
## @param idLab data
##          Data instance for the result of evaluation  (output)
function -Phrase_Evaluation_Major_Minor(idProsoTest,idProsoRef,idLab)
{
	data idAux;																		# Auxiliary data instance

	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase

	var sPause;	        															# A word is a pause
	var sAuxWord;

	var nMajorRef;																	# Number of major annotation symbols in reference file
	var nMajorTest;																	# Number of major annotation symbols in test file
	var nMajorCorr;																	# Number of major corrected symbols
	var nMajorDel;																	# Number of major deleted symbols
	var nMajorIns;																	# Number of major inserted symbols
	var nMajorSub;																	# Number of major substituted symbols (Substitution = Ersatz)

	var nMinorRef;																	# Number of minor annotation symbols in reference file
	var nMinorTest;																	# Number of minor annotation symbols in test file
	var nMinorCorr;																	# Number of minor corrected symbols
	var nMinorDel;																	# Number of minor deleted symbols
	var nMinorIns;																	# Number of minor inserted symbols
	var nMinorSub;																	# Number of minor substituted symbols (Substitution = Ersatz)

	var nNumWordsSentTest;															# Number of words in Test sentence
	var nNumWordsSentRef;															# Number of words in Reference sentence

	var i;
	var j;


  	## Initialize                                                                 	# -------------------------------------
	"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;

	0 nMajorRef =;																	# Number of major annotation symbols in reference file
	0 nMajorTest =;																	# Number of major annotation symbols in test file
	0 nMajorCorr =;																	# Number of major corrected symbols
	0 nMajorDel =;																	# Number of major deleted symbols
	0 nMajorIns =;																	# Number of major inserted symbols
	0 nMajorSub =;																	# Number of major substituted symbols
	
	0 nMinorRef =;																	# Number of minor annotation symbols in reference file
	0 nMinorTest =;																	# Number of minor annotation symbols in test file
	0 nMinorCorr =;																	# Number of minor corrected symbols
	0 nMinorDel =;																	# Number of minor deleted symbols
	0 nMinorIns =;																	# Number of minor inserted symbols
	0 nMinorSub =;																	# Number of minor substituted symbols

	idProsoTest.dim nNumWordsSentTest =;											# Number of words in Test sentence
	idProsoRef.dim nNumWordsSentRef =;												# Number of words in Reference sentence
	
  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Report" 50 idLab -addcomp;														# Output data object
	"FeaNum" type long idLab -addcomp;												# Output data object
	12 idLab -allocate;																# Allocates (n) records

	## Init a data object structure                                              	# -------------------------------------	
	"Number of major symbols in reference file:" sAuxWord =;
	:idLab[0,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[0,1] = 0;																# Init a number with 0

	"Number of minor symbols in reference file:" sAuxWord =;
	:idLab[1,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[1,1] = 0;																# Init a number with 0
	
	"Number of major symbols in test file:" sAuxWord =;
	:idLab[2,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[2,1] = 0;																# Init a number with 0

	"Number of minor symbols in test file:" sAuxWord =;
	:idLab[3,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[3,1] = 0;																# Init a number with 0

	"Correct major symbols:" sAuxWord =;
	:idLab[4,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[4,1] = 0;																# Init a number with 0

	"Correct minor symbols:" sAuxWord =;
	:idLab[5,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[5,1] = 0;																# Init a number with 0

	"Substitution major symbols:" sAuxWord =;
	:idLab[6,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[6,1] = 0;																# Init a number with 0

	"Substitution minor symbols:" sAuxWord =;
	:idLab[7,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[7,1] = 0;																# Init a number with 0

	"Deleted major symbols:" sAuxWord =;
	:idLab[8,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[8,1] = 0;																# Init a number with 0

	"Deleted minor symbols:" sAuxWord =;
	:idLab[9,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[9,1] = 0;																# Init a number with 0

	"Inserted major symbols:" sAuxWord =;
	:idLab[10,0] = sAuxWord;														# Copy the word  to the output data object
	:idLab[10,1] = 0;																# Init a number with 0

	"Inserted minor symbols:" sAuxWord =;
	:idLab[11,0] = sAuxWord;														# Copy the word  to the output data object
	:idLab[11,1] = 0;																# Init a number with 0


  	## Calculate the number of prosodic symbols in Test file                        # -------------------------------------	
	## Minor symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMinorPhrase == if										# A word is a minor symbol >>
			nMinorTest ++=;															# Increment the number of minor symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	## Major symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L2;                                             							# Define a jump label named L2
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMajorPhrase == if										# A word is a major symbol >>
			nMajorTest ++=;															# Increment the number of major symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L2;                                            						# Jump to label L2
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Reference file                   # -------------------------------------
	## Minor symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L3;                                             							# Define a jump label named L3
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMinorPhrase == if										# A word is a minor symbol >>
			nMinorRef ++=;															# Increment the number of minor symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L3;                                            						# Jump to label L3
	end                                                 							# End of conditional branch

	## Major symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L4;                                             							# Define a jump label named L4
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMajorPhrase == if										# A word is a major symbol >>
			nMajorRef ++=;															# Increment the number of major symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L4;                                            						# Jump to label L4
	end                                                 							# End of conditional branch

#00 brk;

  	## Add words to the end of both sentences (to stay in sentence domain) 		# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	25 1 idAux -addncomps;															# Add component of type (char) to data object
	1 idAux -allocate;																# Allocates (n) records of memory
	:idAux[0,0] = sEmptyWord;

	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoTest -join; 														# Append component to idProsoTest
	idAux idProsoTest -join; 														# Append component to idProsoTest

#01 brk;

	nNumWordsSentTest ++=;															# Increase the number of words only one to stay in sentence domain
	nNumWordsSentRef ++=;															# Increase the number of words only one to stay in sentence domain


	################################
	##### Example(ROVER Fis97) #####
	################################
	#####  a   b   c   d   -   ##### Reference sentence
	#####  -   b   z   d   e   ##### Test sentence
	#####  C1  C2  C3  C4  C5  ##### The Number of Character
	################################
	##### Correct: 		C2, C4 #####
	##### Substitution: C3	   #####
	##### Deletion:		C1     #####
	##### Insertion:	C5     #####
	################################

  	## Evaluation of Minor symbols (Correct, Substitution, Deletion)                # -------------------------------------
	var sWordRef;																	# A word in a reference file
	var sWordPreviousRef;															# Previous word to the minor symbol in Reference sentence
	var sWordNextRef;																# Next word to the minor symbol in Reference sentence
	var sWordTest;																	# A word in a test file	
	var sWordPreviousTest;															# Previous word to the minor symbol in Test sentence
	var sWordNextTest;																# Next word to the minor symbol in Test sentence

	# Check the phrase at the beginning of sentence									#   - - - - - - - - - - - - - - - - - -
	:idProsoRef[0,0]: sWordRef =;													# Read one word in the Reference sentence
	:idProsoTest[0,0]: sWordTest =;													# Read one word in the Test sentence
	
	sWordRef sMinorPhrase == sWordTest sMinorPhrase == && if						# The first word in Reference sentence and Test sentence is a minor symbol >> 
		nMinorCorr ++=;																# Increment the Correct
	else
	sWordRef sMinorPhrase == sWordTest sMinorPhrase != && if						# The first word in Reference sentence is a minor symbol but the first word in Test sentence is NOT a minor symbol >> 
		nMinorDel ++=;																# Increment the Deletion
	else
	sWordRef sMinorPhrase != sWordTest sMinorPhrase == && if						# The first word in Reference sentence is not a phrase and in Test sentence is a minor symbol >>
 		nMinorIns ++=;																# Increment the Insertion
	end
	end
	end

	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L5;                                             							# Define a jump label named L5
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMinorPhrase == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L6;                                             					# Define a jump label named L6
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMinorPhrase == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorCorr ++=;													# Increment the Correct
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				sWordTest sMajorPhrase == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorSub ++=;													# Increment the Substitution
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMinorDel ++=;													# Increment the Deletion
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				end
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L6;                                            				# Jump to label L6
			end                                                 					# End of conditional branch
		end																		# <<
		label L7;                                             						# Define a jump label named L7
		i ++=;                                              						# Increment loop counter i
  		goto L5;                                            						# Jump to label L5
	end                                                 							# End of conditional branch


  	## Evaluation of Minor symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L8;                                             							# Define a jump label named L8
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMinorPhrase == if												# The word in Test sentence is a minor symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L9;                                             					# Define a jump label named L9
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMinorIns ++=;													# Increment the Insertion
					goto L10;                                            			# Jump to label L10 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L9;                                            				# Jump to label L9
			end                                                 					# End of conditional branch
		end																		# <<
		label L10;                                             						# Define a jump label named L10
		i ++=;                                              						# Increment loop counter i
  		goto L8;                                            						# Jump to label L8
	end                                                 							# End of conditional branch



  	## Evaluation of Major symbols (Correct, Substitution, Deletion)                # -------------------------------------
	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L11;                                             							# Define a jump label named L11
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMajorPhrase == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L12;                                             					# Define a jump label named L12
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMajorPhrase == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMajorCorr ++=;													# Increment the Correct
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				else
				sWordTest sMinorPhrase == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMajorSub ++=;													# Increment the Substitution
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMajorDel ++=;													# Increment the Deletion
					goto L13;                                            			# Jump to label L13 (Exit from loop)
				end
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L12;                                            				# Jump to label L12
			end                                                 					# End of conditional branch
		end																		# <<
		label L13;                                             						# Define a jump label named L13
		i ++=;                                              						# Increment loop counter i
  		goto L11;                                            						# Jump to label L11
	end                                                 							# End of conditional branch


  	## Evaluation of Major symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L14;                                             							# Define a jump label named L14
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMajorPhrase == if												# The word in Test sentence is a major symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L15;                                             					# Define a jump label named L15
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMajorIns ++=;													# Increment the Insertion
					goto L16;                                            			# Jump to label L16 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L15;                                            				# Jump to label L15
			end                                                 					# End of conditional branch
		end																		# <<
		label L16;                                             						# Define a jump label named L16
		i ++=;                                              						# Increment loop counter i
  		goto L14;                                            						# Jump to label L14
	end                                                 							# End of conditional branch


	## Test if the values are correct                  								# -------------------------------------	
	nMajorCorr nMajorDel + nMajorSub + i =;
	i nMajorRef != if
		4646 brk;
	end
	
	nMinorCorr nMinorDel + nMinorSub + i =;
	i nMinorRef != if
		4747 brk;
	end	


	nMajorCorr nMajorIns + nMinorSub + i =;
	i nMajorTest != if
		4848 brk;
	end
	
	nMinorCorr nMinorIns + nMajorSub + i =;
	i nMinorTest != if
		4949 brk;
	end	


	## Save the values in output data object                  						# -------------------------------------
	:idLab[0,1] = nMajorRef;
	:idLab[1,1] = nMinorRef;
	:idLab[2,1] = nMajorTest;
	:idLab[3,1] = nMinorTest;
	:idLab[4,1] = nMajorCorr;
	:idLab[5,1] = nMinorCorr;
	:idLab[6,1] = nMajorSub;
	:idLab[7,1] = nMinorSub;
	:idLab[8,1] = nMajorDel;
	:idLab[9,1] = nMinorDel;
	:idLab[10,1] = nMajorIns;
	:idLab[11,1] = nMinorIns;
	
	
#100 brk;

}






## <p>Evaluation of minor phrases.</p>
## @param idProsoTest data
##          Data instance of automatic prosodic annotated sentence (Test) (input)
## @param idProsoRef data
##          Data instance of manual prosodic annotated sentence (Reference) (input)
## @param idLab data
##          Data instance for the result of evaluation  (output)
function -Phrase_Evaluation_Minor(idProsoTest,idProsoRef,idLab)
{
	data idAux;																		# Auxiliary data instance

	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase

	var sPause;	        															# A word is a pause
	var sAuxWord;

	var nMinorRef;																	# Number of minor annotation symbols in reference file
	var nMinorTest;																	# Number of minor annotation symbols in test file
	var nMinorCorr;																	# Number of minor corrected symbols
	var nMinorDel;																	# Number of minor deleted symbols
	var nMinorIns;																	# Number of minor inserted symbols

	var nNumWordsSentTest;															# Number of words in Test sentence
	var nNumWordsSentRef;															# Number of words in Reference sentence

	var i;
	var j;


  	## Initialize                                                                 	# -------------------------------------
	"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;
	
	0 nMinorRef =;																	# Number of minor annotation symbols in reference file
	0 nMinorTest =;																	# Number of minor annotation symbols in test file
	0 nMinorCorr =;																	# Number of minor corrected symbols
	0 nMinorDel =;																	# Number of minor deleted symbols
	0 nMinorIns =;																	# Number of minor inserted symbols

	idProsoTest.dim nNumWordsSentTest =;											# Number of words in Test sentence
	idProsoRef.dim nNumWordsSentRef =;												# Number of words in Reference sentence
	
  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLab -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"Report" 50 idLab -addcomp;														# Output data object
	"FeaNum" type long idLab -addcomp;												# Output data object
	5 idLab -allocate;																# Allocates (n) records

	## Init a data object structure                                              	# -------------------------------------	
	"Number of minor symbols in reference file:" sAuxWord =;
	:idLab[0,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[0,1] = 0;																# Init a number with 0
	
	"Number of minor symbols in test file:" sAuxWord =;
	:idLab[1,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[1,1] = 0;																# Init a number with 0

	"Correct minor symbols:" sAuxWord =;
	:idLab[2,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[2,1] = 0;																# Init a number with 0

	"Deleted minor symbols:" sAuxWord =;
	:idLab[3,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[3,1] = 0;																# Init a number with 0

	"Inserted minor symbols:" sAuxWord =;
	:idLab[4,0] = sAuxWord;															# Copy the word  to the output data object
	:idLab[4,1] = 0;																# Init a number with 0


  	## Convert the major symbols to minor symbols in Test file                      # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L111;                                             						# Define a jump label named L111
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMajorPhrase == if										# A word is a major symbol >>
			:idProsoTest[0,i] = sMinorPhrase;										# Convert major symbol to minor symbol
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L111;                                            						# Jump to label L111
	end                                                 							# End of conditional branch


  	## Convert the major symbols to minor symbols in Reference file                 # -------------------------------------	
	0 i =; 																			# Init a loop counter i
	label L222;                                             						# Define a jump label named L222
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMajorPhrase == if										# A word is a major symbol >>
			:idProsoRef[0,i] = sMinorPhrase;										# Convert major symbol to minor symbol
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L222;                                            						# Jump to label L222
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Test file                        # -------------------------------------	
	## Minor symbol in Test file													#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L1;                                             							# Define a jump label named L1
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sMinorPhrase == if										# A word is a minor symbol >>
			nMinorTest ++=;															# Increment the number of minor symbols in Test file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch


  	## Calculate the number of prosodic symbols in Reference file                   # -------------------------------------
	## Minor symbol in Reference file												#   - - - - - - - - - - - - - - - - - -
	0 i =; 																			# Init a loop counter i
	label L3;                                             							# Define a jump label named L3
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sMinorPhrase == if										# A word is a minor symbol >>
			nMinorRef ++=;															# Increment the number of minor symbols in Reference file
		end																		# <<
		i ++=;                                              						# Increment loop counter i
  		goto L3;                                            						# Jump to label L3
	end                                                 							# End of conditional branch


#00 brk;

  	## Add words to the end of both sentences (to stay in sentence domain) 		# -------------------------------------
	var sEmptyWord;
	"EmptyWord" sEmptyWord =;
	
	25 1 idAux -addncomps;															# Add component of type (char) to data object
	1 idAux -allocate;																# Allocates (n) records of memory
	:idAux[0,0] = sEmptyWord;

	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoRef -join; 														# Append component to idProsoRef
	idAux idProsoTest -join; 														# Append component to idProsoTest
	idAux idProsoTest -join; 														# Append component to idProsoTest

#01 brk;

	nNumWordsSentTest ++=;															# Increase the number of words only one to stay in sentence domain
	nNumWordsSentRef ++=;															# Increase the number of words only one to stay in sentence domain


	################################
	##### Example(ROVER Fis97) #####
	################################
	#####  a   b   c   d   -   ##### Reference sentence
	#####  -   b   z   d   e   ##### Test sentence
	#####  C1  C2  C3  C4  C5  ##### The Number of Character
	################################
	##### Correct: 		C2, C4 #####
	##### Substitution: C3	   #####
	##### Deletion:		C1     #####
	##### Insertion:	C5     #####
	################################

  	## Evaluation of Minor symbols (Correct, Deletion)                				# -------------------------------------
	var sWordRef;																	# A word in a reference file
	var sWordPreviousRef;															# Previous word to the minor symbol in Reference sentence
	var sWordNextRef;																# Next word to the minor symbol in Reference sentence
	var sWordTest;																	# A word in a test file	
	var sWordPreviousTest;															# Previous word to the minor symbol in Test sentence
	var sWordNextTest;																# Next word to the minor symbol in Test sentence

	# Check the phrase at the beginning of sentence									#   - - - - - - - - - - - - - - - - - -
	:idProsoRef[0,0]: sWordRef =;													# Read one word in the Reference sentence
	:idProsoTest[0,0]: sWordTest =;													# Read one word in the Test sentence
	
	sWordRef sMinorPhrase == sWordTest sMinorPhrase == && if						# The first word in Reference sentence and Test sentence is a minor symbol >> 
		nMinorCorr ++=;																# Increment the Correct
	else
	sWordRef sMinorPhrase == sWordTest sMinorPhrase != && if						# The first word in Reference sentence is a minor symbol but the first word in Test sentence is NOT a minor symbol >> 
		nMinorDel ++=;																# Increment the Deletion
	else
	sWordRef sMinorPhrase != sWordTest sMinorPhrase == && if						# The first word in Reference sentence is not a phrase and in Test sentence is a minor symbol >>
 		nMinorIns ++=;																# Increment the Insertion
	end
	end
	end

	# Loop for every word in the reference file										#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L5;                                             							# Define a jump label named L5
	i nNumWordsSentRef < if                                   						# If loop counter < (number of records)
		:idProsoRef[0,i]: sWordRef =;												# Read one word in the Reference sentence
		:idProsoRef[0,i-1]: sWordPreviousRef =;										# Previous word in Reference sentence
		:idProsoRef[0,i+1]: sWordNextRef =;											# Next word in Reference sentence

		sWordRef sMinorPhrase == if													# The word in Reference sentence is a minor symbol >> 
			# Loop for every word in the test file									#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L6;                                             					# Define a jump label named L6
			j nNumWordsSentTest < if                                   				# If loop counter < (number of records)
				:idProsoTest[0,j]: sWordTest =;										# Read one word in the Test sentence
				:idProsoTest[0,j-1]: sWordPreviousTest =;							# Previous word in Test sentence
				:idProsoTest[0,j+1]: sWordNextTest =;								# Next word in Test sentence

				sWordTest sMinorPhrase == sWordPreviousRef sWordPreviousTest == sWordNextRef sWordNextTest == && && if
					nMinorCorr ++=;													# Increment the Correct
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				else
				#sWordPreviousRef sWordTest == sWordNextRef sWordNextTest == && if
				sWordPreviousRef sWordPreviousTest == sWordNextRef sWordTest == && if
					nMinorDel ++=;													# Increment the Deletion
					goto L7;                                            			# Jump to label L7 (Exit from loop)
				end
				end

				j ++=;                                              				# Increment loop counter j
  				goto L6;                                            				# Jump to label L6
			end                                                 					# End of conditional branch
		end																		# <<
		label L7;                                             						# Define a jump label named L7
		i ++=;                                              						# Increment loop counter i
  		goto L5;                                            						# Jump to label L5
	end                                                 							# End of conditional branch


  	## Evaluation of Minor symbols (Insertion)                						# -------------------------------------
	# Loop for every word in the test file											#   - - - - - - - - - - - - - - - - - -
	1 i =; 																			# Init a loop counter i
	label L8;                                             							# Define a jump label named L8
	i nNumWordsSentTest < if                                   						# If loop counter < (number of records)
		:idProsoTest[0,i]: sWordTest =;												# Read one word in the Test sentence
		:idProsoTest[0,i-1]: sWordPreviousTest =;									# Previous word in Test sentence
		:idProsoTest[0,i+1]: sWordNextTest =;										# Next word in Test sentence

		sWordTest sMinorPhrase == if												# The word in Test sentence is a minor symbol >>
			# Loop for every word in the reference file								#   - - - - - - - - - - - - - - - - - -
			1 j =; 																	# Init a loop counter j
			label L9;                                             					# Define a jump label named L9
			j nNumWordsSentRef < if                                   				# If loop counter < (number of records)
				:idProsoRef[0,j]: sWordRef =;										# Read one word in the Reference sentence
				:idProsoRef[0,j-1]: sWordPreviousRef =;								# Previous word in Reference sentence
				:idProsoRef[0,j+1]: sWordNextRef =;									# Next word in Reference sentence
				#sWordPreviousTest sWordRef == sWordNextTest sWordNextRef == && if
				sWordPreviousTest sWordPreviousRef == sWordNextTest sWordRef == && if
					nMinorIns ++=;													# Increment the Insertion
					goto L10;                                            			# Jump to label L10 (Exit from loop)
				end

				j ++=;                                              				# Increment loop counter j
  				goto L9;                                            				# Jump to label L9
			end                                                 					# End of conditional branch
		end																		# <<
		label L10;                                             						# Define a jump label named L10
		i ++=;                                              						# Increment loop counter i
  		goto L8;                                            						# Jump to label L8
	end                                                 							# End of conditional branch

	## Test if the values are correct                  								# -------------------------------------	
	nMinorCorr nMinorDel + i =;
	i nMinorRef != if
		4747 brk;
	end	


	nMinorCorr nMinorIns + i =;
	i nMinorTest != if
		4949 brk;
	end	



	## Save the values in output data object                  						# -------------------------------------
	:idLab[0,1] = nMinorRef;
	:idLab[1,1] = nMinorTest;
	:idLab[2,1] = nMinorCorr;
	:idLab[3,1] = nMinorDel;
	:idLab[4,1] = nMinorIns;
	
	
#100 brk;

}




## <p>Calculate the Fujisaki parameter of accented word (onset and offset time of accent, accent amplitude (Aa) and time constant of accent control mechanism (beta) for accented words).</p>
## @param idPAC data
##          Data instance of Fujisaki parameters (PAC file) (input)
## @param idOrthographic data
##          Data instance of orthographic words without extra words (d or T) [Using (-Delete_Extra_Ortho_Word_LAB_WORD) if there is extra word] (input)
## @param idLabWord data
##          Data instance of word labels, extracted with (-LAB_WORD_extract_vm) (input)
## @param nSampRate
##			Sample rate
## @param idLab data
##          Data instance to be filled with Fujisaki parameter of accented word (onset and offset time of accent, accent amplitude (Aa) and time constant of accent control mechanism (beta) for accented words) (output)
function -Fujisaki_Parameter_Accented_Word(idPAC,idOrthographic,idLabWord,nSampRate,idLab)
{
	var nAccAmpMajorThresh;															# Threshold of minimal amplitude of major accent
	var nAccBetaMajorThresh;														# Threshold of Beta of major accent
	var nAccAmpBottom;																# Overall minimal accent amplitude
	var nAccDurBottom;																# Overall minimal Duration of Accent
	var nAccDurTop;																	# Overall maximal Duration of Accent
	var nAccDurMajorThresh;															# Threshold of minimal duration of major accent
	var nPercentAccDurWord;															# Minimal Duration of Accent in Word (in percent)
	var nAccentedWordDurBottom;														# Minimal Duration of accented word

	data idAux;																		# Auxiliary data instance
	data idLabWordEndTime;															# Data object of Word-Label with End-Time of words
	data idTa1DiffArray;															# Difference between Onset time of accent and End time of words
	data idTa2DiffArray;															# Difference between Offset time of accent and End time of words
	data idAccentIndex;																# Index of accent command (Start word and End word)
	data idAa;																		# Data object of Accent Amplitude
	data idBeta;																	# Data object of Beta (Time constant for accent control mechanism)
	data idTa1Array;																# Array for Onset time of accent
	data idTa2Array;																# Array for Offset time of accent
	data idTa1AccentedWord;															# Array of Onset time of accented word(one or multi accented words)
	data idTa2AccentedWord;															# Array of Offset time of accented word(one or multi accented words)
	data idAccentWordIndex;															# Index of accented word in sentence
	data idAccentTimeArray;															# Length of accent in accented word
	data idWordLengthArray;															# Length of accented word
	data idWordAccentTime;															# Time of word in an accent command

  	var nRecPAC; 														  			# Get the number of records (number of records of PAC) 
  	var nRecOrtho; 														  			# Get the number of records (number of orthographic words)
  	var nRecLabWord; 																# Get the number of records (number of word labels with pauses)
	var nAux;
	var nAuxMax;
	
	var sMinorAccent;																# Minor Accent
	var sMajorAccent;																# Major Accent
	var sMinorPhrase;																# Minor phrase
	var sMajorPhrase;																# Major phrase
    var nPhraseI;																	# Number of phrases 
    var nAccentJ;																	# Number of accents
	var Ta1;																		# Onset time of accent command
	var Ta2;																		# Offset time of accent command     
	var Aa;																			# Amplitude of accent command
	var Beta;																		# Time constant for accent control mechanism
	var nAccDur;																	# Duration of accent command
	var nTa1Diff;																	# Difference between Onset time of accent and End time of word
	var nTa2Diff;																	# Difference between Offset time of accent and End time of words
	var nAccStartIndex;																# Index of word, whereas an accent starts
	var nAccEndIndex;  																# Index of word, whereas an accent ended
	var sPause;	        															# A word is a pause
	var sWord;																		# Ortho. word
	var nWordLeng;																	# Length of word
	var nWordTime;																	# Word time in accent command
	var nWordTimeAbs;																# Absolute value of word time
	var nAccMultiIndex;																# Index of word in an accent command
	var nAccSeveralWordsIndex;														# Index of accented word in the sentence

	var i;
	var j;
	var jj;
	var jjj;
	var g;
	var f;

  	## Initialize                                                                 	# -------------------------------------
	0.8 nAccAmpMajorThresh =;															# Major Accent (Aa > 0.8)
	15 nAccBetaMajorThresh =;														# Major Accent (Beta > 15)
	0.01 nAccAmpBottom =;															# Delete an accent, which has a small amplitude (Aa<=0.01)
	0.08 nAccDurBottom =;															# Delete an accent, which has a small duration (Ta_2-Ta_1<0.08 sec)
	1.5 nAccDurTop =;																# Delete an accent, which has a large duration (Ta_2-Ta_1>=1.5 sec)
	0.400 nAccDurMajorThresh =;														# An Accent, which has a larger duration as (400 msec), is Major Accent
	0.60 nPercentAccDurWord =;														# A Duration of accent must be larger than (60%) of word duration
	0.200 nAccentedWordDurBottom =;													# Minimal Duration of accented word (200 msec)

  	idPAC.nrec  nRecPAC =;          												# Get the number of records
  	idOrthographic.nrec  nRecOrtho =;          										# Get the number of records
  	idLabWord.nrec  nRecLabWord =;          										# Get the number of records
	"<a>" sMinorAccent =;															# Init a minor Accent variable
	"<aa>" sMajorAccent =;															# Init a major Accent variable
	#"<s>" sMinorPhrase =;															# Init a minor phrase variable 
	#"<ss>" sMajorPhrase =;															# Init a major phrase variable 

	"<p:>" sPause =;

    :idPAC[1,0]: nPhraseI =;														# Read a number of phrases from PAC
    :idPAC[2,0]: nAccentJ =;														# Read a number of accents from PAC
	0 g =;

  	## Reset data                                                                 	# -------------------------------------
	idAux -reset;
	idLabWordEndTime -reset;
	idTa1DiffArray -reset;
	idTa2DiffArray -reset;
	idAccentIndex -reset;
	idAa -reset;
	idBeta -reset;
	idTa1Array -reset;
	idTa2Array -reset;
	idTa1AccentedWord -reset;														# Array of Onset time of accented word(one or multi accented words)
	idTa2AccentedWord -reset;														# Array of Offset time of accented word(one or multi accented words)
	idAccentWordIndex -reset;
	idAccentTimeArray -reset;
	idWordLengthArray -reset;
	idWordAccentTime -reset;
	
  	## Define a data object structure                                              	# -------------------------------------	
	"AccBegT" type double idLab -addcomp;											# Output data object
	"AccEndT" type double idLab -addcomp;
	"AccAa" type double idLab -addcomp;
	"AccBeta" type double idLab -addcomp;
		
	"EndTime" type double idLabWordEndTime -addcomp;

	"StarAcc" type long idAccentIndex -addcomp;
	"EndAcc" type long idAccentIndex -addcomp;

	"Ta1" type double idTa1Array -addcomp;	
	"Ta2" type double idTa2Array -addcomp;	
	"Aa" type double idAa -addcomp;
	"Beta" type double idBeta -addcomp;

	"Ta1Acc" type double idTa1AccentedWord -addcomp;	
	"Ta2Acc" type double idTa2AccentedWord -addcomp;	
	
	"AccInd" type long idAccentWordIndex -addcomp;	
	"AccTyp" type long idAccentWordIndex -addcomp;		
	
	"AccTime" type double idAccentTimeArray -addcomp;	

	"WordLen" type double idWordLengthArray -addcomp;		
	
	"WordTim" type double idWordAccentTime -addcomp;	


	## Calculate the End-Time of Word-Label and convert it from sample to second   	# -------------------------------------
	0 i =; 																			# Init a loop counter i	
	label L1;                                             							# Define a jump label named L1
	i nRecLabWord < if                                            	 				# If loop counter < (number of records)
		:idLabWord[i,1]: :idLabWord[i,2]: + nAux =; 								# End time = Start time + Length
		i 1 + idLabWordEndTime -reallocate;										    # Reallocates a new record of memory keeping the contents
		:idLabWordEndTime[i,0]=nAux;												# Assign end time
		i ++=;                                              						# Increment loop counter i
  		goto L1;                                            						# Jump to label L1
	end                                                 							# End of conditional branch

	idLabWordEndTime nSampRate / idLabWordEndTime =;								# Convert End time from Sample to Second


	## Find the index of Accent														# -------------------------------------		
	nAccentJ 0 > if																	# There is at least one accent
		5 nPhraseI + j =; 															# Init a loop counter j	(The first five records: F0-Nr., Phrase Nr., Accent-Nr., Fb, F0-rate)
		label L2;                                             						# Define a jump label named L2
		j nRecPAC < if                                            	 				# If loop counter < (number of records)

			:idPAC[j,0]: Ta1 =;														# Onset time of accent command
			Ta1 0 < if																# Onset time of accent command is negative >>
				0 Ta1 =;															# Onset time = 0
			end																	# <<

			:idPAC[j,1]: Ta2 =;														# Offset time of accent command
			Ta2 :idLabWordEndTime[idLabWordEndTime.nrec-1,0]: > if					# Offset time of accent is greater than end time of signal >>
				:idLabWordEndTime[idLabWordEndTime.nrec-1,0]: Ta2 =;				# Offset time = end time of signal
			end																	# <<

			:idPAC[j,2]: Aa =;														# Amplitude of accent command
			:idPAC[j,3]: Beta =;													# Time constant for accent control mechanism
			Ta2 Ta1 - nAccDur =;													# Duration of accent command

			nAccDur nAccDurBottom >= nAccDur nAccDurTop < Aa nAccAmpBottom > && && if # Offset time > Onset time
				## Difference between Onset time of accent and End-Time of word		#   - - - - - - - - - - - - - - - - - -	
				## And Difference between  Offset time and End-Time of the word		#   - - - - - - - - - - - - - - - - - -	
				idTa1DiffArray -reset;												# Reset data object
				"DiffTa1" type double idTa1DiffArray -addcomp;						# Difference between Onset time of accent and End-Time of word
				idTa2DiffArray -reset;												# Reset data object
				"DiffTa2" type double idTa2DiffArray -addcomp;						# Difference between Offset time of accent and End-Time of word

				0 jj =; 															# Init a loop counter jj
				label L3;                                             				# Define a jump label named L3
				jj idLabWordEndTime.nrec < if                                       # If loop counter < (number of records)
					## Difference between Onset time of accent and End-Time of word
					Ta1 :idLabWordEndTime[jj,0]: - nTa1Diff =;						# Difference between Onset time of accent and End-Time of word
					jj 1 + idTa1DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idTa1DiffArray[jj,0]=nTa1Diff;									# Copy the value to data object
					## Difference between Offset time of accent and End-Time of word
					Ta2 :idLabWordEndTime[jj,0]: - nTa2Diff =;						# Difference between Offset time of accent and End-Time of word
					jj 1 + idTa2DiffArray -reallocate;								# Reallocates a new record of memory keeping the contents
					:idTa2DiffArray[jj,0]=nTa2Diff;									# Copy the value to data object
					jj ++=;                                              			# Increment loop counter jj
  					goto L3;                                            			# Jump to label L3
				end                                                 				# End of conditional branch
			
				## Find the index of word, whereas an accent start					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L4;                                             				# Define a jump label named L4
				jj idTa1DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idTa1DiffArray[jj,0]: 0 < if									# Find the first negative value
						jj nAccStartIndex =;										# Index of word
						goto L5; # Exit from loop                       			# Jump to label L5
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L4;                                            			# Jump to label L4
				end                                                 				# End of conditional branch
			
				label L5;                                             				# Define a jump label named L5

				## Find the index of word, whereas an accent ended					#   - - - - - - - - - - - - - - - - - -
				0 jj =; 															# Init a loop counter jj
				label L6;                                             				# Define a jump label named L6
				jj idTa2DiffArray.nrec < if                                       	# If loop counter < (number of records)
					:idTa2DiffArray[jj,0]: 0 <= if									# Find the first negative value
						jj nAccEndIndex =;											# Index of word
						goto L7; # Exit from loop                       			# Jump to label L7
					end			
					jj ++=;                                              			# Increment loop counter jj
  					goto L6;                                            			# Jump to label L6
				end                                                 				# End of conditional branch
			
				label L7;                                             				# Define a jump label named L7

				g 1 + idAccentIndex -reallocate;									# Reallocates a new record of memory keeping the contents
				:idAccentIndex[g,0]=nAccStartIndex;									# Start index of accent
				:idAccentIndex[g,1]=nAccEndIndex;									# End index of accent

				g 1 + idTa1Array -reallocate;										# Reallocates a new record of memory keeping the contents
				g 1 + idTa2Array -reallocate;										# Reallocates a new record of memory keeping the contents
				g 1 + idAa -reallocate;												# Reallocates a new record of memory keeping the contents
				g 1 + idBeta -reallocate;											# Reallocates a new record of memory keeping the contents
				:idTa1Array[g,0]=Ta1;												# Onset time of accent command
				:idTa2Array[g,0]=Ta2;												# Offset time of accent command
				:idAa[g,0]=Aa;														# Amplitude of accent command
				:idBeta[g,0]=Beta;													# Time constant for accent control mechanism
				
				## Test if the accent is in one word or extended in several words	#   - - - - - - - - - - - - - - - - - -                   
				nAccStartIndex nAccEndIndex == if									# Accent command is in one word
					:idLabWord[nAccStartIndex,0]: sWord =;							# Read the word
					sWord sPause != if												# Word is not a pause (Accent is in a word and not in a pause)
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=nAccStartIndex;						# Index of word
						:idAccentWordIndex[g,1]=1;									# 1 = accent, 0 = no accent
					else
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=0;									# Index = 0 (Pause)
						:idAccentWordIndex[g,1]=0;									# 1 = accent, 0 = no accent
					end
				
					g 1 + idAccentTimeArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idAccentTimeArray[g,0]=Ta2-Ta1;								# Length of accent in one word

					## Length of accented word
					nAccStartIndex 0 > if
						:idLabWordEndTime[nAccStartIndex,0]: :idLabWordEndTime[nAccStartIndex-1,0]: - nWordLeng =;
					else
					nAccStartIndex 0 == if
						:idLabWordEndTime[nAccStartIndex,0]: nWordLeng =;
					end
					end

					g 1 + idWordLengthArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idWordLengthArray[g,0]=nWordLeng;

					## Calculate the really onset and offset time of accent			#   - - - - - - - - - - - - - - - - - -
					g 1 + idTa1AccentedWord -reallocate;							# Reallocates a new record of memory keeping the contents
					g 1 + idTa2AccentedWord -reallocate;							# Reallocates a new record of memory keeping the contents
					:idTa1AccentedWord[g,0]=Ta1;									# Onset time of accent command
					:idTa2AccentedWord[g,0]=Ta2;									# Offset time of accent command

				else
				nAccStartIndex nAccEndIndex < if									# Accent command extended in several words
					0 f =;															# Init a variable f
					nAccStartIndex jjj =; 											# Init a loop counter jjj
					label L8;                                             			# Define a jump label named L8
					jjj nAccEndIndex <= if                                       	# If loop counter <= EndIndex

						jjj nAccStartIndex == if									# Accent command is in the first word
							Ta1 :idLabWordEndTime[jjj,0]: - nWordTime =;			# Difference between Begin-Time of accent and End-Time of word
							:nWordTimeAbs=abs(nWordTime);							# Absolute value of difference
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTimeAbs;
							f ++=;
						else
						jjj nAccStartIndex > jjj nAccEndIndex < && if
							:idLabWordEndTime[jjj,0]: :idLabWordEndTime[jjj-1,0]: - nWordTime =;# Difference between End-Time of word and Begin-Time of word 
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTime;
							f ++=;
						else
						jjj nAccEndIndex == if
							Ta2 :idLabWordEndTime[jjj-1,0]: - nWordTime =;			# Difference between End-Time of accent End-Time of word
							f 1 + idWordAccentTime -reallocate;						# Reallocates a new record of memory keeping the contents
							:idWordAccentTime[f,0]=nWordTime;
							f ++=;						
						end						
						end
						end			
						
						jjj ++=;                                              		# Increment loop counter jjj
  						goto L8;                                            		# Jump to label L8
					end                                                 			# End of conditional branch				

					## Find the maximal time for words in an accent command			#   - - - - - - - - - - - - - - - - - -
					0 nAuxMax =;
					0 jj =; 														# Init a loop counter jj
					label L9;                                             			# Define a jump label named L9
					jj idWordAccentTime.nrec < if                                   # If loop counter < (number of records)
						:idWordAccentTime[jj,0]: nAuxMax > if						# Find the maximum value
							:idWordAccentTime[jj,0]: nAuxMax =;						# maximum value
						end			
						jj ++=;                                              		# Increment loop counter jj
  						goto L9;                                            		# Jump to label L9
					end                                                 			# End of conditional branch				

					g 1 + idAccentTimeArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idAccentTimeArray[g,0]=nAuxMax;								# Length of accent in one word

					## Index of accented word in accent command with several words	#   - - - - - - - - - - - - - - - - - -
					0 nAccMultiIndex =;
					0 jj =; 														# Init a loop counter jj
					label L90;                                             			# Define a jump label named L90
					jj idWordAccentTime.nrec < if                                   # If loop counter < (number of records)
						:idWordAccentTime[jj,0]: nAuxMax == if						# Find the maximum value
							jj nAccMultiIndex =;									# Index of a maximum value in an accent command
						end			
						jj ++=;                                              		# Increment loop counter jj
  						goto L90;                                            		# Jump to label L90
					end                                                 			# End of conditional branch						

					## Index of accented word in sentence							#   - - - - - - - - - - - - - - - - - -
					nAccStartIndex nAccMultiIndex + nAccSeveralWordsIndex =;		# Index of word in idLabWordEndTime (with pauses)

					## Length of accented word
					nAccSeveralWordsIndex 0 > if
						:idLabWordEndTime[nAccSeveralWordsIndex,0]: :idLabWordEndTime[nAccSeveralWordsIndex-1,0]: - nWordLeng =;
					else
					nAccSeveralWordsIndex 0 == if
						:idLabWordEndTime[nAccSeveralWordsIndex,0]: nWordLeng =;
					end
					end

  					g 1 + idWordLengthArray -reallocate;							# Reallocates a new record of memory keeping the contents
					:idWordLengthArray[g,0]=nWordLeng;
					
					## Calculate the really onset and offset time of accent			#   - - - - - - - - - - - - - - - - - -
					Ta1 :idLabWordEndTime[nAccSeveralWordsIndex-1,0]: < nAccSeveralWordsIndex 0 > && if
						g 1 + idTa1AccentedWord -reallocate;						# Reallocates a new record of memory keeping the contents
						:idTa1AccentedWord[g,0]=idLabWordEndTime[nAccSeveralWordsIndex-1,0];# Onset time of accent command
					else
						g 1 + idTa1AccentedWord -reallocate;						# Reallocates a new record of memory keeping the contents
						:idTa1AccentedWord[g,0]=Ta1;								# Onset time of accent command
					end

					Ta2 :idLabWordEndTime[nAccSeveralWordsIndex,0]: > if
						g 1 + idTa2AccentedWord -reallocate;						# Reallocates a new record of memory keeping the contents
						:idTa2AccentedWord[g,0]=idLabWordEndTime[nAccSeveralWordsIndex,0];# Offset time of accent command
					else
						g 1 + idTa2AccentedWord -reallocate;						# Reallocates a new record of memory keeping the contents
						:idTa2AccentedWord[g,0]=Ta2;								# Offset time of accent command					
					end

					## Test, whereas the accent is in word or in pause
					:idLabWord[nAccSeveralWordsIndex,0]: sWord =;					# Read the word
					sWord sPause != if												# Word is not a pause (Accent is in a word and not in a pause)
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=nAccSeveralWordsIndex;				# Index of word
						:idAccentWordIndex[g,1]=1;									# 1 = accent, 0 = no accent
					else
						g 1 + idAccentWordIndex -reallocate;						# Reallocates a new record of memory keeping the contents
						:idAccentWordIndex[g,0]=0;									# Index = 0 (Pause)
						:idAccentWordIndex[g,1]=0;									# 1 = accent, 0 = no accent
					end

				end
				end
				g ++=; 
			end                                      								# End of conditional branch
			j ++=;                                              					# Increment loop counter j
  			goto L2;                                            					# Jump to label L2
		end                                                 						# End of conditional branch
	end                                                 							# End of conditional branch <<


	
#00 break;


	var nAccCount;
	0 nAccCount =;
	
	## Number of accented words
	idAccentWordIndex.nrec nAccCount =;

		
	## Two complete accents are in the same word 									# -------------------------------------
	idAccentWordIndex.nrec 1 > if													# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L10;                                             						# Define a jump label named L10
		jj idAccentWordIndex.nrec 1 - < if                                   					# If loop counter < (number of records)
			:idAccentIndex[jj,0]: :idAccentIndex[jj+1,1]: == :idAccentIndex[jj,1]: :idAccentIndex[jj+1,0]: == && if	
				# There are two accents in the same word --> Delete the first accent
				:idAccentIndex[jj,0]=0;
				:idAccentIndex[jj,1]=0;

				:idAccentWordIndex[jj,0]=0;
				:idAccentWordIndex[jj,1]=0;
				
				:idAccentTimeArray[jj,0]=0;
				:idAccentTimeArray[jj+1,0]=idTa2Array[jj+1,0]-idTa1Array[jj,0];		# Begin: Begin of first accent and End: End of second accent

				:idTa1Array[jj+1,0]=idTa1Array[jj,0];								# Begin: Begin of first accent and End: End of second accent
				:idTa1Array[jj,0]=0;			
				:idTa2Array[jj,0]=0;

				:idTa1AccentedWord[jj+1,0]=idTa1AccentedWord[jj,0];					# Begin: Begin of first accent and End: End of second accent
				:idTa1AccentedWord[jj,0]=0;			
				:idTa2AccentedWord[jj,0]=0;

				:idWordLengthArray[jj,0]=0;
				
				:idAa[jj,0]=0;
				
				:idBeta[jj,0]=0;								
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L10;                                            					# Jump to label L10
		end                                                 						# End of conditional branch	
	end

#01 break;
	
	data idAccentIndexNew;
	data idAccentWordIndexNew;
	data idAccentTimeArrayNew;
	data idTa1ArrayNew;
	data idTa2ArrayNew;
	data idTa1AccentedWordNew;
	data idTa2AccentedWordNew;
	data idWordLengthArrayNew;
	data idAaNew;
	data idBetaNew;

  	## Reset data                                                                 	# -------------------------------------	
	idAccentIndexNew -reset;
	idAccentWordIndexNew -reset;
	idAccentTimeArrayNew -reset;
	idTa1ArrayNew -reset;
	idTa2ArrayNew -reset;
	idTa1AccentedWordNew -reset;
	idTa2AccentedWordNew -reset;	
	idWordLengthArrayNew -reset;
	idAaNew -reset;
	idBetaNew -reset;

  	## Define a data object structure                                              	# -------------------------------------
	"StarAcc" type long idAccentIndexNew -addcomp;
	"EndAcc" type long idAccentIndexNew -addcomp;

	"AccInd" type long idAccentWordIndexNew -addcomp;	
	"AccTyp" type long idAccentWordIndexNew -addcomp;		
	
	"AccTime" type double idAccentTimeArrayNew -addcomp;	

	"Ta1" type double idTa1ArrayNew -addcomp;
	"Ta2" type double idTa2ArrayNew -addcomp;	

	"Ta1" type double idTa1AccentedWordNew -addcomp;
	"Ta2" type double idTa2AccentedWordNew -addcomp;
		
	"WordLen" type double idWordLengthArrayNew -addcomp;
	
	"Aa" type double idAaNew -addcomp;
	"Beta" type double idBetaNew -addcomp;
	
	## Delete 0 value, if two accents are in the same word or if accent in pause	# -------------------------------------				
	0 jjj =;																		# New counter for accents
	
	0 jj =; 																		# Init a loop counter jj
	label L11;                                             							# Define a jump label named L11
	jj idAccentWordIndex.nrec < if                                   				# If loop counter < (number of records)
		:idAccentWordIndex[jj,0]: 0 != :idAccentWordIndex[jj,1]: 0 != && if	
			jjj 1 + idAccentIndexNew -reallocate;									# Reallocates a new record of memory keeping the contents
			:idAccentIndexNew[jjj,0]=idAccentIndex[jj,0];
			:idAccentIndexNew[jjj,1]=idAccentIndex[jj,1];

			jjj 1 + idAccentWordIndexNew -reallocate;								# Reallocates a new record of memory keeping the contents
			:idAccentWordIndexNew[jjj,0]=idAccentWordIndex[jj,0];
			:idAccentWordIndexNew[jjj,1]=idAccentWordIndex[jj,1];

			jjj 1 + idAccentTimeArrayNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idAccentTimeArrayNew[jjj,0]=idAccentTimeArray[jj,0];

			jjj 1 + idTa1ArrayNew -reallocate;										# Reallocates a new record of memory keeping the contents				
			:idTa1ArrayNew[jjj,0]=idTa1Array[jj,0];
			
			jjj 1 + idTa2ArrayNew -reallocate;										# Reallocates a new record of memory keeping the contents				
			:idTa2ArrayNew[jjj,0]=idTa2Array[jj,0];

			jjj 1 + idTa1AccentedWordNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idTa1AccentedWordNew[jjj,0]=idTa1AccentedWord[jj,0];

			jjj 1 + idTa2AccentedWordNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idTa2AccentedWordNew[jjj,0]=idTa2AccentedWord[jj,0];
						
			jjj 1 + idWordLengthArrayNew -reallocate;								# Reallocates a new record of memory keeping the contents				
			:idWordLengthArrayNew[jjj,0]=idWordLengthArray[jj,0];

			jjj 1 + idAaNew -reallocate;											# Reallocates a new record of memory keeping the contents				
			:idAaNew[jjj,0]=idAa[jj,0];
			
			jjj 1 + idBetaNew -reallocate;											# Reallocates a new record of memory keeping the contents				
			:idBetaNew[jjj,0]=idBeta[jj,0];			
			jjj ++=;
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L11;                                            						# Jump to label L11
	end                                                 							# End of conditional branch		

#02 break;

	## New number of accented words
	idAccentWordIndexNew.nrec nAccCount =;
	

	## Two accents are in the same word, therefore delete the second accent			# -------------------------------------
	idAccentWordIndexNew.nrec 1 > if												# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L12;                                             						# Define a jump label named L12
		jj idAccentWordIndexNew.nrec 1 - < if                                   	# If loop counter < (number of records)
			:idAccentWordIndexNew[jj,0]: :idAccentWordIndexNew[jj+1,0]: == if		# If there are two accents in one word
				# There are two accents in the same word --> Delete the second accent
				:idAccentIndexNew[jj+1,0]=0;
				:idAccentIndexNew[jj+1,1]=0;

				:idAccentWordIndexNew[jj+1,0]=0;
				:idAccentWordIndexNew[jj+1,1]=0;

				:idAccentTimeArrayNew[jj,0]=idAccentTimeArrayNew[jj,0]+idAccentTimeArrayNew[jj+1,0];
				:idAccentTimeArrayNew[jj+1,0]=0;				

				:idTa2ArrayNew[jj,0]=idTa2ArrayNew[jj+1,0];
				:idTa1ArrayNew[jj+1,0]=0;
				:idTa2ArrayNew[jj+1,0]=0;			

				:idTa2AccentedWordNew[jj,0]=idTa2AccentedWordNew[jj+1,0];
				:idTa1AccentedWordNew[jj+1,0]=0;
				:idTa2AccentedWordNew[jj+1,0]=0;

				:idWordLengthArrayNew[jj+1,0]=0;

				:idAaNew[jj+1,0]=0;

				:idBetaNew[jj+1,0]=0;								
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L12;                                            					# Jump to label L12
		end                                                 						# End of conditional branch	
	end

#03 break;  
        
	## Delete 0 value, if two accents are in the same word							# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L13;                                             							# Define a jump label named L13
	jj idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
		:idAccentWordIndexNew[jj,0]: 0 == :idAccentWordIndexNew[jj,1]: 0 == && if	# Accent index = 0
			idAccentIndexNew jj 1 idAccentIndexNew /rec -delete;

			idAccentWordIndexNew jj 1 idAccentWordIndexNew /rec -delete;

			idAccentTimeArrayNew jj 1 idAccentTimeArrayNew /rec -delete;

			idTa1ArrayNew jj 1 idTa1ArrayNew /rec -delete;
			idTa2ArrayNew jj 1 idTa2ArrayNew /rec -delete;

			idTa1AccentedWordNew jj 1 idTa1AccentedWordNew /rec -delete;
			idTa2AccentedWordNew jj 1 idTa2AccentedWordNew /rec -delete;
									
			idWordLengthArrayNew jj 1 idWordLengthArrayNew /rec -delete;

			idAaNew jj 1 idAaNew /rec -delete;

			idBetaNew jj 1 idBetaNew /rec -delete;								
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L13;                                            						# Jump to label L13
	end                                                 							# End of conditional branch

	## New number of accented words
	idAccentWordIndexNew.nrec nAccCount =;

#04 break;   		


	var nWordLengPercent;															# 60% of word duration
	0 nWordLengPercent =;

	## Delete an accent, if accent duration is smaller than 60% of word duration	# -------------------------------------
	## AND if duration of accented word is smaller than 200 msec					# -------------------------------------
	nAccCount 0 > if																# There are at least two accents
		0 jj =; 																	# Init a loop counter jj
		label L14;                                             						# Define a jump label named L14
		jj idAccentWordIndexNew.nrec < if                                   		# If loop counter < (number of records)
			:idWordLengthArrayNew[jj,0]: nPercentAccDurWord * nWordLengPercent =;	# 60% of word duration
			# accent duration is smaller than 60% of word duration AND duration of accented word is smaller than 200 msec
			:idAccentTimeArrayNew[jj,0]: nWordLengPercent <= :idWordLengthArrayNew[jj,0]: nAccentedWordDurBottom <= && if 

				:idAccentIndexNew[jj,0]=0;
				:idAccentIndexNew[jj,1]=0;

				:idAccentWordIndexNew[jj,0]=0;
				:idAccentWordIndexNew[jj,1]=0;

				:idAccentTimeArrayNew[jj,0]=0;				

				:idTa1ArrayNew[jj,0]=0;
				:idTa2ArrayNew[jj,0]=0;

				:idTa1AccentedWordNew[jj,0]=0;
				:idTa2AccentedWordNew[jj,0]=0;

				:idWordLengthArrayNew[jj,0]=0;

				:idAaNew[jj,0]=0;

				:idBetaNew[jj,0]=0;								
			end			
			jj ++=;                                              					# Increment loop counter jj
  			goto L14;                                            					# Jump to label L14
		end                                                 						# End of conditional branch	
	end


#05 break;  
  
	## Delete 0 value, if accent duration is smaller than 60% of word duration		# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L15;                                             							# Define a jump label named L15
	jj idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
		:idAccentWordIndexNew[jj,0]: 0 == :idAccentWordIndexNew[jj,1]: 0 == && if	# Accent index = 0
			idAccentIndexNew jj 1 idAccentIndexNew /rec -delete;

			idAccentWordIndexNew jj 1 idAccentWordIndexNew /rec -delete;				

			idAccentTimeArrayNew jj 1 idAccentTimeArrayNew /rec -delete;					

			idTa1ArrayNew jj 1 idTa1ArrayNew /rec -delete;
			idTa2ArrayNew jj 1 idTa2ArrayNew /rec -delete;

			idTa1AccentedWordNew jj 1 idTa1AccentedWordNew /rec -delete;
			idTa2AccentedWordNew jj 1 idTa2AccentedWordNew /rec -delete;

			idWordLengthArrayNew jj 1 idWordLengthArrayNew /rec -delete;

			idAaNew jj 1 idAaNew /rec -delete;

			idBetaNew jj 1 idBetaNew /rec -delete;								
		end			
		jj ++=;                                              						# Increment loop counter jj
  		goto L15;                                            						# Jump to label L15
	end                                                 							# End of conditional branch

#06 break;

	## Save Accent parameter (onset time and offset time of accent, Aa, beta)		# -------------------------------------				
	0 jj =; 																		# Init a loop counter jj
	label L16;                                             							# Define a jump label named L16
	jj idAccentWordIndexNew.nrec < if                                   			# If loop counter < (number of records)
		jj 1 + idLab -reallocate;													# Reallocates a new record of memory keeping the contents

		:idLab[jj,0]=idTa1AccentedWordNew[jj,0];
		:idLab[jj,1]=idTa2AccentedWordNew[jj,0];		
		:idLab[jj,2]=idAaNew[jj,0];
		:idLab[jj,3]=idBetaNew[jj,0];				
		jj ++=;                                              						# Increment loop counter jj
  		goto L16;                                            						# Jump to label L16
	else
	idAccentWordIndexNew.nrec 0 == if                                   			# No accent commands	
		idLab -reset;
	end
	end                                                 							# End of conditional branch

			
#100 break;

}









## EOF
